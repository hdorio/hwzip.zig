const std = @import("std");
const allocator = std.heap.page_allocator;
const assert = std.debug.assert;
const expect = std.testing.expect;
const math = std.math;
const mem = std.mem;

const zip = @import("./zip.zig");

const time = @import("./time.zig");
const hamlet = @embedFile("../fixtures/hamlet.txt");

const UINT16_MAX = math.maxInt(u16);
fn strlen(str: [*:0]const u8) usize {
    return mem.indexOfSentinel(u8, 0x00, str);
}

// Created by:
// $ echo -n foo > foo
// $ echo -n nanananana > bar
// $ mkdir dir
// $ echo -n baz > dir/baz
// $ touch --date="2019-09-21 12:34:56" foo bar dir dir/baz
// $ zip test.zip --entry-comments --archive-comment -r foo bar dir
//   adding: foo (stored 0%)
//   adding: bar (deflated 40%)
//   adding: dir/ (stored 0%)
//   adding: dir/baz (stored 0%)
// Enter comment for foo:
// foo
// Enter comment for bar:
// bar
// Enter comment for dir/:
// dir
// Enter comment for dir/baz:
// dirbaz
// enter new zip file comment (end with .):
// testzip
// .
// $ xxd -i < test.zip
//
const basic_zip = [_]u8{
    0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x64,
    0x35, 0x4f, 0x21, 0x65, 0x73, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x00, 0x03, 0x00, 0x1c, 0x00, 0x66, 0x6f, 0x6f, 0x55, 0x54, 0x09,
    0x00, 0x03, 0xd0, 0xfc, 0x85, 0x5d, 0x5b, 0xca, 0x8b, 0x5d, 0x75, 0x78,
    0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00,
    0x00, 0x66, 0x6f, 0x6f, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x5c, 0x64, 0x35, 0x4f, 0x9d, 0x3a, 0x97, 0x4a, 0x06, 0x00,
    0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x1c, 0x00, 0x62, 0x61,
    0x72, 0x55, 0x54, 0x09, 0x00, 0x03, 0xd0, 0xfc, 0x85, 0x5d, 0x5b, 0xca,
    0x8b, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00,
    0x04, 0xe8, 0x03, 0x00, 0x00, 0xcb, 0x4b, 0xcc, 0x83, 0x42, 0x00, 0x50,
    0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x64, 0x35,
    0x4f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x04, 0x00, 0x1c, 0x00, 0x64, 0x69, 0x72, 0x2f, 0x55, 0x54, 0x09,
    0x00, 0x03, 0xd0, 0xfc, 0x85, 0x5d, 0x6e, 0xca, 0x8b, 0x5d, 0x75, 0x78,
    0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00,
    0x00, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c,
    0x64, 0x35, 0x4f, 0x98, 0x04, 0x24, 0x78, 0x03, 0x00, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x00, 0x07, 0x00, 0x1c, 0x00, 0x64, 0x69, 0x72, 0x2f, 0x62,
    0x61, 0x7a, 0x55, 0x54, 0x09, 0x00, 0x03, 0xd0, 0xfc, 0x85, 0x5d, 0xd0,
    0xfc, 0x85, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00,
    0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x62, 0x61, 0x7a, 0x50, 0x4b, 0x01,
    0x02, 0x1e, 0x03, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x64, 0x35,
    0x4f, 0x21, 0x65, 0x73, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x03, 0x00, 0x18, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x00, 0xa4, 0x81, 0x00, 0x00, 0x00, 0x00, 0x66, 0x6f, 0x6f, 0x55, 0x54,
    0x05, 0x00, 0x03, 0xd0, 0xfc, 0x85, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01,
    0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x66, 0x6f,
    0x6f, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x14, 0x00, 0x00, 0x00, 0x08,
    0x00, 0x5c, 0x64, 0x35, 0x4f, 0x9d, 0x3a, 0x97, 0x4a, 0x06, 0x00, 0x00,
    0x00, 0x0a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x18, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x40, 0x00, 0x00, 0x00, 0x62,
    0x61, 0x72, 0x55, 0x54, 0x05, 0x00, 0x03, 0xd0, 0xfc, 0x85, 0x5d, 0x75,
    0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03,
    0x00, 0x00, 0x62, 0x61, 0x72, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x0a,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x64, 0x35, 0x4f, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x18,
    0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0xed, 0x41, 0x83,
    0x00, 0x00, 0x00, 0x64, 0x69, 0x72, 0x2f, 0x55, 0x54, 0x05, 0x00, 0x03,
    0xd0, 0xfc, 0x85, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03,
    0x00, 0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x64, 0x69, 0x72, 0x50, 0x4b,
    0x01, 0x02, 0x1e, 0x03, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x64,
    0x35, 0x4f, 0x98, 0x04, 0x24, 0x78, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x00, 0x07, 0x00, 0x18, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0xa4, 0x81, 0xc1, 0x00, 0x00, 0x00, 0x64, 0x69, 0x72, 0x2f,
    0x62, 0x61, 0x7a, 0x55, 0x54, 0x05, 0x00, 0x03, 0xd0, 0xfc, 0x85, 0x5d,
    0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8,
    0x03, 0x00, 0x00, 0x64, 0x69, 0x72, 0x62, 0x61, 0x7a, 0x50, 0x4b, 0x05,
    0x06, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x38, 0x01, 0x00,
    0x00, 0x05, 0x01, 0x00, 0x00, 0x07, 0x00, 0x74, 0x65, 0x73, 0x74, 0x7a,
    0x69, 0x70,
};

// Created by:
// (After running the steps for basic_zip above)
// $ curl -O https://www.hanshq.net/files/pkz204g.exe
// $ unzip pkz204g.exe PKZIP.EXE
// $ dosbox -c "mount c ." -c "c:" -c "pkzip pk.zip -P foo bar dir/baz" -c exit
// $ xxd -i < PK.ZIP
//
const pk_zip = [_]u8{
    0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x64,
    0x35, 0x4f, 0x21, 0x65, 0x73, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x46, 0x4f, 0x4f, 0x66, 0x6f, 0x6f,
    0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x64,
    0x35, 0x4f, 0x9d, 0x3a, 0x97, 0x4a, 0x0a, 0x00, 0x00, 0x00, 0x0a, 0x00,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x42, 0x41, 0x52, 0x6e, 0x61, 0x6e,
    0x61, 0x6e, 0x61, 0x6e, 0x61, 0x6e, 0x61, 0x50, 0x4b, 0x03, 0x04, 0x0a,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x64, 0x35, 0x4f, 0x98, 0x04, 0x24,
    0x78, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00,
    0x00, 0x44, 0x49, 0x52, 0x2f, 0x42, 0x41, 0x5a, 0x62, 0x61, 0x7a, 0x50,
    0x4b, 0x01, 0x02, 0x14, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c,
    0x64, 0x35, 0x4f, 0x21, 0x65, 0x73, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x4f, 0x4f,
    0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x5c, 0x64, 0x35, 0x4f, 0x9d, 0x3a, 0x97, 0x4a, 0x0a, 0x00, 0x00, 0x00,
    0x0a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x42, 0x41,
    0x52, 0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x5c, 0x64, 0x35, 0x4f, 0x98, 0x04, 0x24, 0x78, 0x03, 0x00, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x44,
    0x49, 0x52, 0x2f, 0x42, 0x41, 0x5a, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00,
    0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x97, 0x00, 0x00, 0x00, 0x77, 0x00,
    0x00, 0x00, 0x00, 0x00,
};

// From https://en.wikipedia.org/wiki/Zip_(file_format)#Limits
//
const empty_zip = [_]u8{
    0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// Created by:
// $ echo -n 1234567 > a
// $ curl -O https://www.hanshq.net/files/pkz204g.exe
// $ unzip pkz204g.exe PKZIP.EXE
// $ dosbox -c "mount c ." -c "c:" -c "pkzip a.zip a" -c exit
// $ xxd -i < A.ZIP | sed 's/0x07/0x4d/g'
//
// Why 0x4d? Because there is room for a 0x4c payload (if we allow it to
// overlap with the cfh and eocdr):
// "1234567" (7 bytes) + cfh (46 bytes) + filename (1 byte) + eocdr (22 bytes)
//
const out_of_bounds_member_zip = [_]u8{
    0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x70,
    0x88, 0x4f, 0x9f, 0x69, 0x03, 0x50, 0x4d, 0x00, 0x00, 0x00, 0x4d, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x41, 0x31, 0x32, 0x33, 0x34, 0x35,
    0x36, 0x37, 0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x0a, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x70, 0x70, 0x88, 0x4f, 0x9f, 0x69, 0x03, 0x50, 0x4d, 0x00,
    0x00, 0x00, 0x4d, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x41, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x2f, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// Created by:
// $ for x in foo bar baz ; do echo $x > $x && zip $x.zip $x ; done
// $ zip test.zip foo.zip bar.zip baz.zip
// $ xxd -i < test.zip
//
const zip_in_zip = [_]u8{
    0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd2, 0x4b,
    0x8f, 0x4f, 0xfc, 0xe0, 0x94, 0x8d, 0xa0, 0x00, 0x00, 0x00, 0xa0, 0x00,
    0x00, 0x00, 0x07, 0x00, 0x1c, 0x00, 0x66, 0x6f, 0x6f, 0x2e, 0x7a, 0x69,
    0x70, 0x55, 0x54, 0x09, 0x00, 0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x2c, 0xef,
    0xf5, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00,
    0x04, 0xe8, 0x03, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xd2, 0x4b, 0x8f, 0x4f, 0xa8, 0x65, 0x32, 0x7e, 0x04,
    0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x1c, 0x00, 0x66,
    0x6f, 0x6f, 0x55, 0x54, 0x09, 0x00, 0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x0b,
    0xef, 0xf5, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00,
    0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x66, 0x6f, 0x6f, 0x0a, 0x50, 0x4b,
    0x01, 0x02, 0x1e, 0x03, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd2, 0x4b,
    0x8f, 0x4f, 0xa8, 0x65, 0x32, 0x7e, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00,
    0x00, 0x00, 0x03, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0xa4, 0x81, 0x00, 0x00, 0x00, 0x00, 0x66, 0x6f, 0x6f, 0x55,
    0x54, 0x05, 0x00, 0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x75, 0x78, 0x0b, 0x00,
    0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x50,
    0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x49,
    0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x03,
    0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd2, 0x4b, 0x8f, 0x4f, 0x09,
    0x2e, 0x40, 0x1a, 0xa0, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x07,
    0x00, 0x1c, 0x00, 0x62, 0x61, 0x72, 0x2e, 0x7a, 0x69, 0x70, 0x55, 0x54,
    0x09, 0x00, 0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x2c, 0xef, 0xf5, 0x5d, 0x75,
    0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03,
    0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xd2, 0x4b, 0x8f, 0x4f, 0xe9, 0xb3, 0xa2, 0x04, 0x04, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x1c, 0x00, 0x62, 0x61, 0x72, 0x55,
    0x54, 0x09, 0x00, 0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x0b, 0xef, 0xf5, 0x5d,
    0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8,
    0x03, 0x00, 0x00, 0x62, 0x61, 0x72, 0x0a, 0x50, 0x4b, 0x01, 0x02, 0x1e,
    0x03, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd2, 0x4b, 0x8f, 0x4f, 0xe9,
    0xb3, 0xa2, 0x04, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03,
    0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa4,
    0x81, 0x00, 0x00, 0x00, 0x00, 0x62, 0x61, 0x72, 0x55, 0x54, 0x05, 0x00,
    0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8,
    0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x50, 0x4b, 0x05, 0x06,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x49, 0x00, 0x00, 0x00,
    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xd2, 0x4b, 0x8f, 0x4f, 0x38, 0xcd, 0x36, 0x40,
    0xa0, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x07, 0x00, 0x1c, 0x00,
    0x62, 0x61, 0x7a, 0x2e, 0x7a, 0x69, 0x70, 0x55, 0x54, 0x09, 0x00, 0x03,
    0x2c, 0xef, 0xf5, 0x5d, 0x2c, 0xef, 0xf5, 0x5d, 0x75, 0x78, 0x0b, 0x00,
    0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x50,
    0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd2, 0x4b, 0x8f,
    0x4f, 0xe1, 0x39, 0x7b, 0xcc, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
    0x00, 0x03, 0x00, 0x1c, 0x00, 0x62, 0x61, 0x7a, 0x55, 0x54, 0x09, 0x00,
    0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x0b, 0xef, 0xf5, 0x5d, 0x75, 0x78, 0x0b,
    0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00, 0x00,
    0x62, 0x61, 0x7a, 0x0a, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x0a, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xd2, 0x4b, 0x8f, 0x4f, 0xe1, 0x39, 0x7b, 0xcc,
    0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x18, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x00, 0x00,
    0x00, 0x00, 0x62, 0x61, 0x7a, 0x55, 0x54, 0x05, 0x00, 0x03, 0x2c, 0xef,
    0xf5, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00,
    0x04, 0xe8, 0x03, 0x00, 0x00, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x49, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x0a, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xd2, 0x4b, 0x8f, 0x4f, 0xfc, 0xe0, 0x94, 0x8d, 0xa0,
    0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x07, 0x00, 0x18, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x00, 0x00, 0x00,
    0x00, 0x66, 0x6f, 0x6f, 0x2e, 0x7a, 0x69, 0x70, 0x55, 0x54, 0x05, 0x00,
    0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8,
    0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x50, 0x4b, 0x01, 0x02,
    0x1e, 0x03, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd2, 0x4b, 0x8f, 0x4f,
    0x09, 0x2e, 0x40, 0x1a, 0xa0, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xa4, 0x81, 0xe1, 0x00, 0x00, 0x00, 0x62, 0x61, 0x72, 0x2e, 0x7a, 0x69,
    0x70, 0x55, 0x54, 0x05, 0x00, 0x03, 0x2c, 0xef, 0xf5, 0x5d, 0x75, 0x78,
    0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x04, 0xe8, 0x03, 0x00,
    0x00, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x0a, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xd2, 0x4b, 0x8f, 0x4f, 0x38, 0xcd, 0x36, 0x40, 0xa0, 0x00, 0x00,
    0x00, 0xa0, 0x00, 0x00, 0x00, 0x07, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x81, 0xc2, 0x01, 0x00, 0x00, 0x62,
    0x61, 0x7a, 0x2e, 0x7a, 0x69, 0x70, 0x55, 0x54, 0x05, 0x00, 0x03, 0x2c,
    0xef, 0xf5, 0x5d, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xe8, 0x03, 0x00,
    0x00, 0x04, 0xe8, 0x03, 0x00, 0x00, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00,
    0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0xe7, 0x00, 0x00, 0x00, 0xa3, 0x02,
    0x00, 0x00, 0x00, 0x00,
};

// Created by:
// $ echo -n 1234567 > a
// $ curl -O https://www.hanshq.net/files/pkz204g.exe
// $ unzip pkz204g.exe PKZIP.EXE
// $ dosbox -c "mount c ." -c "c:" -c "pkzip a.zip a" -c exit
// $ xxd -i < A.ZIP
//
// Then hand modify the lowest byte in uncomp_size from 0x07 to 0x08.
// This makes the uncompressed size not match the compressed size as it should.
//
const bad_stored_uncomp_size_zip = [_]u8{
    0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x70,
    0x88, 0x4f, 0x9f, 0x69, 0x03, 0x50, 0x07, 0x00, 0x00, 0x00, 0x08, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x41, 0x31, 0x32, 0x33, 0x34, 0x35,
    0x36, 0x37, 0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x0a, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x70, 0x70, 0x88, 0x4f, 0x9f, 0x69, 0x03, 0x50, 0x07, 0x00,
    0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x41, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x2f, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00,
};

fn magic_time() time.time_t {
    var tm: time.tm_t = time.tm_t{};

    // 2019-09-21 12:34:56
    tm.tm_year = 2019 - 1900;
    tm.tm_mon = 9 - 1;
    tm.tm_mday = 21;
    tm.tm_hour = 12;
    tm.tm_min = 34;
    tm.tm_sec = 56;

    tm.tm_isdst = -1;

    return time.mktime(&tm);
}

fn check_extract2(m: *const zip.zipmemb_t, expected: [*]const u8, n: usize) !void {
    var uncomp: [*]u8 = undefined;

    try expect(m.uncomp_size == n);

    var uncomp_mem = try allocator.alloc(u8, n);
    uncomp = uncomp_mem.ptr;

    try expect(try zip.zip_extract_member(m, uncomp));
    try expect(mem.eql(u8, uncomp[0..n], expected[0..n]));

    allocator.free(uncomp_mem);
}

fn check_extract(m: *zip.zipmemb_t, expected: [*]const u8) !void {
    var expected_str = @ptrCast([*:0]const u8, expected);
    try check_extract2(m, expected, strlen(expected_str));
}

test "zip_basic" {
    var z: zip.zip_t = undefined;
    var i: zip.zipiter_t = undefined;
    var m: zip.zipmemb_t = undefined;

    try expect(zip.zip_read(&z, basic_zip[0..], basic_zip.len));
    try expect(z.num_members == 4);
    try expect(z.comment_len == 7);
    try expect(mem.eql(u8, z.comment[0..7], "testzip"));

    i = z.members_begin;
    m = zip.zip_member(&z, i);
    try expect(m.name_len == 3);
    try expect(mem.eql(u8, m.name[0..3], "foo"));
    try expect(m.mtime == magic_time());
    try expect(m.comment_len == 3);
    try expect(mem.eql(u8, m.comment[0..3], "foo"));
    try expect(m.is_dir == false);
    try expect(m.crc32 == 0x8c73_6521);
    try check_extract(&m, "foo");

    i = m.next;
    m = zip.zip_member(&z, i);
    try expect(m.name_len == 3);
    try expect(mem.eql(u8, m.name[0..3], "bar"));
    try expect(m.mtime == magic_time());
    try expect(m.comment_len == 3);
    try expect(mem.eql(u8, m.comment[0..3], "bar"));
    try expect(m.is_dir == false);
    try expect(m.crc32 == 0x4a97_3a9d);
    try check_extract(&m, "nanananana");

    i = m.next;
    m = zip.zip_member(&z, i);
    try expect(m.name_len == 4);
    try expect(mem.eql(u8, m.name[0..4], "dir/"));
    try expect(m.mtime == magic_time());
    try expect(m.comment_len == 3);
    try expect(mem.eql(u8, m.comment[0..m.comment_len], "dir"));
    try expect(m.is_dir == true);

    i = m.next;
    m = zip.zip_member(&z, i);
    try expect(m.name_len == 7);
    try expect(mem.eql(u8, m.name[0..7], "dir/baz"));
    try expect(m.mtime == magic_time());
    try expect(mem.eql(u8, m.comment[0..6], "dirbaz"));
    try expect(m.is_dir == false);
    try expect(m.crc32 == 0x7824_0498);
    try check_extract(&m, "baz");

    i = m.next;
    try expect(i == z.members_end);
}

test "zip_pk" {
    var z: zip.zip_t = undefined;
    var i: zip.zipiter_t = undefined;
    var m: zip.zipmemb_t = undefined;

    try expect(zip.zip_read(&z, pk_zip[0..], pk_zip.len));
    try expect(z.num_members == 3);
    try expect(z.comment_len == 0);

    i = z.members_begin;
    m = zip.zip_member(&z, i);
    try expect(m.name_len == 3);
    try expect(mem.eql(u8, m.name[0..3], "FOO"));
    try expect(m.mtime == magic_time());
    try expect(m.comment_len == 0);
    try expect(m.is_dir == false);
    try expect(m.crc32 == 0x8c73_6521);
    try check_extract(&m, "foo");

    i = m.next;
    m = zip.zip_member(&z, i);
    try expect(m.name_len == 3);
    try expect(mem.eql(u8, m.name[0..3], "BAR"));
    try expect(m.mtime == magic_time());
    try expect(m.comment_len == 0);
    try expect(m.is_dir == false);
    try expect(m.crc32 == 0x4a97_3a9d);
    try check_extract(&m, "nanananana");

    i = m.next;
    m = zip.zip_member(&z, i);
    try expect(m.name_len == 7);
    try expect(mem.eql(u8, m.name[0..7], "DIR/BAZ"));
    try expect(m.mtime == magic_time());
    try expect(m.comment_len == 0);
    try expect(m.is_dir == false);
    try expect(m.crc32 == 0x7824_0498);
    try check_extract(&m, "baz");

    i = m.next;
    try expect(i == z.members_end);
}

test "zip_out_of_bounds_member" {
    var z: zip.zip_t = undefined;

    try expect(!zip.zip_read(&z, out_of_bounds_member_zip[0..], out_of_bounds_member_zip.len));
}

test "zip_empty" {
    var z: zip.zip_t = undefined;

    // Not enough bytes.
    try expect(!zip.zip_read(&z, empty_zip[0..], empty_zip.len - 1));

    try expect(zip.zip_read(&z, empty_zip[0..], empty_zip.len));
    try expect(z.comment_len == 0);
    try expect(z.num_members == 0);
    try expect(z.members_begin == z.members_end);
}

fn write_basic_callback(filename: [*]const u8, method: zip.method_t, size: u32, comp_size: u32) zip.CallbackError!void {
    const Static = struct {
        var n: u32 = 0;
    };
    const err = zip.CallbackError.WriteCallbackError;

    switch (Static.n) {
        0 => {
            expect(mem.eql(u8, filename[0..3], "one")) catch return err;
            expect(size == 3) catch return err;
            expect(comp_size <= 3) catch return err;
            expect(method == zip.method_t.ZIP_STORE) catch return err;
        },
        1 => {
            expect(mem.eql(u8, filename[0..3], "two")) catch return err;
            expect(size == 9) catch return err;
            expect(comp_size <= 9) catch return err;
            expect(method == zip.method_t.ZIP_DEFLATE) catch return err;
        },
        else => {
            expect(false) catch return err;
        },
    }

    Static.n += 1;
}

test "zip_write_basic" {
    const names = [_][*:0]const u8{ "one", "two" };
    const data1 = "foo";
    const data2 = "barbarbar";
    const data: [2][*]const u8 = [_][*]const u8{ data1, data2 };
    const sizes = [_]u32{ 3, 9 };
    var mtimes: [2]time.time_t = undefined;
    const comment = "comment";
    var max_size: usize = 0;
    var size: usize = 0;
    var out: [*]u8 = undefined;
    var in: [*]u8 = undefined;
    var z: zip.zip_t = undefined;
    var i: zip.zipiter_t = undefined;
    var m: zip.zipmemb_t = undefined;

    mtimes[0] = magic_time();
    mtimes[1] = mtimes[0];

    max_size = zip.zip_max_size(2, names[0..], sizes[0..], comment);
    var out_mem = try allocator.alloc(u8, max_size);
    out = out_mem.ptr;

    size = try zip.zip_write(out, 2, names[0..], &data, &sizes, &mtimes, comment, zip.method_t.ZIP_DEFLATE, write_basic_callback);

    var in_mem = try allocator.alloc(u8, size);
    in = in_mem.ptr;
    mem.copy(u8, in[0..size], out[0..size]);
    allocator.free(out_mem);

    try expect(zip.zip_read(&z, in, size));
    try expect(z.num_members == 2);
    try expect(z.comment_len == comment.len);
    try expect(mem.eql(u8, z.comment[0..z.comment_len], comment[0..z.comment_len]));

    i = z.members_begin;
    m = zip.zip_member(&z, i);
    try expect(m.name_len == strlen(names[0]));
    try expect(mem.eql(u8, m.name[0..m.name_len], names[0][0..m.name_len]));
    try expect(m.mtime == mtimes[0]);
    try expect(m.crc32 == 0x8c73_6521);
    try check_extract(&m, data[0]);

    i = m.next;
    m = zip.zip_member(&z, i);
    try expect(m.name_len == strlen(names[1]));
    try expect(mem.eql(u8, m.name[0..m.name_len], names[1][0..m.name_len]));
    try expect(m.mtime == mtimes[1]);
    try expect(m.crc32 == 0x5acc_11a8);
    try check_extract(&m, data[1]);

    i = m.next;
    try expect(i == z.members_end);

    allocator.free(in_mem);
}

test "zip_write_empty" {
    var max_size: usize = 0;
    var size: usize = 0;
    var out: [*]u8 = undefined;

    max_size = zip.zip_max_size(0, null, null, null);

    var out_mem = try allocator.alloc(u8, max_size);
    out = out_mem.ptr;

    size = try zip.zip_write(out, 0, null, null, null, null, null, zip.method_t.ZIP_DEFLATE, null);
    try expect(size == empty_zip.len);
    try expect(mem.eql(u8, out[0..size], empty_zip[0..size]));

    allocator.free(out_mem);
}

test "zip_max_comment" {
    var comment: [UINT16_MAX + 1:0]u8 = undefined;
    var max_size: usize = 0;
    var size: usize = 0;
    var out: [*]u8 = undefined;
    var z: zip.zip_t = undefined;

    mem.set(u8, comment[0..], 'a');
    comment[UINT16_MAX] = 0x00;

    max_size = zip.zip_max_size(0, null, null, &comment);
    var out_mem = try allocator.alloc(u8, max_size + 1000);
    out = out_mem.ptr;
    mem.set(u8, out[0 .. max_size + 1000], 0x00);
    size = try zip.zip_write(out, 0, null, null, null, null, &comment, zip.method_t.ZIP_DEFLATE, null);
    try expect(size <= max_size);
    try expect(size == empty_zip.len + UINT16_MAX);

    try expect(zip.zip_read(&z, out, size));
    try expect(z.comment_len == UINT16_MAX);
    try expect(mem.eql(u8, z.comment[0..UINT16_MAX], comment[0..UINT16_MAX]));
    try expect(z.num_members == 0);
    try expect(z.members_begin == z.members_end);

    // The EOCDR + comment don't fit.
    try expect(!zip.zip_read(&z, out, size - 1));

    // The EOCDR + comment should probably be at the end of the file as
    // per the spec, but neither Info-ZIP nor PKZIP are that picky.
    // There are files in the wild with some extra bytes at the end,
    // so we cannot be picky either.
    try expect(zip.zip_read(&z, out, size + 123));

    allocator.free(out_mem);
}

test "zip_in_zip" {
    var z: zip.zip_t = undefined;
    var i: zip.zipiter_t = undefined;
    var m: zip.zipmemb_t = undefined;

    try expect(zip.zip_read(&z, zip_in_zip[0..], zip_in_zip.len));
    try expect(z.num_members == 3);

    i = z.members_begin;
    m = zip.zip_member(&z, i);
    try expect(m.name_len == 7);
    try expect(mem.eql(u8, m.name[0..7], "foo.zip"));

    i = m.next;
    m = zip.zip_member(&z, i);
    try expect(m.name_len == 7);
    try expect(mem.eql(u8, m.name[0..7], "bar.zip"));

    i = m.next;
    m = zip.zip_member(&z, i);
    try expect(m.name_len == 7);
    try expect(mem.eql(u8, m.name[0..7], "baz.zip"));

    try expect(m.next == z.members_end);
}

test "zip_bad_stored_uncomp_size" {
    var z: zip.zip_t = undefined;

    try expect(!zip.zip_read(
        &z,
        &bad_stored_uncomp_size_zip,
        bad_stored_uncomp_size_zip.len,
    ));
}

// multizip - a zip file containing all the compression methods:
//
// for x in 092 110 250 ; do
//   dosbox -c "mount c ." -c "c:" -c "$(ls pk*$x*.exe) pkzip.exe" -c "exit"
//   mv PKZIP.EXE $x.exe
// done
//
// # Store
// echo -n foo > 0.txt
// dosbox -c "mount c ." -c "c:" -c "110 x.zip 0.txt" -c exit
//
// # Shrink
// echo -n ababcbababaaaaaaa > 1.txt
// dosbox -c "mount c ." -c "c:" -c "110 -es x.zip 1.txt" -c exit
//
// # Reduce
// for n in $(seq 2 5) ; do
//   rm -f $n.txt
//   for x in $(seq 1 42) ; do dd if=hamlet.txt bs=1 count=50 >> $n.txt ; done
// done
// dosbox -c "mount c ." -c "c:" -c "092 -ea1 x.zip 2.txt" -c "exit"
// dosbox -c "mount c ." -c "c:" -c "092 -ea2 x.zip 3.txt" -c "exit"
// dosbox -c "mount c ." -c "c:" -c "092 -ea3 x.zip 4.txt" -c "exit"
// dosbox -c "mount c ." -c "c:" -c "092 -ea4 x.zip 5.txt" -c "exit"
//
// # Implode
// # 4KB wnd, no lit tree; zipinfo "i4:2"
// dd if=/dev/zero of=61.txt bs=1 count=256
// dosbox -c "mount c ." -c "c:" -c "110 -ei x.zip 61.txt" -c exit
// # 8KB wnd, lit tree; zipinfo "i8:3"
// rm -f 62.txt
// for x in $(seq 1 200) ; do dd if=hamlet.txt bs=1 count=50 >> 62.txt ; done
// dosbox -c "mount c ." -c "c:" -c "110 -ei x.zip 62.txt" -c exit
//
// # Deflate
// dd if=hamlet.txt of=8.txt bs=1 count=128
// dosbox -c "mount c ." -c "c:" -c "250 -exx x.zip 8.txt" -c exit
//
const multizip = [_]u8{
    0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x4a,
    0x3b, 0x51, 0x21, 0x65, 0x73, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x30, 0x2e, 0x54, 0x58, 0x54, 0x66,
    0x6f, 0x6f, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x62, 0x4a, 0x3b, 0x51, 0x02, 0x04, 0x12, 0x39, 0x0c, 0x00, 0x00, 0x00,
    0x11, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x31, 0x2e, 0x54, 0x58,
    0x54, 0x61, 0xc4, 0x04, 0x1c, 0x23, 0xb0, 0x60, 0x98, 0x83, 0x08, 0xc3,
    0x00, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x63,
    0x4a, 0x3b, 0x51, 0x6e, 0x4e, 0x6d, 0x9c, 0x0a, 0x01, 0x00, 0x00, 0x34,
    0x08, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x32, 0x2e, 0x54, 0x58, 0x54,
    0xc2, 0xff, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x08, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x20, 0xb4, 0x8d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0xbb, 0xbf, 0x0d, 0x0a,
    0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x47, 0x75, 0x74, 0x65,
    0x6e, 0x62, 0x65, 0x72, 0x67, 0x20, 0x45, 0x42, 0x6f, 0x6f, 0x6b, 0x20,
    0x6f, 0x66, 0x20, 0x48, 0x61, 0xb0, 0x95, 0xd1, 0xb1, 0x80, 0x88, 0xe5,
    0x81, 0x5c, 0xa5, 0xb1, 0xb1, 0xa5, 0x85, 0x01, 0xf9, 0x25, 0x06, 0x72,
    0x98, 0x90, 0x1a, 0x1d, 0x43, 0xc2, 0x47, 0x48, 0x10, 0x10, 0x10, 0x7a,
    0xcc, 0x03, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x03, 0x00,
    0x63, 0x4a, 0x3b, 0x51, 0x6e, 0x4e, 0x6d, 0x9c, 0x0f, 0x01, 0x00, 0x00,
    0x34, 0x08, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x33, 0x2e, 0x54, 0x58,
    0x54, 0xc2, 0xff, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x24, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x08, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0xb4, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0xbb, 0xbf, 0x0d, 0x0a,
    0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x47, 0x75, 0x74, 0x65,
    0x6e, 0x62, 0x65, 0x72, 0x67, 0x20, 0x45, 0x42, 0x6f, 0x6f, 0x6b, 0x20,
    0x6f, 0x66, 0x20, 0x48, 0x61, 0xb0, 0x95, 0xd1, 0xb1, 0x80, 0x88, 0xe5,
    0x81, 0x5c, 0xa5, 0xb1, 0xb1, 0xa5, 0x85, 0x01, 0xf9, 0x25, 0x06, 0x52,
    0x91, 0x31, 0x48, 0x0d, 0x8f, 0x21, 0xff, 0xfd, 0x7f, 0x84, 0xfc, 0xfb,
    0x7f, 0x17, 0x12, 0x04, 0x04, 0x84, 0x1d, 0xe7, 0x50, 0x4b, 0x03, 0x04,
    0x0a, 0x00, 0x00, 0x00, 0x04, 0x00, 0x63, 0x4a, 0x3b, 0x51, 0x6e, 0x4e,
    0x6d, 0x9c, 0x16, 0x01, 0x00, 0x00, 0x34, 0x08, 0x00, 0x00, 0x05, 0x00,
    0x00, 0x00, 0x34, 0x2e, 0x54, 0x58, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1f, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xb4, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0xbb,
    0xbf, 0x0d, 0x0a, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x47,
    0x75, 0x74, 0x65, 0x6e, 0x62, 0x65, 0x72, 0x67, 0x20, 0x45, 0x42, 0x6f,
    0x6f, 0x6b, 0x20, 0x6f, 0x66, 0x20, 0x48, 0x61, 0xb0, 0x95, 0xd1, 0xb1,
    0x80, 0x88, 0xe5, 0x81, 0x5c, 0xa5, 0xb1, 0xb1, 0xa5, 0x85, 0x01, 0x09,
    0x44, 0x0c, 0x24, 0x42, 0x63, 0x90, 0x98, 0x1e, 0x43, 0xfe, 0xf9, 0x7f,
    0x84, 0xfc, 0xf5, 0x9f, 0x08, 0xf9, 0xef, 0xbf, 0x16, 0xf2, 0xe7, 0x7f,
    0x38, 0xe4, 0xef, 0xff, 0x06, 0x48, 0xbb, 0x0f, 0x00, 0x50, 0x4b, 0x03,
    0x04, 0x0a, 0x00, 0x00, 0x00, 0x05, 0x00, 0x63, 0x4a, 0x3b, 0x51, 0x6e,
    0x4e, 0x6d, 0x9c, 0x1a, 0x01, 0x00, 0x00, 0x34, 0x08, 0x00, 0x00, 0x05,
    0x00, 0x00, 0x00, 0x35, 0x2e, 0x54, 0x58, 0x54, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0f, 0x7f, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xb4, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef,
    0xbb, 0xbf, 0x0d, 0x0a, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x20,
    0x47, 0x75, 0x74, 0x65, 0x6e, 0x62, 0x65, 0x72, 0x67, 0x20, 0x45, 0x42,
    0x6f, 0x6f, 0x6b, 0x20, 0x6f, 0x66, 0x20, 0x48, 0x61, 0xb0, 0x95, 0xd1,
    0xb1, 0x80, 0x88, 0xe5, 0x81, 0x5c, 0xa5, 0xb1, 0xb1, 0xa5, 0x85, 0x01,
    0x09, 0x48, 0x0c, 0x24, 0x52, 0x63, 0x90, 0xd8, 0x1e, 0x43, 0xfe, 0xf8,
    0x7f, 0x84, 0xfc, 0xf2, 0x9f, 0x08, 0xf9, 0xe7, 0x7f, 0x10, 0xf2, 0xd3,
    0xff, 0x2b, 0xe4, 0xaf, 0xff, 0x54, 0xc8, 0x6f, 0xff, 0xd5, 0x90, 0xb2,
    0x3c, 0x03, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x06, 0x00,
    0x65, 0x4a, 0x3b, 0x51, 0x58, 0x85, 0x96, 0x0d, 0x1d, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x36, 0x31, 0x2e, 0x54,
    0x58, 0x54, 0x0f, 0x00, 0x12, 0x03, 0x24, 0x15, 0x36, 0x27, 0x38, 0x39,
    0x6a, 0x7b, 0x4c, 0x9d, 0x6e, 0x1f, 0x09, 0x06, 0x01, 0x13, 0x34, 0xe5,
    0xf6, 0x96, 0xf7, 0xfe, 0x04, 0xf8, 0x6f, 0x50, 0x4b, 0x03, 0x04, 0x0a,
    0x00, 0x06, 0x00, 0x06, 0x00, 0x65, 0x4a, 0x3b, 0x51, 0xf1, 0x0d, 0xc3,
    0x06, 0x19, 0x01, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x06, 0x00, 0x00,
    0x00, 0x36, 0x32, 0x2e, 0x54, 0x58, 0x54, 0x61, 0x0a, 0x7b, 0x07, 0x06,
    0x1b, 0x06, 0xbb, 0x0c, 0x4b, 0x03, 0x09, 0x07, 0x0b, 0x09, 0x0b, 0x09,
    0x07, 0x16, 0x07, 0x08, 0x06, 0x05, 0x06, 0x07, 0x06, 0x05, 0x36, 0x07,
    0x16, 0x17, 0x0b, 0x0a, 0x06, 0x08, 0x0a, 0x0b, 0x05, 0x06, 0x15, 0x04,
    0x06, 0x17, 0x05, 0x0a, 0x08, 0x05, 0x06, 0x15, 0x06, 0x0a, 0x25, 0x06,
    0x08, 0x07, 0x18, 0x0a, 0x07, 0x0a, 0x08, 0x0b, 0x07, 0x0b, 0x04, 0x25,
    0x04, 0x25, 0x04, 0x0a, 0x06, 0x04, 0x05, 0x14, 0x05, 0x09, 0x34, 0x07,
    0x06, 0x17, 0x09, 0x1a, 0x2b, 0xfc, 0xfc, 0xfc, 0xfb, 0xfb, 0xfb, 0x0c,
    0x0b, 0x2c, 0x0b, 0x2c, 0x0b, 0x3c, 0x0b, 0x2c, 0x2b, 0xac, 0x0c, 0x01,
    0x22, 0x23, 0x14, 0x15, 0x36, 0x37, 0x68, 0x89, 0x9a, 0xdb, 0x3c, 0x05,
    0x06, 0x12, 0x23, 0x14, 0xe5, 0xf6, 0x96, 0xf7, 0x01, 0x6c, 0x50, 0x08,
    0x32, 0x45, 0xc5, 0x49, 0xdb, 0x1e, 0x42, 0x77, 0x63, 0xf9, 0x51, 0xe7,
    0xe5, 0x3e, 0x9a, 0xf7, 0x56, 0xfd, 0x6f, 0xea, 0xbe, 0x27, 0xfc, 0xbd,
    0xf6, 0xa3, 0x3c, 0xe5, 0xf3, 0x5e, 0xf2, 0x7f, 0x33, 0xdc, 0x8f, 0x7c,
    0x9d, 0xe7, 0xf5, 0x94, 0xc5, 0x8e, 0xfa, 0xeb, 0x36, 0xea, 0x2f, 0x11,
    0x51, 0x7f, 0x67, 0x1f, 0xf5, 0x37, 0x71, 0x50, 0x7f, 0x71, 0x0b, 0xf5,
    0xd7, 0xd1, 0x51, 0x7f, 0x49, 0x15, 0xf5, 0x77, 0x92, 0x50, 0x7f, 0x53,
    0x21, 0xea, 0x2f, 0xc6, 0x43, 0xfd, 0x75, 0x39, 0xa8, 0xbf, 0x04, 0x13,
    0xf5, 0x77, 0xa6, 0xa3, 0xfe, 0x26, 0x14, 0xd4, 0x5f, 0x9c, 0x84, 0xfa,
    0xeb, 0xe0, 0x51, 0x7f, 0x49, 0x2c, 0xea, 0xef, 0x84, 0x42, 0xfd, 0x4d,
    0x11, 0xa8, 0xbf, 0x18, 0x2c, 0xea, 0xaf, 0x0b, 0x8d, 0xfa, 0x4b, 0x40,
    0xa0, 0xfe, 0xce, 0x60, 0xa8, 0xbf, 0x09, 0x30, 0xea, 0x2f, 0x0e, 0x88,
    0xfa, 0xab, 0x02, 0xa0, 0xfe, 0xaa, 0x00, 0xa8, 0xbf, 0x2a, 0x00, 0xea,
    0xaf, 0x0a, 0x80, 0xfa, 0xab, 0x02, 0xa0, 0xfe, 0xaa, 0x00, 0x20, 0x04,
    0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x02, 0x00, 0x08, 0x00, 0x66, 0x4a,
    0x3b, 0x51, 0x9f, 0xf7, 0x53, 0x5a, 0x76, 0x00, 0x00, 0x00, 0x80, 0x00,
    0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x38, 0x2e, 0x54, 0x58, 0x54, 0x7b,
    0xbf, 0x7b, 0x3f, 0x2f, 0x57, 0x40, 0x51, 0x7e, 0x56, 0x6a, 0x72, 0x89,
    0x82, 0x7b, 0x69, 0x49, 0x6a, 0x5e, 0x52, 0x6a, 0x51, 0xba, 0x82, 0xab,
    0x53, 0x7e, 0x7e, 0xb6, 0x42, 0x7e, 0x9a, 0x82, 0x47, 0x62, 0x6e, 0x4e,
    0x6a, 0x89, 0x8e, 0x42, 0x52, 0xa5, 0x42, 0x78, 0x66, 0x4e, 0x4e, 0x66,
    0x62, 0xae, 0x42, 0x70, 0x46, 0x62, 0x76, 0x6a, 0x71, 0x41, 0x6a, 0x62,
    0x51, 0x2a, 0x2f, 0x17, 0x2f, 0x57, 0x48, 0x46, 0x66, 0xb1, 0x42, 0x2a,
    0x58, 0x3d, 0x90, 0x91, 0x96, 0x5f, 0xa4, 0x50, 0x92, 0x91, 0xaa, 0x50,
    0x5a, 0x9c, 0x0a, 0xd2, 0x9e, 0x98, 0x57, 0x99, 0x9f, 0x97, 0x0a, 0xa2,
    0xca, 0x33, 0x52, 0x8b, 0x52, 0x15, 0x32, 0xf3, 0xc0, 0xb2, 0xa1, 0x79,
    0x99, 0x25, 0xa9, 0x29, 0x0a, 0xc1, 0x25, 0x89, 0x00, 0x50, 0x4b, 0x01,
    0x02, 0x0b, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x4a, 0x3b,
    0x51, 0x21, 0x65, 0x73, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x2e, 0x54, 0x58, 0x54,
    0x50, 0x4b, 0x01, 0x02, 0x0b, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x62, 0x4a, 0x3b, 0x51, 0x02, 0x04, 0x12, 0x39, 0x0c, 0x00, 0x00, 0x00,
    0x11, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x31, 0x2e,
    0x54, 0x58, 0x54, 0x50, 0x4b, 0x01, 0x02, 0x0a, 0x00, 0x0a, 0x00, 0x00,
    0x00, 0x02, 0x00, 0x63, 0x4a, 0x3b, 0x51, 0x6e, 0x4e, 0x6d, 0x9c, 0x0a,
    0x01, 0x00, 0x00, 0x34, 0x08, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00,
    0x00, 0x32, 0x2e, 0x54, 0x58, 0x54, 0x50, 0x4b, 0x01, 0x02, 0x0a, 0x00,
    0x0a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x63, 0x4a, 0x3b, 0x51, 0x6e, 0x4e,
    0x6d, 0x9c, 0x0f, 0x01, 0x00, 0x00, 0x34, 0x08, 0x00, 0x00, 0x05, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00,
    0x82, 0x01, 0x00, 0x00, 0x33, 0x2e, 0x54, 0x58, 0x54, 0x50, 0x4b, 0x01,
    0x02, 0x0a, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x04, 0x00, 0x63, 0x4a, 0x3b,
    0x51, 0x6e, 0x4e, 0x6d, 0x9c, 0x16, 0x01, 0x00, 0x00, 0x34, 0x08, 0x00,
    0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20,
    0x00, 0x00, 0x00, 0xb4, 0x02, 0x00, 0x00, 0x34, 0x2e, 0x54, 0x58, 0x54,
    0x50, 0x4b, 0x01, 0x02, 0x0a, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x05, 0x00,
    0x63, 0x4a, 0x3b, 0x51, 0x6e, 0x4e, 0x6d, 0x9c, 0x1a, 0x01, 0x00, 0x00,
    0x34, 0x08, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0xed, 0x03, 0x00, 0x00, 0x35, 0x2e,
    0x54, 0x58, 0x54, 0x50, 0x4b, 0x01, 0x02, 0x0b, 0x00, 0x0a, 0x00, 0x00,
    0x00, 0x06, 0x00, 0x65, 0x4a, 0x3b, 0x51, 0x58, 0x85, 0x96, 0x0d, 0x1d,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x2a, 0x05, 0x00,
    0x00, 0x36, 0x31, 0x2e, 0x54, 0x58, 0x54, 0x50, 0x4b, 0x01, 0x02, 0x0b,
    0x00, 0x0a, 0x00, 0x06, 0x00, 0x06, 0x00, 0x65, 0x4a, 0x3b, 0x51, 0xf1,
    0x0d, 0xc3, 0x06, 0x19, 0x01, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x06,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00,
    0x00, 0x6b, 0x05, 0x00, 0x00, 0x36, 0x32, 0x2e, 0x54, 0x58, 0x54, 0x50,
    0x4b, 0x01, 0x02, 0x19, 0x00, 0x14, 0x00, 0x02, 0x00, 0x08, 0x00, 0x66,
    0x4a, 0x3b, 0x51, 0x9f, 0xf7, 0x53, 0x5a, 0x76, 0x00, 0x00, 0x00, 0x80,
    0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x20, 0x00, 0x00, 0x00, 0xa8, 0x06, 0x00, 0x00, 0x38, 0x2e, 0x54,
    0x58, 0x54, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00,
    0x09, 0x00, 0xcd, 0x01, 0x00, 0x00, 0x41, 0x07, 0x00, 0x00, 0x00, 0x00,
};

test "zip_many_methods" {
    // Test reading a zip file with many different compression methods.
    var z: zip.zip_t = undefined;
    var it: zip.zipiter_t = undefined;
    var m: zip.zipmemb_t = undefined;
    var uncomp: [*]u8 = undefined;
    var i: usize = 0;

    var uncomp_mem = try allocator.alloc(u8, 100000);
    uncomp = uncomp_mem.ptr;

    try expect(zip.zip_read(&z, multizip[0..], multizip.len));
    try expect(z.num_members == 9);

    it = z.members_begin;
    m = zip.zip_member(&z, it);
    try expect(mem.eql(u8, m.name[0..5], "0.TXT"));
    try expect(m.method == zip.method_t.ZIP_STORE);
    try expect(try zip.zip_extract_member(&m, uncomp));
    try expect(mem.eql(u8, uncomp[0..3], "foo"));

    it = m.next;
    m = zip.zip_member(&z, it);
    try expect(mem.eql(u8, m.name[0..5], "1.TXT"));
    try expect(m.method == zip.method_t.ZIP_SHRINK);
    try expect(try zip.zip_extract_member(&m, uncomp));
    try expect(mem.eql(u8, uncomp[0..17], "ababcbababaaaaaaa"));

    it = m.next;
    m = zip.zip_member(&z, it);
    try expect(mem.eql(u8, m.name[0..5], "2.TXT"));
    try expect(m.method == zip.method_t.ZIP_REDUCE1);
    try expect(try zip.zip_extract_member(&m, uncomp));
    i = 0;
    while (i < 42 * 50) : (i += 1) {
        try expect(uncomp[i] == hamlet[i % 50]);
    }

    it = m.next;
    m = zip.zip_member(&z, it);
    try expect(mem.eql(u8, m.name[0..5], "3.TXT"));
    try expect(m.method == zip.method_t.ZIP_REDUCE2);
    try expect(try zip.zip_extract_member(&m, uncomp));
    i = 0;
    while (i < 42 * 50) : (i += 1) {
        try expect(uncomp[i] == hamlet[i % 50]);
    }

    it = m.next;
    m = zip.zip_member(&z, it);
    try expect(mem.eql(u8, m.name[0..5], "4.TXT"));
    try expect(m.method == zip.method_t.ZIP_REDUCE3);
    try expect(try zip.zip_extract_member(&m, uncomp));
    i = 0;
    while (i < 42 * 50) : (i += 1) {
        try expect(uncomp[i] == hamlet[i % 50]);
    }

    it = m.next;
    m = zip.zip_member(&z, it);
    try expect(mem.eql(u8, m.name[0..5], "5.TXT"));
    try expect(m.method == zip.method_t.ZIP_REDUCE4);
    try expect(try zip.zip_extract_member(&m, uncomp));
    i = 0;
    while (i < 42 * 50) : (i += 1) {
        try expect(uncomp[i] == hamlet[i % 50]);
    }

    it = m.next;
    m = zip.zip_member(&z, it);
    try expect(mem.eql(u8, m.name[0..6], "61.TXT"));
    try expect(m.method == zip.method_t.ZIP_IMPLODE);
    try expect(m.imp_large_wnd == false);
    try expect(m.imp_lit_tree == false);
    try expect(try zip.zip_extract_member(&m, uncomp));
    i = 0;
    while (i < 128) : (i += 1) {
        try expect(uncomp[i] == 0);
    }

    it = m.next;
    m = zip.zip_member(&z, it);
    try expect(mem.eql(u8, m.name[0..6], "62.TXT"));
    try expect(m.method == zip.method_t.ZIP_IMPLODE);
    try expect(m.imp_large_wnd == true);
    try expect(m.imp_lit_tree == true);
    try expect(try zip.zip_extract_member(&m, uncomp));
    i = 0;
    while (i < 200 * 50) : (i += 1) {
        try expect(uncomp[i] == hamlet[i % 50]);
    }

    it = m.next;
    m = zip.zip_member(&z, it);
    try expect(mem.eql(u8, m.name[0..5], "8.TXT"));
    try expect(m.method == zip.method_t.ZIP_DEFLATE);
    try expect(try zip.zip_extract_member(&m, uncomp));
    i = 0;
    while (i < 128) : (i += 1) {
        try expect(uncomp[i] == hamlet[i]);
    }

    it = m.next;
    try expect(it == z.members_end);
    allocator.free(uncomp_mem);
}

// Created by a hacked up version of hwzip.
// It uses all combinations of the large_wnd and lit_tree flags,
// in 1.01/1.02 and 1.10 compatible modes.
//
// In particular, pkzip 1.01/1.02 will not be able to decompress b & c,
// and pkzip 1.1, info-zip etc. won't be able to decompress f & g.
//
// hwzip is aware of the problem and can to handle it.
//
// -rw-a--     1.1 fat       19 b- i4:2 20-Sep-29 22:06 a
// -rw-a--     1.1 fat       19 b- i4:3 20-Sep-29 22:06 b
// -rw-a--     1.1 fat       19 b- i8:2 20-Sep-29 22:06 c
// -rw-a--     1.1 fat       19 b- i8:3 20-Sep-29 22:06 d
// -rw-a--     1.0 fat       19 b- i4:2 20-Sep-29 22:06 e
// -rw-a--     1.0 fat       19 b- i4:3 20-Sep-29 22:06 f
// -rw-a--     1.0 fat       19 b- i8:2 20-Sep-29 22:06 g
// -rw-a--     1.0 fat       19 b- i8:3 20-Sep-29 22:06 h
//
const legacy_implode_zip = [_]u8{
    0x50, 0x4b, 0x03, 0x04, 0x0b, 0x00, 0x00, 0x00, 0x06, 0x00, 0xdb, 0xb0,
    0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x21, 0x00, 0x00, 0x00, 0x13, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x61, 0x07, 0x16, 0x02, 0x16, 0xf5,
    0xf5, 0xf5, 0x96, 0x05, 0x06, 0x02, 0x36, 0xf5, 0xf5, 0xf5, 0x96, 0x05,
    0xc3, 0x86, 0x0d, 0x1b, 0x36, 0xa6, 0x58, 0xb1, 0x62, 0xc5, 0xca, 0x48,
    0xfe, 0x33, 0x92, 0x1f, 0x50, 0x4b, 0x03, 0x04, 0x0b, 0x00, 0x04, 0x00,
    0x06, 0x00, 0xdb, 0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x34, 0x00,
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62, 0x16,
    0x38, 0xf7, 0xf7, 0x77, 0x48, 0x25, 0xf8, 0xf8, 0xc8, 0x13, 0xd8, 0xf7,
    0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0x78, 0x37, 0x18, 0x07, 0x07,
    0x06, 0x02, 0x26, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0x06, 0x02, 0x36, 0xf5,
    0xf5, 0xf5, 0x96, 0x05, 0xff, 0xff, 0x7f, 0x7f, 0xef, 0xbd, 0x9b, 0xe4,
    0xbf, 0x4a, 0x7e, 0x50, 0x4b, 0x03, 0x04, 0x0b, 0x00, 0x02, 0x00, 0x06,
    0x00, 0xdb, 0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x21, 0x00, 0x00,
    0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x63, 0x07, 0x16,
    0x02, 0x16, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0x06, 0x02, 0x36, 0xf5, 0xf5,
    0xf5, 0x96, 0x05, 0xc3, 0x86, 0x0d, 0x1b, 0x36, 0xa6, 0x58, 0xb1, 0x62,
    0xc5, 0xca, 0x48, 0xfc, 0x67, 0x24, 0x7e, 0x50, 0x4b, 0x03, 0x04, 0x0b,
    0x00, 0x06, 0x00, 0x06, 0x00, 0xdb, 0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8,
    0xaa, 0x35, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x64, 0x16, 0x38, 0xf7, 0xf7, 0x77, 0x48, 0x25, 0xf8, 0xf8, 0xc8,
    0x13, 0xd8, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0x78, 0x37,
    0x18, 0x07, 0x07, 0x06, 0x02, 0x26, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0x06,
    0x02, 0x36, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0xff, 0xff, 0x7f, 0x7f, 0xef,
    0xbd, 0x9b, 0xc4, 0x7f, 0x95, 0xf8, 0x01, 0x50, 0x4b, 0x03, 0x04, 0x0a,
    0x00, 0x00, 0x00, 0x06, 0x00, 0xdb, 0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8,
    0xaa, 0x21, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x65, 0x07, 0x16, 0x02, 0x16, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0x06,
    0x02, 0x36, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0xc3, 0x86, 0x0d, 0x1b, 0x36,
    0xa6, 0x58, 0xb1, 0x62, 0xc5, 0xca, 0x48, 0xfe, 0x33, 0x92, 0x1f, 0x50,
    0x4b, 0x03, 0x04, 0x0a, 0x00, 0x04, 0x00, 0x06, 0x00, 0xdb, 0xb0, 0x3d,
    0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x34, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x66, 0x16, 0x38, 0xf7, 0xf7, 0x77, 0x48,
    0x25, 0xf8, 0xf8, 0xc8, 0x13, 0xd8, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7,
    0xf7, 0xf7, 0x78, 0x37, 0x18, 0x07, 0x07, 0x16, 0x02, 0x16, 0xf5, 0xf5,
    0xf5, 0x96, 0x05, 0x06, 0x02, 0x36, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0xff,
    0xff, 0x7f, 0x7f, 0xef, 0xbd, 0x9b, 0xe4, 0xbf, 0x4a, 0x7e, 0x50, 0x4b,
    0x03, 0x04, 0x0a, 0x00, 0x02, 0x00, 0x06, 0x00, 0xdb, 0xb0, 0x3d, 0x51,
    0x8f, 0xb9, 0xb8, 0xaa, 0x21, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x67, 0x07, 0x06, 0x02, 0x26, 0xf5, 0xf5, 0xf5,
    0x96, 0x05, 0x06, 0x02, 0x36, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0xc3, 0x86,
    0x0d, 0x1b, 0x36, 0xa6, 0x58, 0xb1, 0x62, 0xc5, 0xca, 0x48, 0xfc, 0x67,
    0x24, 0x7e, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x06, 0x00, 0x06, 0x00,
    0xdb, 0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x35, 0x00, 0x00, 0x00,
    0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x68, 0x16, 0x38, 0xf7,
    0xf7, 0x77, 0x48, 0x25, 0xf8, 0xf8, 0xc8, 0x13, 0xd8, 0xf7, 0xf7, 0xf7,
    0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0x78, 0x37, 0x18, 0x07, 0x07, 0x06, 0x02,
    0x26, 0xf5, 0xf5, 0xf5, 0x96, 0x05, 0x06, 0x02, 0x36, 0xf5, 0xf5, 0xf5,
    0x96, 0x05, 0xff, 0xff, 0x7f, 0x7f, 0xef, 0xbd, 0x9b, 0xc4, 0x7f, 0x95,
    0xf8, 0x01, 0x50, 0x4b, 0x01, 0x02, 0x0b, 0x00, 0x0b, 0x00, 0x00, 0x00,
    0x06, 0x00, 0xdb, 0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x21, 0x00,
    0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x61, 0x50, 0x4b, 0x01, 0x02, 0x0b, 0x00, 0x0b, 0x00, 0x04, 0x00, 0x06,
    0x00, 0xdb, 0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x34, 0x00, 0x00,
    0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x62,
    0x50, 0x4b, 0x01, 0x02, 0x0b, 0x00, 0x0b, 0x00, 0x02, 0x00, 0x06, 0x00,
    0xdb, 0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x21, 0x00, 0x00, 0x00,
    0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0x63, 0x50,
    0x4b, 0x01, 0x02, 0x0b, 0x00, 0x0b, 0x00, 0x06, 0x00, 0x06, 0x00, 0xdb,
    0xb0, 0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x35, 0x00, 0x00, 0x00, 0x13,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x00, 0x00, 0x00, 0xd3, 0x00, 0x00, 0x00, 0x64, 0x50, 0x4b,
    0x01, 0x02, 0x0a, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x06, 0x00, 0xdb, 0xb0,
    0x3d, 0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x21, 0x00, 0x00, 0x00, 0x13, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x27, 0x01, 0x00, 0x00, 0x65, 0x50, 0x4b, 0x01,
    0x02, 0x0a, 0x00, 0x0a, 0x00, 0x04, 0x00, 0x06, 0x00, 0xdb, 0xb0, 0x3d,
    0x51, 0x8f, 0xb9, 0xb8, 0xaa, 0x34, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
    0x00, 0x00, 0x00, 0x67, 0x01, 0x00, 0x00, 0x66, 0x50, 0x4b, 0x01, 0x02,
    0x0a, 0x00, 0x0a, 0x00, 0x02, 0x00, 0x06, 0x00, 0xdb, 0xb0, 0x3d, 0x51,
    0x8f, 0xb9, 0xb8, 0xaa, 0x21, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
    0x00, 0x00, 0xba, 0x01, 0x00, 0x00, 0x67, 0x50, 0x4b, 0x01, 0x02, 0x0a,
    0x00, 0x0a, 0x00, 0x06, 0x00, 0x06, 0x00, 0xdb, 0xb0, 0x3d, 0x51, 0x8f,
    0xb9, 0xb8, 0xaa, 0x35, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
    0x00, 0xfa, 0x01, 0x00, 0x00, 0x68, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00,
    0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x78, 0x01, 0x00, 0x00, 0x4e, 0x02,
    0x00, 0x00, 0x00, 0x00,
};

test "zip_legacy_implode" {
    var z: zip.zip_t = undefined;
    var it: zip.zipiter_t = undefined;
    var m: zip.zipmemb_t = undefined;
    var uncomp: [*]u8 = undefined;
    var i: usize = 0;

    var uncomp_mem = try allocator.alloc(u8, 100);
    uncomp = uncomp_mem.ptr;

    try expect(zip.zip_read(&z, legacy_implode_zip[0..], legacy_implode_zip.len));
    try expect(z.num_members == 8);

    it = z.members_begin;

    i = 0;
    while (i < 8) : (i += 1) {
        m = zip.zip_member(&z, it);
        try expect(m.name[0] == "abcdefgh"[i]);
        try expect(m.method == zip.method_t.ZIP_IMPLODE);
        try expect(try zip.zip_extract_member(&m, uncomp));
        try expect(mem.eql(u8, uncomp[0..19], "aaaa1bbbb2aaaa3bbbb"));
        it = m.next;
    }

    try expect(it == z.members_end);

    allocator.free(uncomp_mem);
}

const methods = [_]zip.method_t{
    zip.method_t.ZIP_STORE,
    zip.method_t.ZIP_SHRINK,
    zip.method_t.ZIP_REDUCE1,
    zip.method_t.ZIP_REDUCE2,
    zip.method_t.ZIP_REDUCE3,
    zip.method_t.ZIP_REDUCE4,
    zip.method_t.ZIP_IMPLODE,
    zip.method_t.ZIP_DEFLATE,
};

test "zip_write_methods" {
    const names = ([_][*:0]const u8{"hamlet"})[0..];
    const data = [_][*]const u8{hamlet};
    const sizes = ([_]u32{hamlet.len})[0..];
    var mtimes: [1]time.time_t = undefined;
    var max_size: usize = 0;
    var size: usize = 0;
    var out: [*]u8 = undefined;
    var z: zip.zip_t = undefined;
    var m: zip.zipmemb_t = undefined;

    mtimes[0] = magic_time();
    max_size = zip.zip_max_size(1, names, sizes, null);
    var out_mem = try allocator.alloc(u8, max_size);
    out = out_mem.ptr;

    for (methods) |_, mi| {
        size = try zip.zip_write(out, 1, names, &data, sizes, &mtimes, null, methods[mi], null);

        try expect(zip.zip_read(&z, out, size));
        m = zip.zip_member(&z, z.members_begin);
        try expect(m.method == methods[mi]);
        try expect(m.crc32 == 0xb239_ac7c);

        try check_extract2(&m, hamlet, hamlet.len);

        if (methods[mi] == zip.method_t.ZIP_DEFLATE) {
            try expect(m.made_by_ver == 20);
        } else {
            try expect(m.made_by_ver == 10);
        }
    }

    allocator.free(out_mem);
}

test "zip_write_empty_member" {
    const names = ([_][*:0]const u8{"foo"})[0..];
    const data = [_][*]const u8{""};
    const sizes = ([_]u32{0})[0..];
    var mtimes: [1]time.time_t = undefined;
    var max_size: usize = 0;
    var size: usize = 0;
    var out: [*]u8 = undefined;
    var z: zip.zip_t = undefined;
    var m: zip.zipmemb_t = undefined;

    mtimes[0] = magic_time();
    max_size = zip.zip_max_size(1, names, sizes, null);
    var out_mem = try allocator.alloc(u8, max_size);
    out = out_mem.ptr;

    for (methods) |_, mi| {
        size = try zip.zip_write(out, 1, names, &data, sizes, &mtimes, null, methods[mi], null);

        try expect(zip.zip_read(&z, out, size));
        m = zip.zip_member(&z, z.members_begin);
        try expect(m.method == zip.method_t.ZIP_STORE);
        try expect(m.comp_size == 0);
        try expect(m.uncomp_size == 0);
        try expect(m.crc32 == 0x0000_0000);

        try check_extract2(&m, "", 0);
    }

    allocator.free(out_mem);
}
