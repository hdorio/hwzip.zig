<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0031)https://www.hanshq.net/zip.html -->
<html lang="en"><script type="text/javascript">window["_gaUserPrefs"] = { ioo : function() { return true; } }</script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        
        <title>Zip Files: History, Explanation and Implementation</title>
        <link rel="stylesheet" type="text/css" href="./zip_files/style.css">
        <link rel="stylesheet" type="text/css" href="./zip_files/code-style.css">
        <link rel="alternate" type="application/rss+xml" href="https://www.hanshq.net/feed.rss">
        <meta name="viewport" content="width=device-width, initial-scale=1">

<style type="text/css">
.lzsrc { background: rgba(255,230,0,0.3);   color-adjust: exact; -webkit-print-color-adjust: exact; }
.lzdst { background: rgba(125,125,250,0.3); color-adjust: exact; -webkit-print-color-adjust: exact; }
</style>
</head>
<body>
<div id="main">
        <a href="https://www.hanshq.net/"><img src="./zip_files/header_img_3903.jpg" id="header" alt="hanshq.net" style="max-width: 900px; max-height: 400px"></a>
        <div id="container">
                <div id="center">
                        <h1>Zip Files: <br>History, Explanation and Implementation<br><span class="date">(26&nbsp;February&nbsp;2020)</span></h1>
                        <div id="left">
<p>I have been curious about data compression and the Zip file format in particular for a long time. At some point I decided to address that by learning how it works and writing my own Zip program. The implementation turned into an exciting programming exercise; there is great pleasure to be had from creating a well oiled machine that takes data apart, jumbles its bits into a more efficient representation, and puts it all back together again. Hopefully it is interesting to read about too.</p>

<p>This article explains how the Zip file format and its compression scheme work in great detail: LZ77 compression, Huffman coding, Deflate and all. It tells some of the history, and provides a reasonably efficient example implementation written from scratch in C. The source code is available in <a href="https://www.hanshq.net/files/hwzip/hwzip-2.0.zip">hwzip-2.0.zip</a>.</p>




<p>I have done my best to provide a bug-free implementation. If you find any issues, please let me know.</p>

<p>I am very grateful to
<a href="https://twitter.com/angealbertini">Ange Albertini</a>,
<a href="https://gynvael.coldwind.pl/">Gynvael Coldwind</a>,
<a href="https://fgiesen.wordpress.com/">Fabian Giesen</a>,
<a href="https://www.instagram.com/dr.jonas.skeppstedt">Jonas Skeppstedt</a> (<a href="https://www.jonasskeppstedt.net/">web</a>),
<a href="https://primianotucci.com/">Primiano Tucci</a>, and
<a href="https://twitter.com/thakis">Nico Weber</a>
who provided valuable feedback on draft versions of this material.</p>

<p><b>Update 2021-03-12:</b> I wrote a <a href="https://www.hanshq.net/zip2.html">follow-up article</a> about the legacy Zip compression methods: Shrink, Reduce, and Implode. The code is in <a href="https://www.hanshq.net/files/hwzip/hwzip-2.0.zip">hwzip-2.0.zip</a>.</p>

<p><b>Update 2020-10-11:</b> In <a href="https://www.hanshq.net/files/hwzip/hwzip-1.4.zip">hwzip-1.4.zip</a>, the <span class="code">distance2dist</span> table was split into two smaller tables, reducing the binary size by 32 KB. It also ensures that Deflate blocks always emit at least two non-zero dist codeword lengths, for compatibility with old zlib versions.</p>

<p><b>Update 2020-06-14:</b> In <a href="https://www.hanshq.net/files/hwzip/hwzip-1.3.zip">hwzip-1.3.zip</a>, the minimum Lempel–Ziv back reference length was increased from three to four bytes, and the hash was changed from a three-byte rolling hash to a four-byte multiplicative hash. This made Deflate compression more than twice as fast as the previous version.</p>

<a name="toc"></a>
<h2>Table of Contents</h2>

<ul>
<li><a href="https://www.hanshq.net/zip.html#history">History</a><ul>
        <li><a href="https://www.hanshq.net/zip.html#pkzip">PKZip</a></li>
        <li><a href="https://www.hanshq.net/zip.html#zlib">Info-ZIP and zlib</a></li>
        <li><a href="https://www.hanshq.net/zip.html#winzip">WinZip</a></li>
</ul></li>

<li><a href="https://www.hanshq.net/zip.html#lz">Lempel–Ziv Compression (LZ77)</a></li>

<li><a href="https://www.hanshq.net/zip.html#huffman">Huffman Coding</a><ul>
        <li><a href="https://www.hanshq.net/zip.html#huffalg">Huffman's Algorithm</a></li>
        <li><a href="https://www.hanshq.net/zip.html#canhuff">Canonical Huffman Codes</a></li>
        <li><a href="https://www.hanshq.net/zip.html#huffdec">Efficient Huffman Decoding</a></li>
</ul></li>

<li><a href="https://www.hanshq.net/zip.html#deflate">Deflate</a><ul>
        <li><a href="https://www.hanshq.net/zip.html#bitstreams">Bitstreams</a></li>

        <li><a href="https://www.hanshq.net/zip.html#inflation">Decompression (Inflation)</a><ul>
                <li><a href="https://www.hanshq.net/zip.html#noncomp">Non-Compressed Deflate Blocks</a></li>
                <li><a href="https://www.hanshq.net/zip.html#fixed">Fixed Huffman Code Deflate Blocks</a></li>
                <li><a href="https://www.hanshq.net/zip.html#dyn">Dynamic Huffman Code Deflate Blocks</a></li>
        </ul></li>

        <li><a href="https://www.hanshq.net/zip.html#deflation">Compression (Deflation)</a></li>
</ul></li>

<li><a href="https://www.hanshq.net/zip.html#zip">The Zip File Format</a><ul>
        <li><a href="https://www.hanshq.net/zip.html#zipintro">Overview</a></li>

        <li><a href="https://www.hanshq.net/zip.html#zipstructs">Data Structures</a><ul>
                <li><a href="https://www.hanshq.net/zip.html#eocdr">End of Central Directory Record</a></li>
                <li><a href="https://www.hanshq.net/zip.html#cfh">Central File Header</a></li>
                <li><a href="https://www.hanshq.net/zip.html#lfh">Local File Header</a></li>
        </ul></li>

        <li><a href="https://www.hanshq.net/zip.html#zipreader">Zip Reader Implementation</a></li>
        <li><a href="https://www.hanshq.net/zip.html#zipwriter">Zip Writer Implementation</a></li>
</ul></li>

<li><a href="https://www.hanshq.net/zip.html#hwzip">HWZip</a><ul>
        <li><a href="https://www.hanshq.net/zip.html#build">Build Instructions</a></li>
</ul></li>
<li><a href="https://www.hanshq.net/zip.html#conclusion">Conclusion</a></li>
<li><a href="https://www.hanshq.net/zip.html#exercises">Exercises</a></li>
<li><a href="https://www.hanshq.net/zip.html#reading">Further Reading</a></li>
<li><a href="https://www.hanshq.net/zip.html#files">Linked Files</a></li>

</ul>

<a name="history"></a>
<h2>History</h2>

<a name="pkzip"></a>
<h3>PKZip</h3>

<p>Back in the eighties and early nineties, before the Internet became widely available, home computer enthusiasts used dial-up modems to connect to Bulletin Board Systems (BBSes) over the telephone network.
A BBS is an interactive computer system that typically allows users to send messages, play games, and share files.
All that was needed to go online was a computer, a modem, and the phone number of a good BBS—something that could be found in <a href="https://archive.org/details/Boardwatch_Magazine_Vol_06_10_1992_Dec/page/n81">lists published by computer magazines</a>, and on other BBSes.</p>

<p>One important tool for making file sharing easier was the <em>archiver</em>. An archiver stores one or more files into a single file, an <em>archive</em>, allowing the files to be stored or transferred as a single unit, and ideally also compresses them to save storage space and transfer time. One such archiver that was popular with the BBS scene was <a href="https://en.wikipedia.org/wiki/ARC_(file_format)">Arc</a>, written by Thom Henderson of System Enhancement Associates (SEA), a small company he had founded with his brother-in-law.</p>

<p>In the late eighties, a programmer named Phil Katz released his own Arc program, PKArc. It was compatible with SEA's Arc, but faster due to routines written in assembly, and it had a new compression method added by Katz. The program became popular, and Katz quit his job and founded PKWare to focus on developing it. According to legend, much of the work took place at his mother Hildegard's kitchen table in Glendale, Wisconsin.</p>

<div style="text-align: center">
<img src="./zip_files/philkatz.jpg" alt="Phil Katz at his desk with a stack of floppy disks." style="max-width: 90%">

<p>Photo of Phil Katz from <a href="https://www.hanshq.net/files/katz_article.png">an article in the Milwaukee Sentinel</a> on 19 September 1994.</p>
<!--The actual image file is from http://ftp.pwr.wroc.pl/pub/pc/pack/philkatz.jpg (can also be found on other FTPs).
  The article is from Google News: https://news.google.com/newspapers?id=EJpQAAAAIBAJ&sjid=FBMEAAAAIBAJ&pg=2635%2C6024920
  -->
</div>

<p>SEA, however, were not thrilled by Katz's initiative. They sued for trademark violation and copyright infringement. The dispute and the surrounding debate in the BBS and PC world became known as the <a href="http://catb.org/jargon/chaff.html#arc-wars">Arc Wars</a>. In the end, the case was <a href="http://www.bbsdocumentary.com/library/CONTROVERSY/LAWSUITS/SEA/release.txt">settled</a> to SEA's advantage.</p>

<p>Moving on from Arc, in 1989 Katz created a new archive format which he named Zip and <a href="https://groups.google.com/d/msg/comp.sys.ibm.pc/0tun_9sqKYU/RNeLTza9fAEJ">dedicated to the public domain</a>:</p>

<blockquote>
<p>The file format of the files created by these programs, which file format is original with the first release of this software, is hereby dedicated to the public domain.  Further, the filename extension of ".ZIP", first used in connection with data compression software on the first release of this software, is also hereby dedicated to the public domain, with the fervent and sincere hope that it will not be attempted to be appropriated by anyone else for their exclusive use, but rather that it will be used to refer to data compression and librarying software in general, of a class or type which creates files having a format generally compatible with this software.</p>
</blockquote>

<p>Katz's program for creating such files was called PKZip, and it was soon adopted by the BBS and PC world.</p>

<p>One aspect that most likely contributed to the Zip format's success was that PKZip came with a document, the <a href="https://www.pkware.com/documents/APPNOTE/APPNOTE-2.0.txt">Application Note</a>, which explained exactly how the format works. This allowed others to study the format and create programs that create, extract, or otherwise interact with Zip files in a compatible way.</p>

<p>Zip is a <em>lossless</em> compression format: after decompression, the data is identical to what it was before compression. It works by finding redundancies in the source data and representing it more efficiently. This is different from <em>lossy</em> compression, used in image and sound formats such as JPEG and MP3, which work by removing features from the data which are less perceivable to the human eye or ear, etc.</p>

<p>PKZip was distributed as Shareware: it could be used and copied freely, but users were encouraged to "register" the program. For $47, one would receive a printed manual, premium support, and an enhanced version of the software.</p>

<div style="text-align: center">
<img src="./zip_files/pkzip_manual.jpg" alt="PKZip manual and floppy" style="max-width: 90%">
</div>

<p>The seminal version of PKZip was 2.04c, released on 28 December 1992 (followed by <a href="https://www.hanshq.net/files/pkz204g.exe">version 2.04g</a> soon after). This introduced Deflate as the default compression method, and defined how Zip file compression would work going forward. (<a href="https://archive.org/details/Boardwatch1993-03/page/n21">Boardwatch article about the release.</a>)</p>

<div style="text-align: center">
<img src="./zip_files/pkzip.png" alt="Screenshot of PKZip 2.04g" style="max-width: 90%">
</div>

<p>The Zip format has since been adopted by many other file formats. For example, Java Archives (.jar files) and Android Application Packages (.apk files), as well as Microsoft Office .docx files, are all using the Zip format. Other file formats and protocols re-use the compression algorithm used in Zip files, Deflate. For example, this web page was most likely transferred to your web browser as a gzip file, a format which uses Deflate compression.</p>

<p>Phil Katz passed away in 2000. PKWare still exist and maintain the Zip format, though they focus mainly on data security software.</p>
<!--Pictures from their DevFest 2019: https://pkware.com/devfest2019 -->


<a name="zlib"></a>
<h3>Info-ZIP and zlib</h3>

<p>Soon after the release of PKZip in 1989, other programs to extract Zip files started showing up, in particular a program called <em>unzip</em> that could be used to extract Zip files on Unix systems. A mailing list called Info-ZIP was set up in March 1990.</p>

<p>The <a href="http://www.info-zip.org/">Info-ZIP</a> group released the free and open-source <em>unzip</em> and <em>zip</em> programs, used to extract and create zip files. The code was ported to many systems and they are still the standard Zip programs used on Unix systems. This further helped increase the popularity of Zip files.</p>

<p>At some point, the Info-ZIP code that performed the Deflate compression and decompression was extracted into a separate software library called <a href="https://www.zlib.net/">zlib</a>, written by <a href="http://gailly.net/">Jean-loup Gailly</a> (compression) and <a href="https://madler.net/madler/">Mark Adler</a> (decompression).</p>

<div style="text-align: center">
<img src="./zip_files/gailly_adler.jpg" alt="Photo of Jean-loup Gailly and Mark Adler receiving the USENIX STUG award in 2009." style="max-width: 90%">

<p>Jean-loup Gailly (left) and Mark Adler (right) receiving the <a href="https://www.usenix.org/about/stug">USENIX STUG Award</a> in 2009.</p>
</div>

<p>One reason for creating the library was that this made it convenient to use Deflate compression in other applications and file formats, such as the new <a href="https://en.wikipedia.org/wiki/Gzip">gzip</a> file compression format, and the <a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics">PNG</a> image compression format. These new file formats had been proposed in order to replace the <a href="https://en.wikipedia.org/wiki/Compress">Compress</a> and <a href="https://en.wikipedia.org/wiki/GIF">GIF</a> file formats, which used the patent-encumbered LZW algorithm.</p>

<p>As part of developing those formats, a specification of Deflate was written by <a href="https://en.wikipedia.org/wiki/L._Peter_Deutsch">L Peter Deutsch</a> and published as <a href="https://tools.ietf.org/html/rfc1951">Internet RFC 1951</a> in May 1996. This provides an easier to follow description than the original PKZip Application Note.</p>

<p>Today, the use of zlib is truly ubiquitous. It was probably responsible for both the compression of this page on the web server, and decompression in your web browser. Compression and decompression of most Zip and Zip-like files is now done with zlib.</p>

<a name="winzip"></a>
<h3>WinZip</h3>

<p>Many people who did not use PKZip do remember using WinZip. As PC users moved from DOS to Windows, they also moved from PKZip to WinZip.</p>

<p>It started as a project by programmer Nico Mak, who was working on software for the OS/2 operating system at a company called Mansfield Software Group in Storrs-Mansfield, Connecticut. He was using Presentation Manager, the graphical user interface in OS/2, and was frustrated by how he had to switch from its File Manager to a DOS command prompt whenever he wanted to create or extract Zip files.</p>
<!--Some history: https://archive.org/details/winzipforbeginne0000howa/page/n5 -->
<!--Mansfield Software Group: http://www.edm2.com/index.php/Mansfield_Software_Group -->

<p>Mak wrote a simple graphical program to manage Zip files directly in Presentation Manager, named it <a href="http://cd.textfiles.com/sigserieswin/0WINRUN/2785/PMZIP.TXT">PMZip</a>, and released it as shareware in 1990.</p>

<p>OS/2 never really took off; instead the PC world was moving to Microsoft Windows. In 1991, Mak decided to learn how to write Windows programs, and his first project was to port his Zip program to this new operating system. <a href="https://www.hanshq.net/files/winzip1.zip">WinZip 1.00</a> was released in April 1991 as shareware with a 21-day evaluation period and $29 registration price. It looked like this:</p>

<div style="text-align: center">
<img src="./zip_files/winzip1.png" alt="Screenwhot of Winzip 1.00" style="max-width: 90%">
</div>

<p>The first versions of WinZip used PKZip behind the scenes, but starting with version 5.0 in 1993 it uses the code from Info-ZIP to manage Zip files directly. From its humble beginnings, the user interface evolved to different versions of the one below.</p>

<div style="text-align: center">
<img src="./zip_files/winzip.png" alt="Winzip 6.3 running under Windows 3.11 For Workgroups" style="max-width: 90%">

<p>Screenshot of <a href="https://ftp.sunet.se/mirror/archive/ftp.sunet.se/pub/simtelnet/win3/compress/wz16v_63.exe">WinZip 6.3</a> running under Windows 3.11 for Workgroups.</p>
</div>

<p>WinZip was one of the most popular shareware programs during the nineties, but it eventually became less relevant as operating systems gained built-in support for Zip files. Windows manages Zip files as "compressed folders" since Windows ME (or Windows 98 with <a href="https://en.wikipedia.org/wiki/Microsoft_Plus!#Microsoft_Plus!_98">Plus! 98</a>) using a library called <a href="http://www.innermedia.com/">DynaZip</a> under the hood. The Windows integration was written by Dave Plummer and initially distributed as shareware before Microsoft acquired it (see <a href="https://www.youtube.com/watch?v=aQUtUQ_L8Yk">Dave's video</a> for the story).</p>
<!--It's in zipfldr.dll-->

<p>Mak's company was originally called Nico Mak Computing. In 2000 it was renamed to WinZip Computing, and Mak seems to have left around this time. In 2005 the company was <a href="https://www.businesswire.com/news/home/20050718005297/en/Vector-Capital-Buys-WinZip-Private-Equity-Firm">sold to Vector Capital</a>, and it eventually ended up owned by <a href="https://www.corel.com/">Corel</a> who still release WinZip as a product.</p>


<a name="lz"></a>
<h2>Lempel–Ziv Compression (LZ77)</h2>

<p>There are two main ingredients in Zip compression: Lempel–Ziv compression and Huffman coding. This section describes the former.</p>

<p>One way of compressing text is to maintain a list of common words or phrases, and replace occurrences of those words in the text with references to the dictionary. For example, a long word such as "compression" in the original text might be represented more efficiently as #1234, where 1234 refers to the position in the word list. This is known as <em>dictionary-based compression</em>.</p>

<p>The dictionary method poses several problems for a general-purpose compression scheme. First, what should go in the dictionary? The original data might not be in English, and it might not even be human-readable text. And if the dictionary is not agreed upon between the compressing and decompressing parties beforehand, it needs to be stored and transmitted together with the compressed data, reducing the benefit of the compression.</p>

<p>One elegant solution to these problems is to use the original data itself as the dictionary. In their 1977 paper "<a href="https://www2.cs.duke.edu/courses/spring03/cps296.5/papers/ziv_lempel_1977_universal_algorithm.pdf">A Universal Algorithm for Sequential Data Compression</a>", Jacob Ziv and Abraham Lempel (both at Technion), propose a compression scheme where the original data is parsed into a sequence of triplets</p>

<div style="text-align: center">
<p>(<em>pointer</em>, <em>length</em>, <em>next</em>)</p>
</div>

<p>where <em>pointer</em> and <em>length</em> form a back reference to a substring to be copied from a previous position in the original text, and <em>next</em> is the next character to output.</p>

<div style="text-align: center">
<img src="./zip_files/lempel.jpg" alt="Photo of Ziv Lempel" style="max-width: 90%">
<img src="./zip_files/ziv.jpg" alt="Photo of Jacob Ziv" style="max-width: 90%">

<p>Abraham Lempel (photo <a href="https://en.wikipedia.org/wiki/Abraham_Lempel#/media/File:Abraham_Lempel.JPG">from Wikipedia</a>, by Staelin, <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>) and <a href="https://spectrum.ieee.org/geek-life/profiles/from-winzips-to-cat-gifs-jacob-zivs-algorithms-have-powered-decades-of-compression">Jacob Ziv</a> (photo <a href="https://en.wikipedia.org/wiki/Yaakov_Ziv#/media/File:Jacob_Ziv.jpeg">from Wikipedia</a>).</p>
</div>

<p>For example, consider the snippet below.</p>

<blockquote>
<p>
I<span class="lzsrc">t was the </span>best of times,<br>
i<span class="lzdst">t was the </span>worst of times,<br>
</p>
</blockquote>

<p>In the second line, the "t was the w" substring can be represented as (26, 10, w), because it can be recreated by copying 10 characters from the position 26 steps back, followed by a "w". Characters which have not occurred before use zero-length back references. For example, the initial "I" would be represented as (0, 0, I).</p>

<p>This form of compression is called Lempel–Ziv or LZ77 compression. However, real-world implementations typically do not use the <em>next</em> part of the triplets. Instead, they output single characters separately and use (<em>distance</em>, <em>length</em>) pairs for the back references. (This variant is called <a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Storer%E2%80%93Szymanski">LZSS</a> compression.) How the literals and back reference are <em>encoded</em> is a separate problem, and we will see how it is done in <a href="https://www.hanshq.net/zip.html#deflate">Deflate</a> later.</p>

<p>As an example, the following text</p>

<blockquote>
<p>
It was the best of times,<br>
it was the worst of times,<br>
it was the age of wisdom,<br>
it was the age of foolishness,<br>
it was the epoch of belief,<br>
it was the epoch of incredulity,<br>
it was the season of Light,<br>
it was the season of Darkness,<br>
it was the spring of hope,<br>
it was the winter of despair,<br>
we had everything before us,<br>
we had nothing before us,<br>
we were all going direct to Heaven,<br>
we were all going direct the other way
</p>
</blockquote>

<p>can be compressed into</p>

<blockquote>
<p>
It was the best of times,<br>
i(26,10)wor(27,24)age(25,4)wisdom(26,20)<br>
foolishnes(57,14)epoch(33,4)belief
(28,22)incredulity<br>
(33,13)season(34,4)Light(28,23)Dark(120,17)<br>
spring(31,4)hope(231,14)inter(27,4)despair,<br>
we had everyth(57,4)before us(29,9)no(26,20)<br>
we(12,3)all go(29,4)direct to Heaven<br>
(36,28)(139,3)(83,3)(138,3)way<br>
</p>
</blockquote>

<p>One exciting aspect of back references is that they can overlap with themselves, which happens when the length is greater than the distance. This is best illustrated by an example:

</p><blockquote>
<p>
Fa<span class="lzsrc">-la</span>-la-la-la
</p>
</blockquote>

<p>can be compressed into</p>

<blockquote>
<p>
Fa-la(3,9)
</p>
</blockquote>

<p>This may seem strange, but it works: once the first three "-la" bytes have been copied, the copying continues using the recently output bytes.</p>

<p>This is effectively a form of <a href="https://en.wikipedia.org/wiki/Run-length_encoding">run-length encoding</a>, where a piece of data is copied repeatedly up to a certain length.</p>

<p>See Colin Morris's <a href="https://pudding.cool/2017/05/song-repetition/">Are Pop Lyrics Getting More Repetitive?</a> article for an interactive example of Lempel–Ziv compression applied to song lyrics.</p>

<p>Expressed in C, a back reference can be copied out as shown below. Note that because of the possible self-overlap, we cannot use <span class="code">memcpy</span> or <span class="code">memmove</span>.</p>

<div class="highlight"><pre><span></span><span class="cm">/* Output the (dist,len) back reference at dst_pos in dst. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lz77_output_backref</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dst_pos</span><span class="p">,</span>
                                       <span class="kt">size_t</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">dst_pos</span> <span class="o">&amp;&amp;</span> <span class="s">"cannot reference before beginning of dst"</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span> <span class="o">-</span> <span class="n">dist</span><span class="p">];</span>
                <span class="n">dst_pos</span><span class="o">++</span><span class="p">;
        }
}</span>
</pre></div>


<p>Literals are trivial to output but we provide a utility function for completeness:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Output a literal byte at dst_pos in dst. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lz77_output_lit</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dst_pos</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">lit</span><span class="p">)
{</span>
        <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">lit</span><span class="p">;
}</span>
</pre></div>


<p>Note that the caller of these functions is responsible for making sure there is enough room in <span class="code">dst</span> for the output, and that the back reference does not try to go before the start of the buffer.</p>

<p>Of course the hard part is not to output back references during decompression, but rather how to find them in the first place when compressing the original data. There are different ways of doing that, but we will follow zlib's hash table-based approach, which is also what RFC 1951 suggests.</p>

<p>The idea is to maintain a hash table with the positions of four-character prefixes that have occurred previously in the string (shorter back references are not considered profitable). For Deflate, only back references to the most recent 32,768 characters, the <em>window</em>, are allowed. This enables <em>streaming compression</em>: the input can be processed a little at a time, as long as the window with the most recent bytes are kept in memory. However, our implementation will assume that the full input is available and process it in one go, allowing us to focus on the compression instead of the bookkeeping required for streaming.</p>

<p>We will use two arrays: <span class="code">head</span> maps the hash value of a four-letter prefix to a position in the input data, and <span class="code">prev</span> maps a position to the previous position with the same hash value. In effect, <span class="code">head[h]</span> is the head of a linked list of positions of prefixes with hash <span class="code">h</span>, and <span class="code">prev[x]</span> gets the element previous to <span class="code">x</span> in the list.</p>

<div class="highlight"><pre><span></span><span class="cp">#define LZ_WND_SIZE 32768

#define HASH_SIZE 15
#define NO_POS    SIZE_MAX
#define MIN_LEN   4</span>


<span class="cm">/* Perform LZ77 compression on the src_len bytes in src, with back references
   limited to a certain maximum distance and length, and with or without
   self-overlap. Returns false as soon as either of the callback functions
   returns false, otherwise returns true when all bytes have been processed. */</span>
<span class="kt">bool</span> <span class="nf">lz77_compress</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">src_len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">max_dist</span><span class="p">,</span>
                   <span class="kt">size_t</span> <span class="n">max_len</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">allow_overlap</span><span class="p">,</span>
                   <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">lit_callback</span><span class="p">)(</span><span class="kt">uint8_t</span> <span class="n">lit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">),</span>
                   <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">backref_callback</span><span class="p">)(</span><span class="kt">size_t</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">),</span>
                   <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">head</span><span class="p">[</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">HASH_SIZE</span><span class="p">];</span>
        <span class="kt">size_t</span> <span class="n">prev</span><span class="p">[</span><span class="n">LZ_WND_SIZE</span><span class="p">];</span>

        <span class="kt">uint32_t</span> <span class="n">h</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">dist</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">match_len</span><span class="p">,</span> <span class="n">match_pos</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">prev_match_len</span><span class="p">,</span> <span class="n">prev_match_pos</span><span class="p">;</span>

        <span class="cm">/* Initialize the hash table. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">head</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">NO_POS</span><span class="p">;
        }</span>
</pre></div>


<p>To insert a new string position in the hash table, <span class="code">prev</span> is updated to point to the previous head, and <span class="code">head</span> is then updated:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">insert_hash</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">prev</span><span class="p">)
{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">NO_POS</span> <span class="o">&amp;&amp;</span> <span class="s">"Invalid pos!"</span><span class="p">);</span>
        <span class="n">prev</span><span class="p">[</span><span class="n">pos</span> <span class="o">%</span> <span class="n">LZ_WND_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span>
        <span class="n">head</span><span class="p">[</span><span class="n">hash</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;
}</span>
</pre></div>


<p>Note the modulo operation when indexing into <span class="code">prev</span>: we only care about positions that fall inside the current window.</p>

<p>A simple function is used to compute the hash values: (<span class="code">read32le</span> reads a 32-bit value in little-endian order, and is implemented in <a href="https://www.hanshq.net/files/hwzip/bits.h"><span class="code">bits.h</span></a>)</p>

<div class="highlight"><pre><span></span><span class="cm">/* Compute a hash value based on four bytes pointed to by ptr. */</span>
<span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">hash4</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)
{</span>
        <span class="k">static const</span> <span class="kt">uint32_t</span> <span class="n">HASH_MUL</span> <span class="o">=</span> <span class="mi">2654435761U</span><span class="p">;</span>

        <span class="cm">/* Knuth's multiplicative hash. */</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">read32le</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="o">*</span> <span class="n">HASH_MUL</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">HASH_SIZE</span><span class="p">);
}</span>
</pre></div>


<p>The hash map can then be used to search efficiently for a previous match with a substring, as shown below. Searching for matches is the most computationally expensive part of the compression, so we limit how far back the list of potential matches we search.</p>

<p>Changing parameters such as how far back the list of prefixes to search (and whether to do lazy matching, described further down) is a way of trading less compression for more speed. The settings in our code are chosen to match those of zlib's maximum compression level.</p>

<div class="highlight"><pre><span></span><span class="cm">/* Find the longest most recent string which matches the string starting
 * at src[pos]. The match must be strictly longer than prev_match_len and
 * shorter or equal to max_match_len. Returns the length of the match if found
 * and stores the match position in *match_pos, otherwise returns zero. */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">find_match</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">,</span>
                         <span class="kt">size_t</span> <span class="n">max_dist</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">prev_match_len</span><span class="p">,</span>
                         <span class="kt">size_t</span> <span class="n">max_match_len</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">allow_overlap</span><span class="p">,</span>
                         <span class="k">const</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
                         <span class="kt">size_t</span> <span class="o">*</span><span class="n">match_pos</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">max_match_steps</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">found</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">max_cmp</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">prev_match_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="cm">/* We want backrefs of length MIN_LEN or longer. */</span>
                <span class="n">prev_match_len</span> <span class="o">=</span> <span class="n">MIN_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">prev_match_len</span> <span class="o">&gt;=</span> <span class="n">max_match_len</span><span class="p">) {</span>
                <span class="cm">/* A longer match would be too long. */</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">prev_match_len</span> <span class="o">&gt;=</span> <span class="mi">32</span><span class="p">) {</span>
                <span class="cm">/* Do not try too hard if there is already a good match. */</span>
                <span class="n">max_match_steps</span> <span class="o">/=</span> <span class="mi">4</span><span class="p">;
        }</span>

        <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span>
        <span class="n">max_cmp</span> <span class="o">=</span> <span class="n">max_match_len</span><span class="p">;</span>

        <span class="cm">/* Walk the linked list of prefix positions. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">NO_POS</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">LZ_WND_SIZE</span><span class="p">]) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">max_match_steps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="k">break</span><span class="p">;
                }</span>
                <span class="n">max_match_steps</span><span class="o">--</span><span class="p">;</span>

                <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">pos</span> <span class="o">&amp;&amp;</span> <span class="s">"Matches should precede pos."</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">max_dist</span><span class="p">) {</span>
                        <span class="cm">/* The match is too far back. */</span>
                        <span class="k">break</span><span class="p">;
                }</span>

                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allow_overlap</span><span class="p">) {</span>
                        <span class="n">max_cmp</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">max_match_len</span><span class="p">,</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">max_cmp</span> <span class="o">&lt;=</span> <span class="n">prev_match_len</span><span class="p">) {</span>
                                <span class="k">continue</span><span class="p">;
                        }
                }</span>

                <span class="n">l</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">prev_match_len</span><span class="p">,</span> <span class="n">max_cmp</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">prev_match_len</span><span class="p">);</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">max_match_len</span><span class="p">);</span>

                        <span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                        <span class="o">*</span><span class="n">match_pos</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                        <span class="n">prev_match_len</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">max_match_len</span><span class="p">) {</span>
                                <span class="cm">/* A longer match is not possible. */</span>
                                <span class="k">return</span> <span class="n">l</span><span class="p">;
                        }
                }
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">) {</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="n">prev_match_len</span><span class="p">;
}</span>

<span class="cm">/* Compare the substrings starting at src[i] and src[j], and return the length
 * of the common prefix if it is strictly longer than prev_match_len
 * and shorter or equal to max_match_len, otherwise return zero. */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">cmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">j</span><span class="p">,</span>
                  <span class="kt">size_t</span> <span class="n">prev_match_len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">max_match_len</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">l</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">prev_match_len</span> <span class="o">&lt;</span> <span class="n">max_match_len</span><span class="p">);</span>

        <span class="cm">/* Check whether the first prev_match_len + 1 characters match. Do this
         * backwards for a higher chance of finding a mismatch quickly. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">prev_match_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">prev_match_len</span> <span class="o">-</span> <span class="n">l</span><span class="p">]</span> <span class="o">!=</span>
                    <span class="n">src</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">prev_match_len</span> <span class="o">-</span> <span class="n">l</span><span class="p">]) {</span>
                        <span class="k">return</span> <span class="mi">0</span><span class="p">;
                }
        }</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">prev_match_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

        <span class="cm">/* Now check how long the full match is. */</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">max_match_len</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="o">!=</span> <span class="n">src</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">l</span><span class="p">]) {</span>
                        <span class="k">break</span><span class="p">;
                }
        }</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">prev_match_len</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">max_match_len</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">l</span><span class="p">;
}</span>
</pre></div>


<p>With the code for finding previous matches in place, we can finish the <span class="code">lz77_compress</span> function:</p>

<div class="highlight"><pre><span></span>        <span class="n">prev_match_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">prev_match_pos</span> <span class="o">=</span> <span class="n">NO_POS</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">MIN_LEN</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">src_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="cm">/* Search for a match using the hash table. */</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">hash4</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="n">match_len</span> <span class="o">=</span> <span class="n">find_match</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">max_dist</span><span class="p">,</span> <span class="n">prev_match_len</span><span class="p">,</span>
                                       <span class="n">min</span><span class="p">(</span><span class="n">max_len</span><span class="p">,</span> <span class="n">src_len</span> <span class="o">-</span> <span class="n">i</span><span class="p">),</span> <span class="n">allow_overlap</span><span class="p">,</span>
                                       <span class="n">head</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">match_pos</span><span class="p">);</span>

                <span class="cm">/* Insert the current hash for future searches. */</span>
                <span class="n">insert_hash</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>

                <span class="cm">/* If the previous match is at least as good as the current. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">prev_match_len</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">prev_match_len</span> <span class="o">&gt;=</span> <span class="n">match_len</span><span class="p">) {</span>
                        <span class="cm">/* Output the previous match. */</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">prev_match_pos</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">backref_callback</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">prev_match_len</span><span class="p">,</span> <span class="n">aux</span><span class="p">)) {</span>
                                <span class="k">return</span> <span class="nb">false</span><span class="p">;
                        }</span>
                        <span class="cm">/* Move past the match. */</span>
                        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">((</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">prev_match_len</span><span class="p">,</span>
                                                <span class="n">src_len</span> <span class="o">-</span> <span class="p">(</span><span class="n">MIN_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span> <span class="n">j</span><span class="o">++</span><span class="p">) {</span>
                                <span class="n">h</span> <span class="o">=</span> <span class="n">hash4</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
                                <span class="n">insert_hash</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">prev</span><span class="p">);
                        }</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">prev_match_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="n">prev_match_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                        <span class="k">continue</span><span class="p">;
                }</span>

                <span class="cm">/* If no match (and no previous match), output literal. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">match_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">prev_match_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lit_callback</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">aux</span><span class="p">)) {</span>
                                <span class="k">return</span> <span class="nb">false</span><span class="p">;
                        }</span>
                        <span class="k">continue</span><span class="p">;
                }</span>

                <span class="cm">/* Otherwise the current match is better than the previous. */</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">prev_match_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="cm">/* Output a literal instead of the previous match. */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lit_callback</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">aux</span><span class="p">)) {</span>
                                <span class="k">return</span> <span class="nb">false</span><span class="p">;
                        }
                }</span>

                <span class="cm">/* Defer this match and see if the next is even better. */</span>
                <span class="n">prev_match_len</span> <span class="o">=</span> <span class="n">match_len</span><span class="p">;</span>
                <span class="n">prev_match_pos</span> <span class="o">=</span> <span class="n">match_pos</span><span class="p">;
        }</span>

        <span class="cm">/* Output any previous match. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prev_match_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">prev_match_pos</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">backref_callback</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">prev_match_len</span><span class="p">,</span> <span class="n">aux</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>
                <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">prev_match_len</span><span class="p">;
        }</span>

        <span class="cm">/* Output any remaining literals. */</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">src_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lit_callback</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">aux</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }
        }</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<p>The code looks for the longest possible back reference that could be emitted at the current position. However, before outputting that back reference, it considers whether an even longer match could be found at the next position. zlib calls this <em>lazy match evaluation</em>. This is still a <em>greedy</em> algorithm: it chooses the longest match, even though a shorter match now might allow for a longer match later and better compression overall.</p>

<p>Lempel–Ziv compression can be both fast and slow. <a href="https://github.com/google/zopfli">Zopfli</a> spends a lot of time trying to find optimal back references to squeeze out a few extra percent of compression. This is useful for data that is compressed once and used many times, such as static content on a web server.  On the other end of the spectrum are compressors such as <a href="https://github.com/google/snappy">Snappy</a> and <a href="https://lz4.github.io/lz4/">LZ4</a>, which match only against the most recent 4-byte prefix and run very fast. Such compression can be useful in database or RPC systems, where a short moment spent compressing is paid off by time savings when sending data over the network or to and from disk.</p>

<p>The Lempel–Ziv idea of using the source data itself as the dictionary is very elegant, but using a static dictionary can still be beneficial. <a href="https://github.com/google/brotli">Brotli</a> is an LZ77-based compression algorithm, but it also uses a large <a href="https://gist.github.com/klauspost/2900d5ba6f9b65d69c8e">static dictionary</a> of strings that occur frequently on the web.</p>

<p>The LZ77 code is available in <a href="https://www.hanshq.net/files/hwzip/lz77.h"><span class="code">lz77.h</span></a> and <a href="https://www.hanshq.net/files/hwzip/lz77.c"><span class="code">lz77.c</span></a>.</p>

<a name="huffman"></a>
<h2>Huffman Coding</h2>

<p>The second ingredient in Zip compression is Huffman coding.</p>

<p>The term <em>code</em> in this context refers to a system for representing some data in another form. For our purposes, we are interested in codes that can be used to represent the literals and back references produced by the Lempel–Ziv compression above efficiently.</p>

<p>Computers traditionally represent English text using the <a href="https://en.wikipedia.org/wiki/ASCII">American Standard Code for Information Interchange (ASCII)</a>. That code assigns a number to each character, and computers typically store each such number in an 8-bit byte. For example, the text you are reading now is originally stored like that. Here is the ASCII code for the upper-case English alphabet:</p>

<table border="1">
<tbody><tr>
<th>A</th> <td>01000001</td>
<th>N</th> <td>01001110</td>
</tr>

<tr>
<th>B</th> <td>01000010</td>
<th>O</th> <td>01001111</td>
</tr>

<tr>
<th>C</th> <td>01000011</td>
<th>P</th> <td>01010000</td>
</tr>

<tr>
<th>D</th> <td>01000100</td>
<th>Q</th> <td>01010001</td>
</tr>

<tr>
<th>E</th> <td>01000101</td>
<th>R</th> <td>01010010</td>
</tr>

<tr>
<th>F</th> <td>01000110</td>
<th>S</th> <td>01010011</td>
</tr>

<tr>
<th>G</th> <td>01000111</td>
<th>T</th> <td>01010100</td>
</tr>

<tr>
<th>H</th> <td>01001000</td>
<th>U</th> <td>01010101</td>
</tr>

<tr>
<th>I</th> <td>01001001</td>
<th>V</th> <td>01010110</td>
</tr>

<tr>
<th>J</th> <td>01001010</td>
<th>W</th> <td>01010111</td>
</tr>

<tr>
<th>K</th> <td>01001011</td>
<th>X</th> <td>01011000</td>
</tr>

<tr>
<th>L</th> <td>01001100</td>
<th>Y</th> <td>01011001</td>
</tr>

<tr>
<th>M</th> <td>01001101</td>
<th>Z</th> <td>01011010</td>
</tr>
</tbody></table>

<p>Using one byte per character is a convenient way of storing text. It makes it easy to access or change parts of the text, and it is obvious how many bytes are required to store <span class="code">N</span> characters or how many characters are stored in <span class="code">N</span> bytes. However, it is not the most space efficient way. For example, E and Z are the most and least used characters in English text, respectively. Therefore it would be more space efficient to use a shorter bit representation for E and a longer for Z, instead of using the same number of bits for each character.</p>

<p>A code that specifies different-length codewords for different source symbols is called a <em>variable-length code</em>. The most famous example is <a href="https://en.wikipedia.org/wiki/Morse_code">Morse code</a>, which encodes symbols using dots and dashes, originally transmitted as short and long electric pulses over a telegraph wire:</p>

<table border="1" style="font-weight: bold">
<tbody><tr>
<th>A</th> <td>•&nbsp;−</td>
<th>N</th> <td>−&nbsp;•</td>
</tr>

<tr>
<th>B</th> <td>−&nbsp;•&nbsp;•&nbsp;•</td>
<th>O</th> <td>−&nbsp;−&nbsp;−</td>
</tr>

<tr>
<th>C</th> <td>−&nbsp;•&nbsp;−&nbsp;•</td>
<th>P</th> <td>•&nbsp;−&nbsp;−&nbsp;•</td>
</tr>

<tr>
<th>D</th> <td>−&nbsp;•&nbsp;•</td>
<th>Q</th> <td>−&nbsp;−&nbsp;•&nbsp;−</td>
</tr>

<tr>
<th>E</th> <td>•</td>
<th>R</th> <td>•&nbsp;−&nbsp;•</td>
</tr>

<tr>
<th>F</th> <td>•&nbsp;•&nbsp;−&nbsp;•</td>
<th>S</th> <td>•&nbsp;•&nbsp;•</td>
</tr>

<tr>
<th>G</th> <td>−&nbsp;−&nbsp;•</td>
<th>T</th> <td>−</td>
</tr>

<tr>
<th>H</th> <td>•&nbsp;•&nbsp;•&nbsp;•</td>
<th>U</th> <td>•&nbsp;•&nbsp;−</td>
</tr>

<tr>
<th>I</th> <td>•&nbsp;•</td>
<th>V</th> <td>•&nbsp;•&nbsp;•&nbsp;−</td>
</tr>

<tr>
<th>J</th> <td>•&nbsp;−&nbsp;−&nbsp;−</td>
<th>W</th> <td>•&nbsp;−&nbsp;−</td>
</tr>

<tr>
<th>K</th> <td>−&nbsp;•&nbsp;−</td>
<th>X</th> <td>−&nbsp;•&nbsp;•&nbsp;−</td>
</tr>

<tr>
<th>L</th> <td>•&nbsp;−&nbsp;•&nbsp;•</td>
<th>Y</th> <td>−&nbsp;•&nbsp;−&nbsp;−</td>
</tr>

<tr>
<th>M</th> <td>−&nbsp;−</td>
<th>Z</th> <td>−&nbsp;−&nbsp;•&nbsp;•</td>
</tr>
</tbody></table>

<p>One problem with Morse code is that one codeword can be the prefix of another. For example, •&nbsp;•&nbsp;−&nbsp;• is not uniquely decodable: it could mean either F or ER. This problem is solved by making pauses (the length of three dots) between letters during transmission. However, a better solution would be if no codeword was the prefix of another. Such a code is called a <em>prefix-free code</em>, or sometimes just <em>prefix code</em>. The fixed-length ASCII code above is trivially prefix-free since the codewords are all the same length, but variable-length codes can also be prefix-free. Telephone numbers are mostly prefix-free. Before the <a href="https://en.wikipedia.org/wiki/112_(emergency_telephone_number)">112</a> emergency telephone number was adopted in Sweden, all existing phone numbers starting with 112 had to be changed, and nobody in the US has a phone number starting with 911.</p>

<p>To minimize the size of an encoded message, we would like a prefix-free code where frequently occurring symbols have shorter codewords than infrequent ones. The optimum code would be one which generates the shortest possible result, that is, a code where the sum of the codeword lengths multiplied by their frequency of occurrence is as small as possible. This is called a <em>minimum-redundancy prefix-free code</em>, or these days a <em>Huffman code</em> after the man who invented an efficient algorithm for constructing them.</p>


<a name="huffalg"></a>
<h3>Huffman's Algorithm</h3>

<p>While studying for his doctorate in electrical engineering at MIT, David A. Huffman took a course in information theory taught by Robert Fano. <a href="https://www.huffmancoding.com/my-uncle/scientific-american">According to legend</a>, Fano gave his students a choice between taking a final exam or writing a term paper. Huffman chose the latter, and was assigned the topic of finding minimum-redundancy prefix-free codes. Huffman was allegedly not aware that this was an open problem which Fano himself had worked on (the best known method at the time was <a href="https://en.wikipedia.org/wiki/Shannon%E2%80%93Fano_coding">Shannon-Fano coding</a>). Huffman's paper was published as <a href="https://www.ic.tu-berlin.de/fileadmin/fg121/Source-Coding_WS12/selected-readings/10_04051119.pdf">A Method for the Construction of Minimum-Redundancy Codes</a> in 1952, and the algorithm has been widely used ever since.</p>

<div style="text-align: center">
<img src="./zip_files/huffman.jpg" alt="David A. Huffman" style="max-width: 90%">
<p>Photo of David A. Huffman from a UC Santa Cruz <a href="https://www.cise.ufl.edu/~manuel/huffman/press.release.html">press release</a>.</p>
</div>

<p>Huffman's algorithm creates a minimum-redundancy prefix-free code for a set of symbols and their frequencies of use. The algorithm works by repeatedly selecting the two symbols, say X and Y, with the lowest frequencies from the set, and replacing them with a single <em>composite symbol</em> which represents "X or Y". The frequency of the composite symbol is the sum of the frequencies of the two original symbols. The codewords for X and Y can be whatever codeword gets assigned to the composite "X or Y" symbol, followed by a 0 or 1 to differentiate between the two original symbols. When the set has been reduced to a single symbol, the algorithm is done. (See <a href="https://www.youtube.com/watch?v=ZdooBTdW5bM">this video</a> for a good explanation.)</p>


<p>Below is an example of running the algorithm on a small set of symbols:</p>

<table border="1">
<tbody><tr><th>Symbol</th> <th>Frequency</th></tr>
<tr><td>A</td> <td>6</td></tr>
<tr><td>B</td> <td>4</td></tr>
<tr><td>C</td> <td>2</td></tr>
<tr><td>D</td> <td>3</td></tr>
</tbody></table>

<p>Initially, the set of symbols to be processed (coloured blue) is our original symbols:</p>

<div class="latex"><p style="margin-left: 2em"><img src="./zip_files/tex_a8347fd0.svg" alt="LaTeX"></p></div>

<p>The two lowest-frequency symbols, C and D, are removed from the set, and replaced by a composite symbol whose frequency is the sum of C and D's frequencies.</p>

<div class="latex"><p style="margin-left: 2em"><img src="./zip_files/tex_98d681cf.svg" alt="LaTeX"></p></div>

<p>The lowest-frequency symbols are now B and the composite symbol with frequency five. These are removed from the set, and a new composite symbol with frequency nine is inserted instead:</p>

<div class="latex"><p style="margin-left: 2em"><img src="./zip_files/tex_a83ef7ed.svg" alt="LaTeX"></p></div>

<p>Finally, A and the composite node with frequency 9 have the lowest frequencies, and so a composite node with frequency 15 is inserted.</p>

<a name="earlier"></a>
<div class="latex"><p style="margin-left: 2em"><img src="./zip_files/tex_e999d62f.svg" alt="LaTeX"></p></div>

<p>Since there is only one node left in the set, the algorithm is finished.</p>

<p>The algorithm leaves us with a structure called a <em>Huffman tree</em>. Note how it has our input symbols as leaves, and symbols with higher frequency are closer to the top. We can derive codewords for our symbols from this tree by starting at the root, walking towards a symbol, and adding a 0 or 1 to the codeword when going left or right, respectively. If we do that, we end up with:</p>

<table border="1">
<tbody><tr><th>Symbol</th> <th>codeword</th></tr>
<tr><td>A</td> <td>0</td></tr>
<tr><td>B</td> <td>10</td></tr>
<tr><td>C</td> <td>110</td></tr>
<tr><td>D</td> <td>111</td></tr>
</tbody></table>

<p>Note how none of the codewords are a prefix of another, and how the symbols with higher frequency have shorter codewords.</p>

<p>The tree can also be used for decoding: start at the root and go left or right for 0 or 1 until a symbol is reached. For example, the string 010100 decodes to ABBA.</p>

<p>Note that the length of each codeword equals the depth of the corresponding node in the tree. As we will see in the next section, we do not need the actual tree to assign codewords; knowing the lengths of the codewords is enough. Therefore, the output of our implementation of Huffman's algorithm will be those codeword lengths.</p>

<p>To store the set of symbols and efficiently find the one with lowest frequency, we use a <a href="https://en.wikipedia.org/wiki/Binary_heap">binary heap</a> data structure, specifically a <em>min-heap</em> since we want the minimum value on top.</p>

<div class="highlight"><pre><span></span><span class="cm">/* Swap the 32-bit values pointed to by a and b. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swap32</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">b</span><span class="p">)
{</span>
        <span class="kt">uint32_t</span> <span class="n">tmp</span><span class="p">;</span>

        <span class="n">tmp</span> <span class="o">= *</span><span class="n">a</span><span class="p">;</span>
        <span class="o">*</span><span class="n">a</span> <span class="o">= *</span><span class="n">b</span><span class="p">;</span>
        <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;
}</span>

<span class="cm">/* Move element i in the n-element heap down to restore the minheap property. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">minheap_down</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="n">heap</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">min</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="s">"i must be inside the heap"</span><span class="p">);</span>

        <span class="cm">/* While the i-th element has at least one child. */</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">) {</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

                <span class="cm">/* Find the child with lowest value. */</span>
                <span class="n">min</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">heap</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">left</span><span class="p">]) {</span>
                        <span class="n">min</span> <span class="o">=</span> <span class="n">right</span><span class="p">;
                }</span>

                <span class="cm">/* Move i down if it is larger. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="n">min</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">i</span><span class="p">]) {</span>
                        <span class="n">swap32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">[</span><span class="n">min</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">heap</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">min</span><span class="p">;
                }</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">break</span><span class="p">;
                }
        }
}</span>

<span class="cm">/* Establish minheap property for heap[1..n]. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">minheap_heapify</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="n">heap</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

        <span class="cm">/* Floyd's algorithm. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">) {</span>
                <span class="n">minheap_down</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">);
        }
}</span>
</pre></div>


<p>To keep track of the frequency of up to <span class="code">n</span> symbols we will use a heap of <span class="code">n</span> elements. In addition, every time we create a composite symbol, we want to "link" the two original symbols to the new one. So each symbol will also have a "link element".</p>

<p>We will use a single array of <span class="code">n * 2 + 1</span> elements to store the <span class="code">n</span>-element heap and the <span class="code">n</span> link elements. When two symbols in the heap are replaced by one, we will use the leftover array element to store the link of the new symbol. This is based on the implementation in Witten, Moffat and Bell's <a href="https://people.eng.unimelb.edu.au/ammoffat/mg/">Managing Gigabytes</a>.</p>

<p>In each heap node, we will use the upper 16 bits to store the symbol's frequency, and the lower 16 bits to store the index of the symbol's link element. By using the upper bits, the difference in frequency will determine the outcome of 32-bit comparisons between two heap elements.</p>

<p>Because of this representation, we must be sure that a symbol's frequency always fits within 16 bits. When the algorithm is finished, the final composite symbol will have the frequency of all original symbols combined, so therefore this sum must fit within 16 bits. Our Deflate implementation will make sure of this by processing at most 65,535 symbols at a time.</p>

<p>Symbols with zero frequency will receive a codeword length of zero and not take part in the construction of the code.</p>

<p>If a codeword exceeds the designated maximum length, we will "flatten" the distribution of the symbol frequencies by imposing a frequency cap and try again (yes, with a <span class="code">goto</span>). There are more sophisticated ways of doing length-limited Huffman coding, but this is simple and effective.</p>

<div class="highlight"><pre><span></span><span class="cp">#define MAX_HUFFMAN_SYMBOLS 288      </span><span class="cm">/* Deflate uses max 288 symbols. */</span><span class="cp"></span>

<span class="cm">/* Construct a Huffman code for n symbols with the frequencies in freq, and
 * codeword length limited to max_len. The sum of the frequencies must be &lt;=
 * UINT16_MAX. max_len must be large enough that a code is always possible,
 * i.e. 2 ** max_len &gt;= n. Symbols with zero frequency are not part of the code
 * and get length zero. Outputs the codeword lengths in lengths[0..n-1]. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">compute_huffman_lengths</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">freqs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span>
                                    <span class="kt">uint8_t</span> <span class="n">max_len</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">lengths</span><span class="p">)
{</span>
        <span class="kt">uint32_t</span> <span class="n">nodes</span><span class="p">[</span><span class="n">MAX_HUFFMAN_SYMBOLS</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">freq</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">l</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">freq_cap</span> <span class="o">=</span> <span class="n">UINT16_MAX</span><span class="p">;</span>

<span class="cp">#ifndef NDEBUG</span>
        <span class="kt">uint32_t</span> <span class="n">freq_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">freq_sum</span> <span class="o">+=</span> <span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">];
        }</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">freq_sum</span> <span class="o">&lt;=</span> <span class="n">UINT16_MAX</span> <span class="o">&amp;&amp;</span> <span class="s">"Frequency sum too large!"</span><span class="p">);</span>
<span class="cp">#endif</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">MAX_HUFFMAN_SYMBOLS</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">((</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">max_len</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="s">"max_len must be large enough"</span><span class="p">);</span>

<span class="nl">try_again</span><span class="p">:</span>
        <span class="cm">/* Initialize the heap. h is the heap size. */</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">freq</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="k">continue</span><span class="p">;</span> <span class="cm">/* Ignore zero-frequency symbols. */</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">freq</span> <span class="o">&gt;</span> <span class="n">freq_cap</span><span class="p">) {</span>
                        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq_cap</span><span class="p">;</span> <span class="cm">/* Enforce the frequency cap. */</span>
                <span class="p">}</span>

                <span class="cm">/* High 16 bits: Symbol frequency.
                   Low 16 bits:  Symbol link element index. */</span>
                <span class="n">h</span><span class="o">++</span><span class="p">;</span>
                <span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">freq</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">n</span> <span class="o">+</span> <span class="n">h</span><span class="p">);
        }</span>
        <span class="n">minheap_heapify</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

        <span class="cm">/* Special case for fewer than two non-zero symbols. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">) {</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                        <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;
                }</span>
                <span class="k">return</span><span class="p">;
        }</span>

        <span class="cm">/* Build the Huffman tree. */</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">) {</span>
                <span class="cm">/* Remove the lowest frequency node p from the heap. */</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
                <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="o">--</span><span class="p">];</span>
                <span class="n">minheap_down</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

                <span class="cm">/* Get q, the next lowest frequency node. */</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

                <span class="cm">/* Replace q with a new symbol with the combined frequencies of
                   p and q, and with the no longer used h+1'th node as the
                   link element. */</span>
                <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">p</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">q</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">))</span>
                           <span class="o">|</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

                <span class="cm">/* Set the links of p and q to point to the link element of
                   the new node. */</span>
                <span class="n">nodes</span><span class="p">[</span><span class="n">p</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">q</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

                <span class="cm">/* Move the new symbol down to restore heap property. */</span>
                <span class="n">minheap_down</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">1</span><span class="p">);
        }</span>

        <span class="cm">/* Compute the codeword length for each symbol. */</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                        <span class="k">continue</span><span class="p">;
                }</span>
                <span class="n">h</span><span class="o">++</span><span class="p">;</span>

                <span class="cm">/* Link element for the i-th symbol. */</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">h</span><span class="p">];</span>

                <span class="cm">/* Follow the links until we hit the root (link index 2). */</span>
                <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">) {</span>
                        <span class="n">l</span><span class="o">++</span><span class="p">;</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">p</span><span class="p">];
                }</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">max_len</span><span class="p">) {</span>
                        <span class="cm">/* Lower freq_cap to flatten the distribution. */</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">freq_cap</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="s">"Cannot lower freq_cap!"</span><span class="p">);</span>
                        <span class="n">freq_cap</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
                        <span class="k">goto</span> <span class="n">try_again</span><span class="p">;
                }</span>

                <span class="n">assert</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">UINT8_MAX</span><span class="p">);</span>
                <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">l</span><span class="p">;
        }
}</span>
</pre></div>


<p>An elegant alternative to the binary heap approach is to store the symbols in two queues. The first queue contains the original symbols, sorted by frequency. When a composite symbol is created, it is added to the second queue. This way, the lowest-frequency symbol will always be found at the front of one of the queues. This was described by <a href="https://www.staff.science.uu.nl/~leeuw112/">Jan van Leeuwen</a> in <a href="https://www.staff.science.uu.nl/~leeuw112/huffman.pdf">On the Construction of Huffman Trees</a> (1976).</p>
<!-- Brotli uses this approach: https://github.com/google/brotli/blob/v1.0.7/c/enc/entropy_encode.c#L111 -->

<p>While Huffman codes are optimal as far as prefix-free codes go, there are more efficient ways to encode data beyond prefix coding, such as <a href="https://en.wikipedia.org/wiki/Arithmetic_coding">Arithmetic coding</a> and <a href="https://en.wikipedia.org/wiki/Asymmetric_numeral_systems">Asymmetric numeral systems</a>.</p>

<a name="canhuff"></a>
<h3>Canonical Huffman Codes</h3>

<p>In the <a href="https://www.hanshq.net/zip.html#earlier">earlier example</a> we ended up with the Huffman tree below.</p>

<div class="latex"><p style="margin-left: 2em"><img src="./zip_files/tex_e999d62f.svg" alt="LaTeX"></p></div>

<p>By walking down the tree from the root and using 0 for left branches and 1 for right branches, we ended up with the following code:</p>

<table border="1">
<tbody><tr><th>Symbol</th> <th>codeword</th></tr>
<tr><td>A</td> <td>0</td></tr>
<tr><td>B</td> <td>10</td></tr>
<tr><td>C</td> <td>110</td></tr>
<tr><td>D</td> <td>111</td></tr>
</tbody></table>

<p>The decision to use 0 for left 1 for right branches seems arbitrary. If we do the reverse we get:</p>

<table border="1">
<tbody><tr><th>Symbol</th> <th>codeword</th></tr>
<tr><td>A</td> <td>1</td></tr>
<tr><td>B</td> <td>01</td></tr>
<tr><td>C</td> <td>001</td></tr>
<tr><td>D</td> <td>000</td></tr>
</tbody></table>

<p>In fact, we can label the two edges from a node with 0 or 1 arbitrarily (as long as the labels are different) and still end up with an equivalent code:</p>

<div class="latex"><p style="margin-left: 2em"><img src="./zip_files/tex_2403b72d.svg" alt="LaTeX"></p></div>

<table border="1">
<tbody><tr><th>Symbol</th> <th>codeword</th></tr>
<tr><td>A</td> <td>0</td></tr>
<tr><td>B</td> <td>11</td></tr>
<tr><td>C</td> <td>100</td></tr>
<tr><td>D</td> <td>101</td></tr>
</tbody></table>


<p>This shows that while Huffman's algorithm gives the requisite codeword lengths for a minimum-redundancy prefix-free code, there are many ways of assigning the individual codewords.</p>
<p>Given codeword lengths computed by Huffman's algorithm, a <em>Canonical Huffman code</em> assigns codewords to symbols in a specific way. This is useful because it makes it sufficient to store and transmit the codeword lengths with the compressed data: the decoder can reconstruct the codewords based on the lengths. (One could of course also store and transmit the symbol frequencies and run Huffman's algorithm in the decoder, but that would require more work for the decoder and likely more storage space too.) Another very important property is that the structure of canonical codes facilitates efficient decoding.</p>

<p>The idea is to assign codewords to the symbols sequentially, one codeword length at a time. The initial codeword is 0. The next codeword of some length is the previous one plus 1. The first codeword of length N is constructed by taking the last codeword of length N-1, adding one (to get a new codeword) and shifting left one step (to increase the length).</p>

<p>Viewed in terms of a Huffman tree, codewords are assigned in sequence to the leaves in left-to-right order, one level at a time, shifting left when we move down one level.</p>
<!--See Knuth Vol 1, S 2.3.4.5, Ex. 4-->

<p>In our A, B, C, D example, Huffman's algorithm gave codeword lengths 1,2,3,3.  The first codeword is 0. That is also the last codeword of length 1. For length 2, we take the 0, add 1 to get the next code which will be the prefix of the two-bit codes: we shift it left and obtain 10. That is also the last codeword of length 2. To get to length 3, we add one and shift: 110. To get the next one of length 3, we add one: 111.</p>

<table border="1">
<tbody><tr><th>Symbol</th> <th>codeword</th></tr>
<tr><td>A</td> <td>0</td></tr>
<tr><td>B</td> <td>10</td></tr>
<tr><td>C</td> <td>110</td></tr>
<tr><td>D</td> <td>111</td></tr>
</tbody></table>

<p>The implementation for generating the canonical codes is shown below. Note that the Deflate algorithm expects codewords to be emitted LSB-first, that is, the first bit of a codeword should be stored in the least significant bit. This means we have to reverse the bits, which can be done using a lookup table.</p>

<div class="highlight"><pre><span></span><span class="cp">#define MAX_HUFFMAN_BITS 16          </span><span class="cm">/* Implode uses max 16-bit codewords. */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">compute_canonical_code</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="o">*</span><span class="n">codewords</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">lengths</span><span class="p">,</span>
                                   <span class="kt">size_t</span> <span class="n">n</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">count</span><span class="p">[</span><span class="n">MAX_HUFFMAN_BITS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
        <span class="kt">uint16_t</span> <span class="n">code</span><span class="p">[</span><span class="n">MAX_HUFFMAN_BITS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">l</span><span class="p">;</span>

        <span class="cm">/* Count the number of codewords of each length. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">count</span><span class="p">[</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;
        }</span>
        <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Ignore zero-length codes. */

        /* Compute the first codeword for each length. */</span>
        <span class="n">code</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">MAX_HUFFMAN_BITS</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">code</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)((</span><span class="n">code</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">count</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);
        }</span>

        <span class="cm">/* Assign a codeword for each symbol. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="k">continue</span><span class="p">;
                }</span>

                <span class="n">codewords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">reverse16</span><span class="p">(</span><span class="n">code</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">++</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span> <span class="cm">/* Make it LSB-first. */</span>
        <span class="p">}
}</span>

<span class="cm">/* Reverse the n least significant bits of x.
   The (16 - n) most significant bits of the result will be zero. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint16_t</span> <span class="nf">reverse16</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)
{</span>
        <span class="kt">uint16_t</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">reversed</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">);</span>

        <span class="n">lo</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
        <span class="n">hi</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>

        <span class="n">reversed</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)((</span><span class="n">reverse8_tbl</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">reverse8_tbl</span><span class="p">[</span><span class="n">hi</span><span class="p">]);</span>

        <span class="k">return</span> <span class="n">reversed</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">16</span> <span class="o">-</span> <span class="n">n</span><span class="p">);
}</span>
</pre></div>


<p>With all the parts now in place, we can write the code to initialize the encoder:</p>

<div class="highlight"><pre><span></span><span class="k">typedef struct</span> <span class="n">huffman_encoder_t huffman_encoder_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">huffman_encoder_t</span> <span class="p">{</span>
        <span class="kt">uint16_t</span> <span class="n">codewords</span><span class="p">[</span><span class="n">MAX_HUFFMAN_SYMBOLS</span><span class="p">];</span> <span class="cm">/* LSB-first codewords. */</span>
        <span class="kt">uint8_t</span> <span class="n">lengths</span><span class="p">[</span><span class="n">MAX_HUFFMAN_SYMBOLS</span><span class="p">];</span>    <span class="cm">/* Codeword lengths. */</span>
<span class="p">};</span>
</pre></div>

<a name="huffman_encoder_init"></a>
<div class="highlight"><pre><span></span><span class="cm">/* Initialize a Huffman encoder based on the n symbol frequencies. */</span>
<span class="kt">void</span> <span class="nf">huffman_encoder_init</span><span class="p">(</span><span class="n">huffman_encoder_t</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">freqs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span>
                          <span class="kt">uint8_t</span> <span class="n">max_codeword_len</span><span class="p">)
{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">MAX_HUFFMAN_SYMBOLS</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">max_codeword_len</span> <span class="o">&lt;=</span> <span class="n">MAX_HUFFMAN_BITS</span><span class="p">);</span>

        <span class="n">compute_huffman_lengths</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">max_codeword_len</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">lengths</span><span class="p">);</span>
        <span class="n">compute_canonical_code</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">codewords</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">lengths</span><span class="p">,</span> <span class="n">n</span><span class="p">);
}</span>
</pre></div>


<p>We also provide a function for setting up an encoder based on already computed code lengths:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Initialize a Huffman encoder based on the n codeword lengths. */</span>
<span class="kt">void</span> <span class="nf">huffman_encoder_init2</span><span class="p">(</span><span class="n">huffman_encoder_t</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">lengths</span><span class="p">,</span>
                           <span class="kt">size_t</span> <span class="n">n</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">e</span><span class="o">-&gt;</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">];
        }</span>
        <span class="n">compute_canonical_code</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">codewords</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">lengths</span><span class="p">,</span> <span class="n">n</span><span class="p">);
}</span>
</pre></div>



<a name="huffdec"></a>
<h3>Efficient Huffman Decoding</h3>

<p>The most basic way of doing Huffman decoding is to walk the Huffman tree from the root, reading one bit of input at a time to decide whether to take the next left or right branch. Once a leaf node is reached, that is the decoded symbol.</p>

<p>The method above is often taught at universities and in textbooks. It is simple and elegant, but processing one bit at a time is relatively slow. A very fast way of decoding is to use a lookup table. For the code above where the max codeword length is three bits, we could use the following table:</p>

<table border="1" style="text-align: center">
<tbody><tr><th>Bits</th> <th>Symbol</th> <th>Codeword Length</th></tr>
<tr><td><b>0</b>00</td> <td>A</td> <td>1</td></tr>
<tr><td><b>0</b>01</td> <td>A</td> <td>1</td></tr>
<tr><td><b>0</b>10</td> <td>A</td> <td>1</td></tr>
<tr><td><b>0</b>11</td> <td>A</td> <td>1</td></tr>
<tr><td><b>10</b>0</td> <td>B</td> <td>2</td></tr>
<tr><td><b>10</b>1</td> <td>B</td> <td>2</td></tr>
<tr><td><b>110</b></td> <td>C</td> <td>3</td></tr>
<tr><td><b>111</b></td> <td>D</td> <td>3</td></tr>
</tbody></table>

<p>Although there are only four symbols, the table needs to have eight entries to cover all possible three-bit inputs. Symbols with codewords shorter than three bits have multiple entries in the table. For example, the 10 codeword has been "padded" to <b>10</b>0 and <b>10</b>1 to cover all three-bit inputs starting with 10.</p>

<p>To perform decoding using this method, one would index into the table using the next three bits of input, and immediately find the corresponding symbol and its codeword length. The length is important, because even though we looked at the next three bits, we should only consume as many bits of input as the actual codeword is long.</p>

<p>The lookup table approach is very fast, but there is a downside: the table size doubles with each extra bit of codeword length. This means that building the table becomes exponentially slower, and using it may also become slower if it no longer fits in the CPU's cache.</p>

<p>Because of this, a lookup table is typically only used for codewords up to a certain length, and some other approach is used for longer codewords. As Huffman coding assigns shorter codewords to more frequent symbols, using a lookup table for short codewords is a great optimization for the common case.</p>

<p><a href="https://github.com/madler/zlib/blob/v1.2.11/doc/algorithm.txt#L58">The method used by zlib</a> is to have multiple levels of lookup tables. If a codeword is too long for the first table, the table entry will point to a secondary table, to be indexed with the remaining bits.</p>

<p>However, there is another very elegant method based on the properties of canonical Huffman codes. This is described in <a href="https://github.com/tpn/pdfs/raw/08eeeb9631252a7a8e61c160518d6f3ae98859b1/On%20the%20Implementation%20of%20Minimum%20Redundancy%20Prefix%20Codes%20(1997).pdf">On the Implementation of Minimum Redundancy Prefix Codes</a> (Moffat and Turpin 1997) and further explained in Charles Bloom's <a href="http://cbloomrants.blogspot.com/2010/08/08-12-10-lost-huffman-paper.html">The Lost Huffman Paper</a>.</p>

<p>Consider the codewords from our canonical code above: 0, 10, 110, 111. We will keep track of the first codeword of each length, and where in the sequence of assigned codewords it is, the "symbol index".</p>

<table border="1" style="text-align: center">
<tbody><tr><th>Codeword Length</th> <th>First Codeword</th> <th>First Symbol Index</th></tr>
<tr><td>1</td> <td>0</td> <td>1 (A)</td></tr>
<tr><td>2</td> <td>10</td> <td>2 (B)</td></tr>
<tr><td>3</td> <td>110</td> <td>3 (C)</td></tr>
</tbody></table>

<p>Because the codewords are assigned sequentially, once we know how many bits of input to consider, the table above lets us find out what symbol index those bits represent. For example, for the 3-bit input 111, we see that this is at offset 1 from the first codeword of that length (110). The first symbol index of that length is 3, and the offset of 1 takes us to symbol index 4. Another table maps the symbol index to the symbol:</p>

<div class="highlight"><pre><span></span><span class="n">sym_idx</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">first_symbol</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">bits</span> <span class="o">-</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">first_code</span><span class="p">[</span><span class="n">len</span><span class="p">]);</span>
<span class="n">sym</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">syms</span><span class="p">[</span><span class="n">sym_idx</span><span class="p">];</span>
</pre></div>


<p>As a small optimization, instead of storing the first symbol index and first codeword separately, we can store the first symbol index minus the first codeword in a table:</p>

<div class="highlight"><pre><span></span><span class="n">sym_idx</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">offset_first_sym_idx</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">+</span> <span class="n">bits</span><span class="p">;</span>
<span class="n">sym</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">syms</span><span class="p">[</span><span class="n">sym_idx</span><span class="p">];</span>
</pre></div>


<p>To determine how many bits of input to consider, we again use the sequential property of the code. In our example code, the valid 1-bit codewords are all strictly less than 1, the 2-bit codewords are strictly less than 11, and the 3-bit codewords are strictly less than 1000 (trivially true for all 3-bit values). In other words, a valid N-bit codeword must be strictly less than the first N-bit codeword plus the number of N-bit codewords.  What is even more exciting is that we can left-shift those limits so that they are all 3 bits wide. Let us call them the <em>sentinel bits</em> for each codeword length:</p>

<table border="1" style="text-align: center">
<tbody><tr><th>Codeword Length</th> <th>Sentinel Bits</th></tr>
<tr><td>1</td> <td>100</td>  </tr>
<tr><td>2</td> <td>110</td>  </tr>
<tr><td>3</td> <td>1000</td> </tr>
</tbody></table>

<p>(The length 3 sentinel has overflowed to 4 bits, but that just means any 3-bit input will do.)</p>

<p>This means we can look at three bits of input and compare against the sentinel bits to figure out how long our codeword is. Once that is done, we shift the input bits as to only consider the right number of them, and then find the symbol index as shown above:</p>

<div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">len</span><span class="o">++</span><span class="p">) {</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&lt;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sentinel_bits</span><span class="p">[</span><span class="n">len</span><span class="p">]) {</span>
                <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>  <span class="cm">/* Get the len most significant bits. */</span>
                <span class="n">sym_idx</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">offset_first_sym_idx</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">+</span> <span class="n">bits</span><span class="p">;
        }
}</span>
</pre></div>


<p>The time complexity of this is linear in the number of codeword bits, but it is space efficient, requires only a load and comparison per step, and since shorter codewords are more frequent it optimizes for the common case.</p>

<p>The full decoder is shown below:</p>

<div class="highlight"><pre><span></span><span class="cp">#define HUFFMAN_LOOKUP_TABLE_BITS 8  </span><span class="cm">/* Seems a good trade-off. */</span><span class="cp"></span>

<span class="k">typedef struct</span> <span class="n">huffman_decoder_t huffman_decoder_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">huffman_decoder_t</span> <span class="p">{</span>
        <span class="cm">/* Lookup table for fast decoding of short codewords. */</span>
        <span class="k">struct</span> <span class="p">{</span>
                <span class="kt">uint16_t</span> <span class="nl">sym</span> <span class="p">:</span> <span class="mi">9</span><span class="p">;</span>  <span class="cm">/* Wide enough to fit the max symbol nbr. */</span>
                <span class="kt">uint16_t</span> <span class="nl">len</span> <span class="p">:</span> <span class="mi">7</span><span class="p">;</span>  <span class="cm">/* 0 means no symbol. */</span>
        <span class="p">}</span> <span class="n">table</span><span class="p">[</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">HUFFMAN_LOOKUP_TABLE_BITS</span><span class="p">];</span>

        <span class="cm">/* "Sentinel bits" value for each codeword length. */</span>
        <span class="kt">uint32_t</span> <span class="n">sentinel_bits</span><span class="p">[</span><span class="n">MAX_HUFFMAN_BITS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

        <span class="cm">/* First symbol index minus first codeword mod 2**16 for each length. */</span>
        <span class="kt">uint16_t</span> <span class="n">offset_first_sym_idx</span><span class="p">[</span><span class="n">MAX_HUFFMAN_BITS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

        <span class="cm">/* Map from symbol index to symbol. */</span>
        <span class="kt">uint16_t</span> <span class="n">syms</span><span class="p">[</span><span class="n">MAX_HUFFMAN_SYMBOLS</span><span class="p">];</span>
<span class="cp">#ifndef NDEBUG</span>
        <span class="kt">size_t</span> <span class="n">num_syms</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* Get the n least significant bits of x. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">lsb</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">x</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)
{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">63</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="p">(((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);
}</span>

<span class="cm">/* Use the decoder d to decode a symbol from the LSB-first zero-padded bits.
 * Returns the decoded symbol number or -1 if no symbol could be decoded.
 * *num_used_bits will be set to the number of bits used to decode the symbol,
 * or zero if no symbol could be decoded. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">huffman_decode</span><span class="p">(</span><span class="k">const</span> <span class="n">huffman_decoder_t</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">bits</span><span class="p">,</span>
                                 <span class="kt">size_t</span> <span class="o">*</span><span class="n">num_used_bits</span><span class="p">)
{</span>
        <span class="kt">uint64_t</span> <span class="n">lookup_bits</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">l</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">sym_idx</span><span class="p">;</span>

        <span class="cm">/* First try the lookup table. */</span>
        <span class="n">lookup_bits</span> <span class="o">=</span> <span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">HUFFMAN_LOOKUP_TABLE_BITS</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">lookup_bits</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">lookup_bits</span><span class="p">].</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">lookup_bits</span><span class="p">].</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">HUFFMAN_LOOKUP_TABLE_BITS</span><span class="p">);</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">lookup_bits</span><span class="p">].</span><span class="n">sym</span> <span class="o">&lt;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">num_syms</span><span class="p">);</span>

                <span class="o">*</span><span class="n">num_used_bits</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">lookup_bits</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">lookup_bits</span><span class="p">].</span><span class="n">sym</span><span class="p">;
        }</span>

        <span class="cm">/* Then do canonical decoding with the bits in MSB-first order. */</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">reverse16</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">MAX_HUFFMAN_BITS</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="n">HUFFMAN_LOOKUP_TABLE_BITS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">MAX_HUFFMAN_BITS</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&lt;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sentinel_bits</span><span class="p">[</span><span class="n">l</span><span class="p">]) {</span>
                        <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="n">MAX_HUFFMAN_BITS</span> <span class="o">-</span> <span class="n">l</span><span class="p">;</span>

                        <span class="n">sym_idx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">offset_first_sym_idx</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">+</span> <span class="n">bits</span><span class="p">);</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">sym_idx</span> <span class="o">&lt;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">num_syms</span><span class="p">);</span>

                        <span class="o">*</span><span class="n">num_used_bits</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
                        <span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">syms</span><span class="p">[</span><span class="n">sym_idx</span><span class="p">];
                }
        }</span>

        <span class="o">*</span><span class="n">num_used_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;
}</span>
</pre></div>


<p>To set up the decoder, we compute the canonical code similarly to <a href="https://www.hanshq.net/zip.html#huffman_encoder_init"><span class="code">huffman_encoder_init</span></a> and fill in the various tables:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Initialize huffman decoder d for a code defined by the n codeword lengths.
   Returns false if the codeword lengths do not correspond to a valid prefix
   code. */</span>
<span class="kt">bool</span> <span class="nf">huffman_decoder_init</span><span class="p">(</span><span class="n">huffman_decoder_t</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">lengths</span><span class="p">,</span>
                          <span class="kt">size_t</span> <span class="n">n</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">count</span><span class="p">[</span><span class="n">MAX_HUFFMAN_BITS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
        <span class="kt">uint16_t</span> <span class="n">code</span><span class="p">[</span><span class="n">MAX_HUFFMAN_BITS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="kt">uint32_t</span> <span class="n">s</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">sym_idx</span><span class="p">[</span><span class="n">MAX_HUFFMAN_BITS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">l</span><span class="p">;</span>

<span class="cp">#ifndef NDEBUG</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">MAX_HUFFMAN_SYMBOLS</span><span class="p">);</span>
        <span class="n">d</span><span class="o">-&gt;</span><span class="n">num_syms</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
<span class="cp">#endif</span>

        <span class="cm">/* Zero-initialize the lookup table. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">d</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;
        }</span>

        <span class="cm">/* Count the number of codewords of each length. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">MAX_HUFFMAN_BITS</span><span class="p">);</span>
                <span class="n">count</span><span class="p">[</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;
        }</span>
        <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* Ignore zero-length codewords. */

        /* Compute sentinel_bits and offset_first_sym_idx for each length. */</span>
        <span class="n">code</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">sym_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">MAX_HUFFMAN_BITS</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">) {</span>
                <span class="cm">/* First canonical codeword of this length. */</span>
                <span class="n">code</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)((</span><span class="n">code</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">count</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">code</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">+</span> <span class="n">count</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">) {</span>
                        <span class="cm">/* The last codeword is longer than l bits. */</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>

                <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="n">code</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">+</span> <span class="n">count</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">MAX_HUFFMAN_BITS</span> <span class="o">-</span> <span class="n">l</span><span class="p">));</span>
                <span class="n">d</span><span class="o">-&gt;</span><span class="n">sentinel_bits</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sentinel_bits</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">code</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="s">"No overflow!"</span><span class="p">);</span>

                <span class="n">sym_idx</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym_idx</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">count</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                <span class="n">d</span><span class="o">-&gt;</span><span class="n">offset_first_sym_idx</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym_idx</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">-</span> <span class="n">code</span><span class="p">[</span><span class="n">l</span><span class="p">];
        }</span>

        <span class="cm">/* Build mapping from index to symbol and populate the lookup table. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="k">continue</span><span class="p">;
                }</span>

                <span class="n">d</span><span class="o">-&gt;</span><span class="n">syms</span><span class="p">[</span><span class="n">sym_idx</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
                <span class="n">sym_idx</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">HUFFMAN_LOOKUP_TABLE_BITS</span><span class="p">) {</span>
                        <span class="n">table_insert</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">code</span><span class="p">[</span><span class="n">l</span><span class="p">]);</span>
                        <span class="n">code</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">++</span><span class="p">;
                }
        }</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">table_insert</span><span class="p">(</span><span class="n">huffman_decoder_t</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sym</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
                         <span class="kt">uint16_t</span> <span class="n">codeword</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">pad_len</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">padding</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">HUFFMAN_LOOKUP_TABLE_BITS</span><span class="p">);</span>

        <span class="n">codeword</span> <span class="o">=</span> <span class="n">reverse16</span><span class="p">(</span><span class="n">codeword</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span> <span class="cm">/* Make it LSB-first. */</span>
        <span class="n">pad_len</span> <span class="o">=</span> <span class="n">HUFFMAN_LOOKUP_TABLE_BITS</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>

        <span class="cm">/* Pad the pad_len upper bits with all bit combinations. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">padding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">padding</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">pad_len</span><span class="p">);</span> <span class="n">padding</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="n">codeword</span> <span class="o">|</span> <span class="p">(</span><span class="n">padding</span> <span class="o">&lt;&lt;</span> <span class="n">len</span><span class="p">));</span>
                <span class="n">d</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">sym</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">sym</span><span class="p">;</span>
                <span class="n">d</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">len</span><span class="p">;</span>

                <span class="n">assert</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">sym</span> <span class="o">==</span> <span class="n">sym</span> <span class="o">&amp;&amp;</span> <span class="s">"Fits in bitfield."</span><span class="p">);</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">len</span> <span class="o">==</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="s">"Fits in bitfield."</span><span class="p">);
        }
}</span>
</pre></div>


<a name="deflate"></a>
<h2>Deflate</h2>

<p>Deflate, introduced with PKZip 2.04c in 1993, is the default compression method in modern Zip files. It is also the compression method used in gzip, PNG, and many other file formats. It uses LZ77 compression and Huffman coding in a combination which will be described and implemented in this section.</p>

<p>Before Deflate, PKZip used compression methods called Shrink, Reduce, and Implode. Although those methods are rarely seen in use today, they were still in use some time after the introduction of Deflate since they required less memory. Those legacy methods are covered in a <a href="https://www.hanshq.net/zip2.html">follow-up article</a>.</p>

<a name="bitstreams"></a>
<h3>Bitstreams</h3>

<p>Deflate stores Huffman codewords in a least-significant-bit-first (LSB-first) bitstream, meaning that the first bit of the stream is stored in the least significant bit of the first byte.</p>

<p>For example, consider this bit stream (read left-to-right): 1-0-0-1-1. When stored LSB-first in a byte, the byte's value becomes 0b00011001 (binary) or 0x19 (hexadecimal). This might seem backwards (in a sense it is), but one advantage is that it makes it easy to get the first N bits from a computer word: just mask off the N lowest bits.</p>

<p>The following routines are from <a href="https://www.hanshq.net/files/hwzip/bitstream.h"><span class="code">bitstream.h</span></a>.</p>

<div class="highlight"><pre><span></span><span class="cm">/* Input bitstream. */</span>
<span class="k">typedef struct</span> <span class="n">istream_t istream_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">istream_t</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>  <span class="cm">/* Source bytes. */</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>  <span class="cm">/* Past-the-end byte of src. */</span>
        <span class="kt">size_t</span> <span class="n">bitpos</span><span class="p">;</span>       <span class="cm">/* Position of the next bit to read. */</span>
        <span class="kt">size_t</span> <span class="n">bitpos_end</span><span class="p">;</span>   <span class="cm">/* Position of past-the-end bit. */</span>
<span class="p">};</span>

<span class="cm">/* Initialize an input stream to present the n bytes from src as an LSB-first
 * bitstream. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">istream_init</span><span class="p">(</span><span class="n">istream_t</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)
{</span>
        <span class="n">is</span><span class="o">-&gt;</span><span class="n">src</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
        <span class="n">is</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">src</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">is</span><span class="o">-&gt;</span><span class="n">bitpos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">is</span><span class="o">-&gt;</span><span class="n">bitpos_end</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;
}</span>
</pre></div>


<p>For our Huffman decoder, we want to look at the next bits in the stream (enough bits for the longest possible codeword), and then advance the stream by the number of bits used by the decoded symbol:</p>

<div class="highlight"><pre><span></span><span class="cp">#define ISTREAM_MIN_BITS (64 - 7)</span>

<span class="cm">/* Get the next bits from the input stream. The number of bits returned is
 * between ISTREAM_MIN_BITS and 64, depending on the position in the stream, or
 * fewer if the end of stream is reached. The upper bits are zero-padded. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">istream_bits</span><span class="p">(</span><span class="k">const</span> <span class="n">istream_t</span> <span class="o">*</span><span class="n">is</span><span class="p">)
{</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">bits</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="n">next</span> <span class="o">= &amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">[</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">bitpos</span> <span class="o">/</span> <span class="mi">8</span><span class="p">];</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">next</span> <span class="o">&lt;=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="s">"Cannot read past end of stream."</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">next</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">) {</span>
                <span class="cm">/* Common case: read 8 bytes in one go. */</span>
                <span class="n">bits</span> <span class="o">=</span> <span class="n">read64le</span><span class="p">(</span><span class="n">next</span><span class="p">);
        }</span> <span class="k">else</span> <span class="p">{</span>
                <span class="cm">/* Read the available bytes and zero-pad. */</span>
                <span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">next</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                        <span class="n">bits</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);
                }
        }</span>

        <span class="k">return</span> <span class="n">bits</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">bitpos</span> <span class="o">%</span> <span class="mi">8</span><span class="p">);
}</span>

<span class="cm">/* Advance n bits in the bitstream if possible. Returns false if that many bits
 * are not available in the stream. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">istream_advance</span><span class="p">(</span><span class="n">istream_t</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">) {</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">bitpos</span> <span class="o">&lt;=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">bitpos_end</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">bitpos_end</span> <span class="o">-</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">bitpos</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="n">is</span><span class="o">-&gt;</span><span class="n">bitpos</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>



<p>The intention is that in the common case, <span class="code">istream_bits</span> can execute as a single load instruction and some arithmetic on 64-bit machines, assuming the members of the <span class="code">istream_t</span> struct are available in registers. <span class="code">read64le</span> is implemented in <a href="https://www.hanshq.net/files/hwzip/bits.h"><span class="code">bits.h</span></a> (modern compilers translate it to a single 64-bit load on little-endian):</p>

<div class="highlight"><pre><span></span><span class="cm">/* Read a 64-bit value from p in little-endian byte order. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">read64le</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">p</span><span class="p">)
{</span>
        <span class="cm">/* The one true way, see
         * https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html */</span>
        <span class="k">return</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="o">|</span>
               <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>  <span class="o">|</span>
               <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
               <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
               <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span>
               <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">40</span><span class="p">)</span> <span class="o">|</span>
               <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">48</span><span class="p">)</span> <span class="o">|</span>
               <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">56</span><span class="p">);
}</span>
</pre></div>


<p>We also need a function to advance the bitstream to the next byte boundary:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Round x up to the next multiple of m, which must be a power of 2. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">round_up</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">x</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">m</span><span class="p">)
{</span>
        <span class="n">assert</span><span class="p">((</span><span class="n">m</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">"m must be a power of two"</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="o">-</span><span class="n">m</span><span class="p">);</span> <span class="cm">/* Hacker's Delight (2nd), 3-1. */</span>
<span class="p">}</span>

<span class="cm">/* Align the input stream to the next 8-bit boundary and return a pointer to
 * that byte, which may be the past-the-end-of-stream byte. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="nf">istream_byte_align</span><span class="p">(</span><span class="n">istream_t</span> <span class="o">*</span><span class="n">is</span><span class="p">)
{</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">byte</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">bitpos</span> <span class="o">&lt;=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">bitpos_end</span> <span class="o">&amp;&amp;</span> <span class="s">"Not past end of stream."</span><span class="p">);</span>

        <span class="n">is</span><span class="o">-&gt;</span><span class="n">bitpos</span> <span class="o">=</span> <span class="n">round_up</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">bitpos</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
        <span class="n">byte</span> <span class="o">= &amp;</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">[</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">bitpos</span> <span class="o">/</span> <span class="mi">8</span><span class="p">];</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">byte</span> <span class="o">&lt;=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">byte</span><span class="p">;
}</span>
</pre></div>


<p>For the output bitstream, we write bits using a read-modify-write sequence. In the fast case, a bit write can be done by a 64-bit read, some bit operations, and a 64-bit write.</p>

<div class="highlight"><pre><span></span><span class="cm">/* Output bitstream. */</span>
<span class="k">typedef struct</span> <span class="n">ostream_t ostream_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ostream_t</span> <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">bitpos</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">bitpos_end</span><span class="p">;
};</span>

<span class="cm">/* Initialize an output stream to write LSB-first bits into dst[0..n-1]. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ostream_init</span><span class="p">(</span><span class="n">ostream_t</span> <span class="o">*</span><span class="n">os</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)
{</span>
        <span class="n">os</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
        <span class="n">os</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">dst</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">os</span><span class="o">-&gt;</span><span class="n">bitpos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">os</span><span class="o">-&gt;</span><span class="n">bitpos_end</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;
}</span>

<span class="cm">/* Get the current bit position in the stream. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">ostream_bit_pos</span><span class="p">(</span><span class="k">const</span> <span class="n">ostream_t</span> <span class="o">*</span><span class="n">os</span><span class="p">)
{</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">-&gt;</span><span class="n">bitpos</span><span class="p">;
}</span>

<span class="cm">/* Return the number of bytes written to the output buffer. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">ostream_bytes_written</span><span class="p">(</span><span class="n">ostream_t</span> <span class="o">*</span><span class="n">os</span><span class="p">)
{</span>
        <span class="k">return</span> <span class="n">round_up</span><span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">bitpos</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;
}</span>

<span class="cm">/* Write n bits to the output stream. Returns false if there is not enough room
 * at the destination. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">ostream_write</span><span class="p">(</span><span class="n">ostream_t</span> <span class="o">*</span><span class="n">os</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">bits</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)
{</span>
        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">x</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">shift</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">57</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">bits</span> <span class="o">&lt;=</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="s">"Must fit in n bits."</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">bitpos_end</span> <span class="o">-</span> <span class="n">os</span><span class="o">-&gt;</span><span class="n">bitpos</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">) {</span>
                <span class="cm">/* Not enough room. */</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="n">p</span> <span class="o">= &amp;</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">[</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">bitpos</span> <span class="o">/</span> <span class="mi">8</span><span class="p">];</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">os</span><span class="o">-&gt;</span><span class="n">bitpos</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">) {</span>
                <span class="cm">/* Common case: read and write 8 bytes in one go. */</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">read64le</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">lsb</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>
                <span class="n">x</span> <span class="o">|=</span> <span class="n">bits</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
                <span class="n">write64le</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);
        }</span> <span class="k">else</span> <span class="p">{</span>
                <span class="cm">/* Slow case: read/write as many bytes as are available. */</span>
                <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">p</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                        <span class="n">x</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);
                }</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">lsb</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>
                <span class="n">x</span> <span class="o">|=</span> <span class="n">bits</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">p</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));
                }
        }</span>

        <span class="n">os</span><span class="o">-&gt;</span><span class="n">bitpos</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>

<span class="cm">/* Write a 64-bit value x to dst in little-endian byte order. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write64le</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">x</span><span class="p">)
{</span>
        <span class="n">dst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">dst</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
        <span class="n">dst</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
        <span class="n">dst</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
        <span class="n">dst</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
        <span class="n">dst</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">);</span>
        <span class="n">dst</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">48</span><span class="p">);</span>
        <span class="n">dst</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">56</span><span class="p">);
}</span>
</pre></div>


<p>We also want an efficient way of writing bytes to the stream. One could of course perform repeated 8-bit writes, but using <span class="code">memcpy</span> is much faster:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Align the bitstream to the next byte boundary, then write the n bytes from
   src to it. Returns false if there is not enough room in the stream. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">ostream_write_bytes_aligned</span><span class="p">(</span><span class="n">ostream_t</span> <span class="o">*</span><span class="n">os</span><span class="p">,</span>
                                               <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
                                               <span class="kt">size_t</span> <span class="n">n</span><span class="p">)
{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">bitpos_end</span> <span class="o">-</span> <span class="n">round_up</span><span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">bitpos</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">8</span><span class="p">) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="n">os</span><span class="o">-&gt;</span><span class="n">bitpos</span> <span class="o">=</span> <span class="n">round_up</span><span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">bitpos</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">[</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">bitpos</span> <span class="o">/</span> <span class="mi">8</span><span class="p">],</span> <span class="n">src</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">os</span><span class="o">-&gt;</span><span class="n">bitpos</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<a name="inflation"></a>
<h3>Decompression (Inflation)</h3>

<p>Since the compression algorithm is called <i>Deflate</i>—to let the air out of something—the decompression process is sometimes referred to as <i>Inflation</i>. Studying this process first will give us an understanding of how the format works.
The code is available in the first part of
<a href="https://www.hanshq.net/files/hwzip/deflate.h"><span class="code">deflate.h</span></a> and
<a href="https://www.hanshq.net/files/hwzip/deflate.c"><span class="code">deflate.c</span></a>,
<a href="https://www.hanshq.net/files/hwzip/bits.h"><span class="code">bits.h</span></a>,
<a href="https://www.hanshq.net/files/hwzip/tables.h"><span class="code">tables.h</span></a>, and
<a href="https://www.hanshq.net/files/hwzip/tables.c"><span class="code">tables.c</span></a>
(generated by <a href="https://www.hanshq.net/files/hwzip/generate_tables.c"><span class="code">generate_tables.c</span></a>).
</p>

<p>Deflate-compressed data is stored as a series of <i>blocks</i>. Each block starts with a 3-bit header where the first (least significant) bit is set if this is the final block of the series, and the other two bits indicate the block type.</p>

<div class="latex"><p style="margin-left: 2em"><img src="./zip_files/tex_4858bc99.svg" alt="LaTeX"></p></div>

<p>There are three block types: uncompressed (0), compressed with fixed Huffman codes (1) and compressed with "dynamic" Huffman codes (2).</p>

<p>The following code drives the decompression, relying on helper functions for the different block types which will be implemented further below.</p>

<div class="highlight"><pre><span></span><span class="k">typedef enum</span> <span class="p">{</span>
        <span class="n">HWINF_OK</span><span class="p">,</span>   <span class="cm">/* Inflation was successful. */</span>
        <span class="n">HWINF_FULL</span><span class="p">,</span> <span class="cm">/* Not enough room in the output buffer. */</span>
        <span class="n">HWINF_ERR</span>   <span class="cm">/* Error in the input data. */</span>
<span class="p">}</span> <span class="n">inf_stat_t</span><span class="p">;</span>

<span class="cm">/* Decompress (inflate) the Deflate stream in src. The number of input bytes
   used, at most src_len, is stored in *src_used on success. Output is written
   to dst. The number of bytes written, at most dst_cap, is stored in *dst_used
   on success. src[0..src_len-1] and dst[0..dst_cap-1] must not overlap. */</span>
<span class="n">inf_stat_t</span> <span class="nf">hwinflate</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">src_len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">src_used</span><span class="p">,</span>
                     <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">dst_used</span><span class="p">)
{</span>
        <span class="n">istream_t is</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">dst_pos</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">bits</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">bfinal</span><span class="p">;</span>
        <span class="n">inf_stat_t s</span><span class="p">;</span>

        <span class="n">istream_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">src_len</span><span class="p">);</span>
        <span class="n">dst_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">do</span> <span class="p">{</span>
                <span class="cm">/* Read the 3-bit block header. */</span>
                <span class="n">bits</span> <span class="o">=</span> <span class="n">istream_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="mi">3</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
                }</span>
                <span class="n">bfinal</span> <span class="o">=</span> <span class="n">bits</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>

                <span class="k">switch</span> <span class="p">(</span><span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">2</span><span class="p">)) {</span>
                <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="cm">/* 00: No compression. */</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="n">inf_noncomp_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst_pos</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="cm">/* 01: Compressed with fixed Huffman codes. */</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="n">inf_fixed_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst_pos</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="cm">/* 10: Compressed with "dynamic" Huffman codes. */</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="n">inf_dyn_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst_pos</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="k">default</span><span class="o">:</span> <span class="cm">/* Invalid block type. */</span>
                        <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
                }</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">HWINF_OK</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="n">s</span><span class="p">;
                }
        }</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">bfinal</span><span class="p">);</span>

        <span class="o">*</span><span class="n">src_used</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">istream_byte_align</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">)</span> <span class="o">-</span> <span class="n">src</span><span class="p">);</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">dst_pos</span> <span class="o">&lt;=</span> <span class="n">dst_cap</span><span class="p">);</span>
        <span class="o">*</span><span class="n">dst_used</span> <span class="o">=</span> <span class="n">dst_pos</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">HWINF_OK</span><span class="p">;
}</span>
</pre></div>


<a name="noncomp"></a>
<h4>Non-Compressed Deflate Blocks</h4>

<p>The simplest block type is the non-compressed or "stored" block. It begins at the next 8-bit boundary of the bitstream, with a 16-bit word (<span class="code">len</span>) indicating the length of the block, followed by another 16-bit word (<span class="code">nlen</span>) which is the ones' complement (all bits inverted) of <span class="code">len</span>. The idea is presumably that <span class="code">nlen</span> acts as a simple checksum of <span class="code">len</span>: if the file is corrupted, it is likely that the values are no longer each others' complements, and the program can detect the error.</p>

<div class="latex"><p style="margin-left: 2em"><img src="./zip_files/tex_a74faf22.svg" alt="LaTeX"></p></div>


<p>After <span class="code">len</span> and <span class="code">nlen</span> follows the non-compressed data. Because the block length is a 16-bit value, it is limited to 65,535 bytes.</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">inf_stat_t</span> <span class="nf">inf_noncomp_block</span><span class="p">(</span><span class="n">istream_t</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
                                    <span class="kt">size_t</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">dst_pos</span><span class="p">)
{</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">nlen</span><span class="p">;</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">istream_byte_align</span><span class="p">(</span><span class="n">is</span><span class="p">);</span>

        <span class="cm">/* Read len and nlen (2 x 16 bits). */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="mi">32</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;</span> <span class="cm">/* Not enough input. */</span>
        <span class="p">}</span>
        <span class="n">len</span>  <span class="o">=</span> <span class="n">read16le</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">nlen</span> <span class="o">=</span> <span class="n">read16le</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">p</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">nlen</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="o">~</span><span class="n">len</span><span class="p">) {</span>
                <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">len</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;</span> <span class="cm">/* Not enough input. */</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dst_cap</span> <span class="o">- *</span><span class="n">dst_pos</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">) {</span>
                <span class="k">return</span> <span class="n">HWINF_FULL</span><span class="p">;</span> <span class="cm">/* Not enough room to output. */</span>
        <span class="p">}</span>

        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="o">*</span><span class="n">dst_pos</span><span class="p">],</span> <span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="o">*</span><span class="n">dst_pos</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">HWINF_OK</span><span class="p">;
}</span>
</pre></div>


<a name="fixed"></a>
<h4>Fixed Huffman Code Deflate Blocks</h4>

<p>Compressed Deflate blocks use Huffman codes to represent a sequence of LZ77 literals and back references terminated by an end-of-block marker. One Huffman code, the <em>litlen code</em>, is used for literals, back reference lengths, and the end-of-block marker. A second code, the <em>dist code</em>, is used for back reference distances.</p>

<div class="latex"><p style="margin-left: 2em"><img src="./zip_files/tex_b3cfba44.svg" alt="LaTeX"></p></div>



<p>The litlen code encodes values between 0 and 285. Values 0 through 255 represent literal bytes, 256 is the end-of-block marker, and values 257 through 285 represent back reference lengths.</p>

<p>Back references are between 3 and 258 bytes long. The litlen value determines a base length to which zero or more <em>extra bits</em> from the stream are added to get the full length according to the table below. For example, a litlen value of 269 indicates a base length of 19 and two extra bits. Adding the next two bits from the stream yields a final length between 19 and 22.</p>


<table border="1">
<tbody><tr><th>Litlen</th> <th>Extra Bits</th> <th>Length(s)</th></tr>
<tr><td>257</td> <td>0</td> <td>3</td></tr>
<tr><td>258</td> <td>0</td> <td>4</td></tr>
<tr><td>259</td> <td>0</td> <td>5</td></tr>
<tr><td>260</td> <td>0</td> <td>6</td></tr>
<tr><td>261</td> <td>0</td> <td>7</td></tr>
<tr><td>262</td> <td>0</td> <td>8</td></tr>
<tr><td>263</td> <td>0</td> <td>9</td></tr>
<tr><td>264</td> <td>0</td> <td>10</td></tr>
<tr><td>265</td> <td>1</td> <td>11–12</td></tr>
<tr><td>266</td> <td>1</td> <td>13–14</td></tr>
<tr><td>267</td> <td>1</td> <td>15–16</td></tr>
<tr><td>268</td> <td>1</td> <td>17–18</td></tr>
<tr><td>269</td> <td>2</td> <td>19–22</td></tr>
<tr><td>270</td> <td>2</td> <td>23–26</td></tr>
<tr><td>271</td> <td>2</td> <td>27–30</td></tr>
<tr><td>272</td> <td>2</td> <td>31–34</td></tr>
<tr><td>273</td> <td>3</td> <td>35–42</td></tr>
<tr><td>274</td> <td>3</td> <td>43–50</td></tr>
<tr><td>275</td> <td>3</td> <td>51–58</td></tr>
<tr><td>276</td> <td>3</td> <td>59–66</td></tr>
<tr><td>277</td> <td>4</td> <td>67–82</td></tr>
<tr><td>278</td> <td>4</td> <td>83–98</td></tr>
<tr><td>279</td> <td>4</td> <td>99–114</td></tr>
<tr><td>280</td> <td>4</td> <td>115–130</td></tr>
<tr><td>281</td> <td>5</td> <td>131–162</td></tr>
<tr><td>282</td> <td>5</td> <td>163–194</td></tr>
<tr><td>283</td> <td>5</td> <td>195–226</td></tr>
<tr><td>284</td> <td>5</td> <td>227–257</td></tr>
<tr><td>285</td> <td>0</td> <td>258</td></tr>
</tbody></table>

<p>(Note that litlen value 284 plus five extra bits could actually represents lengths 227–258, but the specification indicates that 258, the maximum back reference length, should be represented using a separate litlen value. This is presumably to allow for a shorter encoding in cases where the maximum length is common.)</p>

<p>The decompressor uses a table that maps from litlen value (minus 257) to base length and extra bits:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Table of litlen symbol values minus 257 with corresponding base length
   and number of extra bits. */</span>
<span class="k">struct</span> <span class="n">litlen_tbl_t</span> <span class="p">{</span>
        <span class="kt">uint16_t</span> <span class="nl">base_len</span> <span class="p">:</span> <span class="mi">9</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="nl">ebits</span> <span class="p">:</span> <span class="mi">7</span><span class="p">;
};</span>
<span class="k">const struct</span> <span class="n">litlen_tbl_t litlen_tbl</span><span class="p">[</span><span class="mi">29</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cm">/* 257 */</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
<span class="cm">/* 258 */</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},

...</span>

<span class="cm">/* 284 */</span> <span class="p">{</span> <span class="mi">227</span><span class="p">,</span> <span class="mi">5</span> <span class="p">},</span>
<span class="cm">/* 285 */</span> <span class="p">{</span> <span class="mi">258</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}
};</span>
</pre></div>


<p>The fixed litlen Huffman code is a canonical code using the following codeword lengths (286–287 are not valid litlen values, but they participate in the code construction):</p>

<table border="1">
<tbody><tr><th>Litlen values</th> <th>Codeword length</th></tr>
<tr><td>0–143</td>   <td>8</td></tr>
<tr><td>144–255</td> <td>9</td></tr>
<tr><td>256–279</td> <td>7</td></tr>
<tr><td>280–287</td> <td>8</td></tr>
</tbody></table>

<p>The decompressor keeps those lengths in a table suitable for passing to <span class="code">huffman_decoder_init</span>:</p>

<div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">fixed_litlen_lengths</span><span class="p">[</span><span class="mi">288</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cm">/*   0 */</span> <span class="mi">8</span><span class="p">,</span>
<span class="cm">/*   1 */</span> <span class="mi">8</span><span class="p">,

...</span>

<span class="cm">/* 287 */</span> <span class="mi">8</span><span class="p">,
};</span>
</pre></div>


<p>Back reference distances, ranging from 1 to 32,768, are encoded using a scheme similar to the one for lengths. The dist Huffman code encodes values between 0 and 29, each corresponding to a base length to which a number of extra bits are added to get the final distance:</p>

<table border="1">
<tbody><tr><th>Dist</th> <th>Extra Bits</th> <th>Distance(s)</th></tr>
<tr><td>0</td>  <td>0</td>  <td>1</td></tr>
<tr><td>1</td>  <td>0</td>  <td>2</td></tr>
<tr><td>2</td>  <td>0</td>  <td>3</td></tr>
<tr><td>3</td>  <td>0</td>  <td>4</td></tr>
<tr><td>4</td>  <td>1</td>  <td>5–6</td></tr>
<tr><td>5</td>  <td>1</td>  <td>7–8</td></tr>
<tr><td>6</td>  <td>2</td>  <td>9–12</td></tr>
<tr><td>7</td>  <td>2</td>  <td>13–16</td></tr>
<tr><td>8</td>  <td>3</td>  <td>17–24</td></tr>
<tr><td>9</td>  <td>3</td>  <td>25–32</td></tr>
<tr><td>10</td> <td>4</td>  <td>33–48</td></tr>
<tr><td>11</td> <td>4</td>  <td>49–64</td></tr>
<tr><td>12</td> <td>5</td>  <td>65–96</td></tr>
<tr><td>13</td> <td>5</td>  <td>97–128</td></tr>
<tr><td>14</td> <td>6</td>  <td>129–192</td></tr>
<tr><td>15</td> <td>6</td>  <td>193–256</td></tr>
<tr><td>16</td> <td>7</td>  <td>257–384</td></tr>
<tr><td>17</td> <td>7</td>  <td>385–512</td></tr>
<tr><td>18</td> <td>8</td>  <td>513–768</td></tr>
<tr><td>19</td> <td>8</td>  <td>769–1024</td></tr>
<tr><td>20</td> <td>9</td>  <td>1025–1536</td></tr>
<tr><td>21</td> <td>9</td>  <td>1537–2048</td></tr>
<tr><td>22</td> <td>10</td> <td>2049–3072</td></tr>
<tr><td>23</td> <td>10</td> <td>3073–4096</td></tr>
<tr><td>24</td> <td>11</td> <td>4097–6144</td></tr>
<tr><td>25</td> <td>11</td> <td>6145–8192</td></tr>
<tr><td>26</td> <td>12</td> <td>8193–12288</td></tr>
<tr><td>27</td> <td>12</td> <td>12289–16384</td></tr>
<tr><td>28</td> <td>13</td> <td>16385–24576</td></tr>
<tr><td>29</td> <td>13</td> <td>24577–32768</td></tr>
</tbody></table>

<p>The fixed dist code is a canonical Huffman code where all codewords are 5 bits long. Although trivial, the decompressor keeps it in a table so that it can be used with <span class="code">huffman_decoder_init</span> (dist values 30–31 are not valid, but are specified as participating in the Huffman code construction, though they do not have any effect):</p>

<div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">fixed_dist_lengths</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cm">/*  0 */</span> <span class="mi">5</span><span class="p">,</span>
<span class="cm">/*  1 */</span> <span class="mi">5</span><span class="p">,

...</span>

<span class="cm">/* 31 */</span> <span class="mi">5</span><span class="p">,
};</span>
</pre></div>


<p>The code for decompressing, or inflating, a fixed Huffman code deflate block is shown below.</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">inf_stat_t</span> <span class="nf">inf_fixed_block</span><span class="p">(</span><span class="n">istream_t</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
                                  <span class="kt">size_t</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">dst_pos</span><span class="p">)
{</span>
        <span class="n">huffman_decoder_t litlen_dec</span><span class="p">,</span> <span class="n">dist_dec</span><span class="p">;</span>

        <span class="n">huffman_decoder_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">litlen_dec</span><span class="p">,</span> <span class="n">fixed_litlen_lengths</span><span class="p">,</span>
                             <span class="k">sizeof</span><span class="p">(</span><span class="n">fixed_litlen_lengths</span><span class="p">)</span> <span class="o">/</span>
                             <span class="k">sizeof</span><span class="p">(</span><span class="n">fixed_litlen_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
        <span class="n">huffman_decoder_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dist_dec</span><span class="p">,</span> <span class="n">fixed_dist_lengths</span><span class="p">,</span>
                             <span class="k">sizeof</span><span class="p">(</span><span class="n">fixed_dist_lengths</span><span class="p">)</span> <span class="o">/</span>
                             <span class="k">sizeof</span><span class="p">(</span><span class="n">fixed_dist_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>

        <span class="k">return</span> <span class="n">inf_block</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="n">dst_pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">litlen_dec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dist_dec</span><span class="p">);
}</span>

<span class="cp">#define LITLEN_EOB 256
#define LITLEN_MAX 285
#define LITLEN_TBL_OFFSET 257
#define MIN_LEN 3
#define MAX_LEN 258

#define DISTSYM_MAX 29
#define MIN_DISTANCE 1
#define MAX_DISTANCE 32768</span>

<span class="k">static</span> <span class="n">inf_stat_t</span> <span class="nf">inf_block</span><span class="p">(</span><span class="n">istream_t</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dst_cap</span><span class="p">,</span>
                            <span class="kt">size_t</span> <span class="o">*</span><span class="n">dst_pos</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">huffman_decoder_t</span> <span class="o">*</span><span class="n">litlen_dec</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">huffman_decoder_t</span> <span class="o">*</span><span class="n">dist_dec</span><span class="p">)
{</span>
        <span class="kt">uint64_t</span> <span class="n">bits</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">used</span><span class="p">,</span> <span class="n">used_tot</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">litlen</span><span class="p">,</span> <span class="n">distsym</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">ebits</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">) {</span>
                <span class="cm">/* Read a litlen symbol. */</span>
                <span class="n">bits</span> <span class="o">=</span> <span class="n">istream_bits</span><span class="p">(</span><span class="n">is</span><span class="p">);</span>
                <span class="n">litlen</span> <span class="o">=</span> <span class="n">huffman_decode</span><span class="p">(</span><span class="n">litlen_dec</span><span class="p">, (</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">used</span><span class="p">);</span>
                <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="n">used</span><span class="p">;</span>
                <span class="n">used_tot</span> <span class="o">=</span> <span class="n">used</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">litlen</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">litlen</span> <span class="o">&gt;</span> <span class="n">LITLEN_MAX</span><span class="p">) {</span>
                        <span class="cm">/* Failed to decode, or invalid symbol. */</span>
                        <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
                }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">litlen</span> <span class="o">&lt;=</span> <span class="n">UINT8_MAX</span><span class="p">) {</span>
                        <span class="cm">/* Literal. */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">used_tot</span><span class="p">)) {</span>
                                <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
                        }</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dst_pos</span> <span class="o">==</span> <span class="n">dst_cap</span><span class="p">) {</span>
                                <span class="k">return</span> <span class="n">HWINF_FULL</span><span class="p">;
                        }</span>
                        <span class="n">lz77_output_lit</span><span class="p">(</span><span class="n">dst</span><span class="p">, (</span><span class="o">*</span><span class="n">dst_pos</span><span class="p">)</span><span class="o">++</span><span class="p">, (</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">litlen</span><span class="p">);</span>
                        <span class="k">continue</span><span class="p">;
                }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">litlen</span> <span class="o">==</span> <span class="n">LITLEN_EOB</span><span class="p">) {</span>
                        <span class="cm">/* End of block. */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">used_tot</span><span class="p">)) {</span>
                                <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
                        }</span>
                        <span class="k">return</span> <span class="n">HWINF_OK</span><span class="p">;
                }</span>

                <span class="cm">/* It is a back reference. Figure out the length. */</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">litlen</span> <span class="o">&gt;=</span> <span class="n">LITLEN_TBL_OFFSET</span> <span class="o">&amp;&amp;</span> <span class="n">litlen</span> <span class="o">&lt;=</span> <span class="n">LITLEN_MAX</span><span class="p">);</span>
                <span class="n">len</span>   <span class="o">=</span> <span class="n">litlen_tbl</span><span class="p">[</span><span class="n">litlen</span> <span class="o">-</span> <span class="n">LITLEN_TBL_OFFSET</span><span class="p">].</span><span class="n">base_len</span><span class="p">;</span>
                <span class="n">ebits</span> <span class="o">=</span> <span class="n">litlen_tbl</span><span class="p">[</span><span class="n">litlen</span> <span class="o">-</span> <span class="n">LITLEN_TBL_OFFSET</span><span class="p">].</span><span class="n">ebits</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ebits</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="n">len</span> <span class="o">+=</span> <span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">ebits</span><span class="p">);</span>
                        <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="n">ebits</span><span class="p">;</span>
                        <span class="n">used_tot</span> <span class="o">+=</span> <span class="n">ebits</span><span class="p">;
                }</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">MIN_LEN</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">MAX_LEN</span><span class="p">);</span>

                <span class="cm">/* Get the distance. */</span>
                <span class="n">distsym</span> <span class="o">=</span> <span class="n">huffman_decode</span><span class="p">(</span><span class="n">dist_dec</span><span class="p">, (</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">used</span><span class="p">);</span>
                <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="n">used</span><span class="p">;</span>
                <span class="n">used_tot</span> <span class="o">+=</span> <span class="n">used</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">distsym</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">distsym</span> <span class="o">&gt;</span> <span class="n">DISTSYM_MAX</span><span class="p">) {</span>
                        <span class="cm">/* Failed to decode, or invalid symbol. */</span>
                        <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
                }</span>
                <span class="n">dist</span>  <span class="o">=</span> <span class="n">dist_tbl</span><span class="p">[</span><span class="n">distsym</span><span class="p">].</span><span class="n">base_dist</span><span class="p">;</span>
                <span class="n">ebits</span> <span class="o">=</span> <span class="n">dist_tbl</span><span class="p">[</span><span class="n">distsym</span><span class="p">].</span><span class="n">ebits</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ebits</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="n">dist</span> <span class="o">+=</span> <span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">ebits</span><span class="p">);</span>
                        <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="n">ebits</span><span class="p">;</span>
                        <span class="n">used_tot</span> <span class="o">+=</span> <span class="n">ebits</span><span class="p">;
                }</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">MIN_DISTANCE</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">MAX_DISTANCE</span><span class="p">);</span>

                <span class="n">assert</span><span class="p">(</span><span class="n">used_tot</span> <span class="o">&lt;=</span> <span class="n">ISTREAM_MIN_BITS</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">used_tot</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
                }</span>

                <span class="cm">/* Bounds check and output the backref. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&gt; *</span><span class="n">dst_pos</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
                }</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">round_up</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">dst_cap</span> <span class="o">- *</span><span class="n">dst_pos</span><span class="p">) {</span>
                        <span class="n">lz77_output_backref64</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="o">*</span><span class="n">dst_pos</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">len</span><span class="p">);
                }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">dst_cap</span> <span class="o">- *</span><span class="n">dst_pos</span><span class="p">) {</span>
                        <span class="n">lz77_output_backref</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="o">*</span><span class="n">dst_pos</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">len</span><span class="p">);
                }</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="n">HWINF_FULL</span><span class="p">;
                }
                (</span><span class="o">*</span><span class="n">dst_pos</span><span class="p">)</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;
        }
}</span>
</pre></div>


<p>Note that as an optimization when there is enough room in the output buffer, we output back references using the routine below which copies 64 bits at a time. It is "sloppy" in the sense that it often copies a few extra bytes (to the next multiple of 8), but it is much faster than <span class="code">lz77_output_backref</span> since it needs fewer loop iterations and memory accesses. In fact, short back references will now all be handled by a single iteration, which is great for branch prediction.</p>

<a name="lz77_output_backref64"></a>
<div class="highlight"><pre><span></span><span class="cm">/* Output the (dist,len) backref at dst_pos in dst using 64-bit wide writes.
   There must be enough room for len bytes rounded to the next multiple of 8. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lz77_output_backref64</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dst_pos</span><span class="p">,</span>
                                         <span class="kt">size_t</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">tmp</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">dst_pos</span> <span class="o">&amp;&amp;</span> <span class="s">"cannot reference before beginning of dst"</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">) {</span>
                <span class="cm">/* Self-overlapping backref; fall back to byte-by-byte copy. */</span>
                <span class="n">lz77_output_backref</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">dst_pos</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;
        }</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">do</span> <span class="p">{</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span> <span class="o">-</span> <span class="n">dist</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span> <span class="mi">8</span><span class="p">);</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;
        }</span> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">);
}</span>
</pre></div>


<a name="dyn"></a>
<h4>Dynamic Huffman Code Deflate Blocks</h4>

<p>Deflate blocks using dynamic Huffman codes work similarly to the blocks described above, but instead of using pre-determined Huffman codes for the litlen and dist codes, they use codes that are stored in the Deflate stream itself, at the start of the block. The name is perhaps unfortunate, since dynamic Huffman codes can also refer to codes that change during the coding process, sometimes called <a href="https://en.wikipedia.org/wiki/Adaptive_Huffman_coding">adaptive Huffman coding</a>. The codes described here have nothing to do with that; they are only dynamic in the sense that different blocks can use different codes.</p>

<p>The encoding of the dynamic litlen and dist codes is the most intricate part of the Deflate format, but once the codes have been retrieved, decompression proceeds in the same way as for blocks in the previous section, using <span class="code">inf_block</span>:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">inf_stat_t</span> <span class="nf">inf_dyn_block</span><span class="p">(</span><span class="n">istream_t</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
                                <span class="kt">size_t</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">dst_pos</span><span class="p">)
{</span>
        <span class="n">inf_stat_t s</span><span class="p">;</span>
        <span class="n">huffman_decoder_t litlen_dec</span><span class="p">,</span> <span class="n">dist_dec</span><span class="p">;</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">init_dyn_decoders</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">litlen_dec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dist_dec</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">HWINF_OK</span><span class="p">) {</span>
                <span class="k">return</span> <span class="n">s</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="n">inf_block</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="n">dst_pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">litlen_dec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dist_dec</span><span class="p">);
}</span>
</pre></div>


<p>The litlen and dist codes for a dynamic Deflate block are stored as a series of codeword lengths. Those codeword lengths are themselves encoded using a third Huffman code, which we will call the <em>codelen code</em>. Finally, that code is itself defined by codeword lengths (<span class="code">codelen_lens</span>) stored in the block. (Did I mention it was intricate?)</p>

<div class="latex"><p style="margin-left: 2em"><img src="./zip_files/tex_336f2ad6.svg" alt="LaTeX"></p></div>

<p>At the beginning of the dynamic block are 14 bits that define the number of litlen, dist, and codelen codeword lengths that should be read from the block:</p>

<div class="highlight"><pre><span></span><span class="cp">#define MIN_CODELEN_LENS 4
#define MAX_CODELEN_LENS 19

#define MIN_LITLEN_LENS 257
#define MAX_LITLEN_LENS 288

#define MIN_DIST_LENS 1
#define MAX_DIST_LENS 32

#define CODELEN_MAX_LIT 15

#define CODELEN_COPY 16
#define CODELEN_COPY_MIN 3
#define CODELEN_COPY_MAX 6

#define CODELEN_ZEROS 17
#define CODELEN_ZEROS_MIN 3
#define CODELEN_ZEROS_MAX 10

#define CODELEN_ZEROS2 18
#define CODELEN_ZEROS2_MIN 11
#define CODELEN_ZEROS2_MAX 138</span>

<span class="cm">/* RFC 1951, 3.2.7 */</span>
<span class="k">static const</span> <span class="kt">int</span> <span class="n">codelen_lengths_order</span><span class="p">[</span><span class="n">MAX_CODELEN_LENS</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15</span> <span class="p">};</span>

<span class="k">static</span> <span class="n">inf_stat_t</span> <span class="nf">init_dyn_decoders</span><span class="p">(</span><span class="n">istream_t</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span>
                                    <span class="n">huffman_decoder_t</span> <span class="o">*</span><span class="n">litlen_dec</span><span class="p">,</span>
                                    <span class="n">huffman_decoder_t</span> <span class="o">*</span><span class="n">dist_dec</span><span class="p">)
{</span>
        <span class="kt">uint64_t</span> <span class="n">bits</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">num_litlen_lens</span><span class="p">,</span> <span class="n">num_dist_lens</span><span class="p">,</span> <span class="n">num_codelen_lens</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">codelen_lengths</span><span class="p">[</span><span class="n">MAX_CODELEN_LENS</span><span class="p">];</span>
        <span class="kt">uint8_t</span> <span class="n">code_lengths</span><span class="p">[</span><span class="n">MAX_LITLEN_LENS</span> <span class="o">+</span> <span class="n">MAX_DIST_LENS</span><span class="p">];</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">used</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">sym</span><span class="p">;</span>
        <span class="n">huffman_decoder_t codelen_dec</span><span class="p">;</span>

        <span class="n">bits</span> <span class="o">=</span> <span class="n">istream_bits</span><span class="p">(</span><span class="n">is</span><span class="p">);</span>

        <span class="cm">/* Number of litlen codeword lengths (5 bits + 257). */</span>
        <span class="n">num_litlen_lens</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">MIN_LITLEN_LENS</span><span class="p">);</span>
        <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="mi">5</span><span class="p">;</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">num_litlen_lens</span> <span class="o">&lt;=</span> <span class="n">MAX_LITLEN_LENS</span><span class="p">);</span>

        <span class="cm">/* Number of dist codeword lengths (5 bits + 1). */</span>
        <span class="n">num_dist_lens</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">MIN_DIST_LENS</span><span class="p">);</span>
        <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="mi">5</span><span class="p">;</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">num_dist_lens</span> <span class="o">&lt;=</span> <span class="n">MAX_DIST_LENS</span><span class="p">);</span>

        <span class="cm">/* Number of code length lengths (4 bits + 4). */</span>
        <span class="n">num_codelen_lens</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">MIN_CODELEN_LENS</span><span class="p">);</span>
        <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">num_codelen_lens</span> <span class="o">&lt;=</span> <span class="n">MAX_CODELEN_LENS</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
        }</span>
</pre></div>


<p>After those bits follow the codeword lengths for the codelen code. The lengths are plain three-bit values, but they are written in a special order defined by <span class="code">codelen_lengths_order</span> above. While there are 19 lengths to be specified, only <span class="code">num_codelen_lens</span> will be read from the stream; the rest are implicitly zero. It is for this reason the lengths are in a special order: to increase the chance that latter lengths will all be zero and do not have to be stored in the block.</p>

<div class="highlight"><pre><span></span>        <span class="cm">/* Read the codelen codeword lengths (3 bits each)
           and initialize the codelen decoder. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_codelen_lens</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">bits</span> <span class="o">=</span> <span class="n">istream_bits</span><span class="p">(</span><span class="n">is</span><span class="p">);</span>
                <span class="n">codelen_lengths</span><span class="p">[</span><span class="n">codelen_lengths_order</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span>
                        <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="mi">3</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
                }
        }</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_CODELEN_LENS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">codelen_lengths</span><span class="p">[</span><span class="n">codelen_lengths_order</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;
        }</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">huffman_decoder_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codelen_dec</span><span class="p">,</span> <span class="n">codelen_lengths</span><span class="p">,</span>
                                  <span class="n">MAX_CODELEN_LENS</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
        }</span>
</pre></div>


<p>With the codelen decoder set up, we can proceed to read the litlen and dist codeword lengths from the stream.</p>

<div class="highlight"><pre><span></span>        <span class="cm">/* Read the litlen and dist codeword lengths. */</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_litlen_lens</span> <span class="o">+</span> <span class="n">num_dist_lens</span><span class="p">) {</span>
                <span class="n">bits</span> <span class="o">=</span> <span class="n">istream_bits</span><span class="p">(</span><span class="n">is</span><span class="p">);</span>
                <span class="n">sym</span> <span class="o">=</span> <span class="n">huffman_decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codelen_dec</span><span class="p">, (</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">used</span><span class="p">);</span>
                <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="n">used</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">used</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
                }</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">sym</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sym</span> <span class="o">&lt;=</span> <span class="n">CODELEN_MAX_LIT</span><span class="p">) {</span>
                        <span class="cm">/* A literal codeword length. */</span>
                        <span class="n">code_lengths</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">sym</span><span class="p">;
                }</span>
</pre></div>


<p>Lengths 16, 17, and 18 are not real lengths, but indicate that the previous length should be repeated some number of times, or that a zero length should be repeated:</p>

<div class="highlight"><pre><span></span>                <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">sym</span> <span class="o">==</span> <span class="n">CODELEN_COPY</span><span class="p">) {</span>
                        <span class="cm">/* Copy the previous codeword length 3--6 times. */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">) {</span>
                                <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;</span> <span class="cm">/* No previous length. */</span>
                        <span class="p">}</span>
                        <span class="cm">/* 2 bits + 3 */</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">CODELEN_COPY_MIN</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="mi">2</span><span class="p">)) {</span>
                                <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
                        }</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">CODELEN_COPY_MIN</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">CODELEN_COPY_MAX</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">num_litlen_lens</span> <span class="o">+</span> <span class="n">num_dist_lens</span><span class="p">) {</span>
                                <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
                        }</span>
                        <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">) {</span>
                                <span class="n">code_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">code_lengths</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                                <span class="n">i</span><span class="o">++</span><span class="p">;
                        }
                }</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">sym</span> <span class="o">==</span> <span class="n">CODELEN_ZEROS</span><span class="p">) {</span>
                        <span class="cm">/* 3--10 zeros; 3 bits + 3 */</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">CODELEN_ZEROS_MIN</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="mi">3</span><span class="p">)) {</span>
                                <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
                        }</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">CODELEN_ZEROS_MIN</span> <span class="o">&amp;&amp;</span>
                               <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">CODELEN_ZEROS_MAX</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">num_litlen_lens</span> <span class="o">+</span> <span class="n">num_dist_lens</span><span class="p">) {</span>
                                <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
                        }</span>
                        <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">) {</span>
                                <span class="n">code_lengths</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;
                        }
                }</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">sym</span> <span class="o">==</span> <span class="n">CODELEN_ZEROS2</span><span class="p">) {</span>
                        <span class="cm">/* 11--138 zeros; 7 bits + 138. */</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="n">CODELEN_ZEROS2_MIN</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="mi">7</span><span class="p">)) {</span>
                                <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
                        }</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">CODELEN_ZEROS2_MIN</span> <span class="o">&amp;&amp;</span>
                               <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">CODELEN_ZEROS2_MAX</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">num_litlen_lens</span> <span class="o">+</span> <span class="n">num_dist_lens</span><span class="p">) {</span>
                                <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
                        }</span>
                        <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">) {</span>
                                <span class="n">code_lengths</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;
                        }
                }</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="cm">/* Invalid symbol. */</span>
                        <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
                }
        }</span>
</pre></div>


<p>Note that the litlen and dist lengths are read one after the other into the same <span class="code">code_lengths</span> array. They could not be read separately, because code length runs can carry over from the last litlen lengths to the first dist lengths.</p>

<p>With the codeword lengths ready for use, we can set up the Huffman decoders and return to the task of decoding literals and back references:</p>

<div class="highlight"><pre><span></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">huffman_decoder_init</span><span class="p">(</span><span class="n">litlen_dec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">code_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                  <span class="n">num_litlen_lens</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
        }</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">huffman_decoder_init</span><span class="p">(</span><span class="n">dist_dec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">code_lengths</span><span class="p">[</span><span class="n">num_litlen_lens</span><span class="p">],</span>
                                  <span class="n">num_dist_lens</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="n">HWINF_ERR</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="n">HWINF_OK</span><span class="p">;
}</span>
</pre></div>


<a name="deflation"></a>
<h3>Compression (Deflation)</h3>

<p>From the sections above, we have all the tools needed for Deflate compression: Lempel–Ziv, Huffman coding, bitstreams, and the description of the three Deflate block types. This section puts the pieces together to finally perform Deflate compression.</p>

<p>Lempel–Ziv compression parses the source data into a sequence of back references and literals. This sequence needs to be divided and encoded into Deflate blocks as described in the previous section. Choosing how to do this division is sometimes referred to as <em>block splitting</em>. On the one hand, each new block carries some overhead which varies depending on block type and contents, so fewer blocks means less overhead. On the other hand, the overhead from starting a new block might be worth it, for example if the characteristics of the data lead to a more efficient Huffman encoding in the new block and smaller output overall.</p>

<p>Block splitting is a difficult optimization problem. Some compressors (such as <a href="https://github.com/google/zopfli">Zopfli</a>) try harder than others, but most just use a greedy approach: output a block once a certain size has been reached.</p>

<p>The different block types impose different size constraints:</p>

<ul>
<li>Uncompressed blocks can contain at most 65,535 bytes.</li>
<li>Fixed Huffman Code blocks do not have a maximum size.</li>
<li>Dynamic Huffman Code blocks do not generally have a maximum size, but because our implementation of Huffman's algorithm uses 16-bit symbol frequencies, we are limited to at most 65,535 symbols.</li>
</ul>

<p>To be able to freely choose any of the three types for block, we limit the block size to at most 65,534 bytes:</p>

<div class="highlight"><pre><span></span><span class="cm">/* The largest number of bytes that will fit in any kind of block is 65,534.
   It will fit in an uncompressed block (max 65,535 bytes) and a Huffman
   block with only literals (65,535 symbols including end-of-block marker). */</span>
<span class="cp">#define MAX_BLOCK_LEN_BYTES 65534</span>
</pre></div>


<p>We use a structure to keep track of the output bitstream and the contents of the current block during deflation:</p>

<div class="highlight"><pre><span></span><span class="k">typedef struct</span> <span class="n">deflate_state_t deflate_state_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">deflate_state_t</span> <span class="p">{</span>
        <span class="n">ostream_t os</span><span class="p">;</span>

        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">block_src</span><span class="p">;</span> <span class="cm">/* First src byte in the block. */</span>

        <span class="kt">size_t</span> <span class="n">block_len</span><span class="p">;</span>       <span class="cm">/* Number of symbols in the current block. */</span>
        <span class="kt">size_t</span> <span class="n">block_len_bytes</span><span class="p">;</span> <span class="cm">/* Number of src bytes in the block. */

        /* Symbol frequencies for the current block. */</span>
        <span class="kt">uint16_t</span> <span class="n">litlen_freqs</span><span class="p">[</span><span class="n">LITLEN_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="kt">uint16_t</span> <span class="n">dist_freqs</span><span class="p">[</span><span class="n">DISTSYM_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">struct</span> <span class="p">{</span>
                <span class="kt">uint16_t</span> <span class="n">distance</span><span class="p">;</span>    <span class="cm">/* Backref distance. */</span>
                <span class="k">union</span> <span class="p">{</span>
                        <span class="kt">uint16_t</span> <span class="n">lit</span><span class="p">;</span> <span class="cm">/* Literal byte or end-of-block. */</span>
                        <span class="kt">uint16_t</span> <span class="n">len</span><span class="p">;</span> <span class="cm">/* Backref length (distance != 0). */</span>
                <span class="p">}</span> <span class="n">u</span><span class="p">;
        }</span> <span class="n">block</span><span class="p">[</span><span class="n">MAX_BLOCK_LEN_BYTES</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];
};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_block</span><span class="p">(</span><span class="n">deflate_state_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)
{</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">litlen_freqs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">litlen_freqs</span><span class="p">));</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dist_freqs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dist_freqs</span><span class="p">));
}</span>
</pre></div>


<p>Callback functions are used to update the block with the output from <span class="code">lz77_compress</span>, and write the block to the bitstream when it reaches the maximum size:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">lit_callback</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">lit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">)
{</span>
        <span class="n">deflate_state_t</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">aux</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len_bytes</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">MAX_BLOCK_LEN_BYTES</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">false</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>
                <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_src</span> <span class="o">+=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len_bytes</span><span class="p">;</span>
                <span class="n">reset_block</span><span class="p">(</span><span class="n">s</span><span class="p">);
        }</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len</span>  <span class="p">].</span><span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len</span><span class="o">++</span><span class="p">].</span><span class="n">u</span><span class="p">.</span><span class="n">lit</span> <span class="o">=</span> <span class="n">lit</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len_bytes</span><span class="o">++</span><span class="p">;</span>

        <span class="n">s</span><span class="o">-&gt;</span><span class="n">litlen_freqs</span><span class="p">[</span><span class="n">lit</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>

<span class="k">static</span> <span class="kt">bool</span> <span class="nf">backref_callback</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">)
{</span>
        <span class="n">deflate_state_t</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">aux</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len_bytes</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">MAX_BLOCK_LEN_BYTES</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">false</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>
                <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_src</span> <span class="o">+=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len_bytes</span><span class="p">;</span>
                <span class="n">reset_block</span><span class="p">(</span><span class="n">s</span><span class="p">);
        }</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len</span>  <span class="p">].</span><span class="n">distance</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">dist</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len</span><span class="o">++</span><span class="p">].</span><span class="n">u</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">len</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len_bytes</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">MIN_LEN</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">MAX_LEN</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">MIN_DISTANCE</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">MAX_DISTANCE</span><span class="p">);</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">litlen_freqs</span><span class="p">[</span><span class="n">len2litlen</span><span class="p">[</span><span class="n">len</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">dist_freqs</span><span class="p">[</span><span class="n">distance2dist</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span><span class="o">++</span><span class="p">;</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<p>The interesting part is of course writing the blocks. Writing an uncompressed block is straight-forward:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">write_uncomp_block</span><span class="p">(</span><span class="n">deflate_state_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">final</span><span class="p">)
{</span>
        <span class="kt">uint8_t</span> <span class="n">len_nlen</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

        <span class="cm">/* Write the block header. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">, (</span><span class="mh">0x0</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">final</span><span class="p">,</span> <span class="mi">3</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="n">len_nlen</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len_bytes</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">len_nlen</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len_bytes</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
        <span class="n">len_nlen</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">= ~</span><span class="n">len_nlen</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">len_nlen</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">= ~</span><span class="n">len_nlen</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write_bytes_aligned</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">len_nlen</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">len_nlen</span><span class="p">))) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write_bytes_aligned</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_src</span><span class="p">,</span>
                                         <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len_bytes</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<p>To write a static Huffman block, we first generate canonical Huffman codes based on the fixed codeword lengths for the litlen and dist codes. Then we iterate through the block, writing the symbols using those codes:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">write_static_block</span><span class="p">(</span><span class="n">deflate_state_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">final</span><span class="p">)
{</span>
        <span class="n">huffman_encoder_t litlen_enc</span><span class="p">,</span> <span class="n">dist_enc</span><span class="p">;</span>

        <span class="cm">/* Write the block header. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">, (</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">final</span><span class="p">,</span> <span class="mi">3</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="n">huffman_encoder_init2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">litlen_enc</span><span class="p">,</span> <span class="n">fixed_litlen_lengths</span><span class="p">,</span>
                              <span class="k">sizeof</span><span class="p">(</span><span class="n">fixed_litlen_lengths</span><span class="p">)</span> <span class="o">/</span>
                              <span class="k">sizeof</span><span class="p">(</span><span class="n">fixed_litlen_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
        <span class="n">huffman_encoder_init2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dist_enc</span><span class="p">,</span> <span class="n">fixed_dist_lengths</span><span class="p">,</span>
                              <span class="k">sizeof</span><span class="p">(</span><span class="n">fixed_dist_lengths</span><span class="p">)</span> <span class="o">/</span>
                              <span class="k">sizeof</span><span class="p">(</span><span class="n">fixed_dist_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>

        <span class="k">return</span> <span class="n">write_huffman_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">litlen_enc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dist_enc</span><span class="p">);
}</span>

<span class="k">static</span> <span class="kt">bool</span> <span class="nf">write_huffman_block</span><span class="p">(</span><span class="n">deflate_state_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">huffman_encoder_t</span> <span class="o">*</span><span class="n">litlen_enc</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">huffman_encoder_t</span> <span class="o">*</span><span class="n">dist_enc</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">nbits</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">distance</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">litlen</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">bits</span><span class="p">,</span> <span class="n">ebits</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">distance</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="cm">/* Literal or EOB. */</span>
                        <span class="n">litlen</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">u</span><span class="p">.</span><span class="n">lit</span><span class="p">;</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">litlen</span> <span class="o">&lt;=</span> <span class="n">LITLEN_EOB</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span>
                                           <span class="n">litlen_enc</span><span class="o">-&gt;</span><span class="n">codewords</span><span class="p">[</span><span class="n">litlen</span><span class="p">],</span>
                                           <span class="n">litlen_enc</span><span class="o">-&gt;</span><span class="n">lengths</span><span class="p">[</span><span class="n">litlen</span><span class="p">])) {</span>
                                <span class="k">return</span> <span class="nb">false</span><span class="p">;
                        }</span>
                        <span class="k">continue</span><span class="p">;
                }</span>

                <span class="cm">/* Back reference length. */</span>
                <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">u</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
                <span class="n">litlen</span> <span class="o">=</span> <span class="n">len2litlen</span><span class="p">[</span><span class="n">len</span><span class="p">];</span>

                <span class="cm">/* litlen bits */</span>
                <span class="n">bits</span> <span class="o">=</span> <span class="n">litlen_enc</span><span class="o">-&gt;</span><span class="n">codewords</span><span class="p">[</span><span class="n">litlen</span><span class="p">];</span>
                <span class="n">nbits</span> <span class="o">=</span> <span class="n">litlen_enc</span><span class="o">-&gt;</span><span class="n">lengths</span><span class="p">[</span><span class="n">litlen</span><span class="p">];</span>

                <span class="cm">/* ebits */</span>
                <span class="n">ebits</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">litlen_tbl</span><span class="p">[</span><span class="n">litlen</span> <span class="o">-</span> <span class="n">LITLEN_TBL_OFFSET</span><span class="p">].</span><span class="n">base_len</span><span class="p">;</span>
                <span class="n">bits</span> <span class="o">|=</span> <span class="n">ebits</span> <span class="o">&lt;&lt;</span> <span class="n">nbits</span><span class="p">;</span>
                <span class="n">nbits</span> <span class="o">+=</span> <span class="n">litlen_tbl</span><span class="p">[</span><span class="n">litlen</span> <span class="o">-</span> <span class="n">LITLEN_TBL_OFFSET</span><span class="p">].</span><span class="n">ebits</span><span class="p">;</span>

                <span class="cm">/* Back reference distance. */</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">distance</span><span class="p">;</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">distance2dist</span><span class="p">(</span><span class="n">distance</span><span class="p">);</span>

                <span class="cm">/* dist bits */</span>
                <span class="n">bits</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">dist_enc</span><span class="o">-&gt;</span><span class="n">codewords</span><span class="p">[</span><span class="n">dist</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">nbits</span><span class="p">;</span>
                <span class="n">nbits</span> <span class="o">+=</span> <span class="n">dist_enc</span><span class="o">-&gt;</span><span class="n">lengths</span><span class="p">[</span><span class="n">dist</span><span class="p">];</span>

                <span class="cm">/* ebits */</span>
                <span class="n">ebits</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">-</span> <span class="n">dist_tbl</span><span class="p">[</span><span class="n">dist</span><span class="p">].</span><span class="n">base_dist</span><span class="p">;</span>
                <span class="n">bits</span> <span class="o">|=</span> <span class="n">ebits</span> <span class="o">&lt;&lt;</span> <span class="n">nbits</span><span class="p">;</span>
                <span class="n">nbits</span> <span class="o">+=</span> <span class="n">dist_tbl</span><span class="p">[</span><span class="n">dist</span><span class="p">].</span><span class="n">ebits</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }
        }</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<p>Dynamic Huffman blocks are of course the trickiest to write, since they include the intricate encoding of the litlen and dist codes. We will use this struct to represent their encoding:</p>

<div class="highlight"><pre><span></span><span class="k">typedef struct</span> <span class="n">codelen_sym_t codelen_sym_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">codelen_sym_t</span> <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="n">sym</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">count</span><span class="p">;</span> <span class="cm">/* For symbols 16, 17, 18. */</span>
<span class="p">};</span>
</pre></div>


<p>First, we drop trailing zero litlen and dist codeword lengths, and copy them into a common array for encoding. We cannot drop all trailing zeros: it is not possible to encode a Deflate block with fewer than one dist code. (It is also not possible to have fewer then 257 litlen codes, but since there is always an end-of-byte marker, there will always be a non-zero code length for symbol 256.)</p>

<div class="highlight"><pre><span></span><span class="cm">/* Encode litlen_lens and dist_lens into encoded. *num_litlen_lens and
   *num_dist_lens will be set to the number of encoded litlen and dist lens,
   respectively. Returns the number of elements in encoded. */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">encode_dist_litlen_lens</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">litlen_lens</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dist_lens</span><span class="p">,</span>
                                      <span class="n">codelen_sym_t</span> <span class="o">*</span><span class="n">encoded</span><span class="p">,</span>
                                      <span class="kt">size_t</span> <span class="o">*</span><span class="n">num_litlen_lens</span><span class="p">,</span>
                                      <span class="kt">size_t</span> <span class="o">*</span><span class="n">num_dist_lens</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">lens</span><span class="p">[</span><span class="n">LITLEN_MAX</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">DISTSYM_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

        <span class="o">*</span><span class="n">num_litlen_lens</span> <span class="o">=</span> <span class="n">LITLEN_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="o">*</span><span class="n">num_dist_lens</span> <span class="o">=</span> <span class="n">DISTSYM_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="cm">/* Drop trailing zero litlen lengths. */</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">litlen_lens</span><span class="p">[</span><span class="n">LITLEN_EOB</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">"EOB len should be non-zero."</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">litlen_lens</span><span class="p">[</span><span class="o">*</span><span class="n">num_litlen_lens</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {
                (</span><span class="o">*</span><span class="n">num_litlen_lens</span><span class="p">)</span><span class="o">--</span><span class="p">;
        }</span>
        <span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">num_litlen_lens</span> <span class="o">&gt;=</span> <span class="n">MIN_LITLEN_LENS</span><span class="p">);</span>

        <span class="cm">/* Drop trailing zero dist lengths, keeping at least one. */</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">dist_lens</span><span class="p">[</span><span class="o">*</span><span class="n">num_dist_lens</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp; *</span><span class="n">num_dist_lens</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">) {
                (</span><span class="o">*</span><span class="n">num_dist_lens</span><span class="p">)</span><span class="o">--</span><span class="p">;
        }</span>
        <span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">num_dist_lens</span> <span class="o">&gt;=</span> <span class="n">MIN_DIST_LENS</span><span class="p">);</span>

        <span class="cm">/* Copy the lengths into a unified array. */</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt; *</span><span class="n">num_litlen_lens</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">lens</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">litlen_lens</span><span class="p">[</span><span class="n">i</span><span class="p">];
        }</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt; *</span><span class="n">num_dist_lens</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">lens</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_lens</span><span class="p">[</span><span class="n">i</span><span class="p">];
        }</span>

        <span class="k">return</span> <span class="n">encode_lens</span><span class="p">(</span><span class="n">lens</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">encoded</span><span class="p">);
}</span>
</pre></div>


<p>Once the code lengths are in a single array, we perform the encoding, using special symbols for runs of identical code lengths.</p>

<div class="highlight"><pre><span></span><span class="cm">/* Encode the n code lengths in lens into encoded, returning the number of
   elements in encoded. */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">encode_lens</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">lens</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">codelen_sym_t</span> <span class="o">*</span><span class="n">encoded</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">num_encoded</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">count</span><span class="p">;</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">num_encoded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">lens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="cm">/* Scan past the end of this zero run (max 138). */</span>
                        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">CODELEN_ZEROS2_MAX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                                    <span class="n">lens</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">);</span>
                        <span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">CODELEN_ZEROS_MIN</span><span class="p">) {</span>
                                <span class="cm">/* Output a single zero. */</span>
                                <span class="n">encoded</span><span class="p">[</span><span class="n">num_encoded</span><span class="o">++</span><span class="p">].</span><span class="n">sym</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
                                <span class="k">continue</span><span class="p">;
                        }</span>

                        <span class="cm">/* Output a repeated zero. */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="n">CODELEN_ZEROS_MAX</span><span class="p">) {</span>
                                <span class="cm">/* Repeated zero 3--10 times. */</span>
                                <span class="n">assert</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">CODELEN_ZEROS_MIN</span> <span class="o">&amp;&amp;</span>
                                       <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">CODELEN_ZEROS_MAX</span><span class="p">);</span>
                                <span class="n">encoded</span><span class="p">[</span><span class="n">num_encoded</span><span class="p">].</span><span class="n">sym</span> <span class="o">=</span> <span class="n">CODELEN_ZEROS</span><span class="p">;</span>
                                <span class="n">encoded</span><span class="p">[</span><span class="n">num_encoded</span><span class="o">++</span><span class="p">].</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;
                        }</span> <span class="k">else</span> <span class="p">{</span>
                                <span class="cm">/* Repeated zero 11--138 times. */</span>
                                <span class="n">assert</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">CODELEN_ZEROS2_MIN</span> <span class="o">&amp;&amp;</span>
                                       <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">CODELEN_ZEROS2_MAX</span><span class="p">);</span>
                                <span class="n">encoded</span><span class="p">[</span><span class="n">num_encoded</span><span class="p">].</span><span class="n">sym</span> <span class="o">=</span> <span class="n">CODELEN_ZEROS2</span><span class="p">;</span>
                                <span class="n">encoded</span><span class="p">[</span><span class="n">num_encoded</span><span class="o">++</span><span class="p">].</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;
                        }</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                        <span class="k">continue</span><span class="p">;
                }</span>

                <span class="cm">/* Output len. */</span>
                <span class="n">encoded</span><span class="p">[</span><span class="n">num_encoded</span><span class="o">++</span><span class="p">].</span><span class="n">sym</span> <span class="o">=</span> <span class="n">lens</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>

                <span class="cm">/* Scan past the end of the run of this len (max 6). */</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">CODELEN_COPY_MAX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                            <span class="n">lens</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">lens</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span><span class="p">);</span>
                <span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">CODELEN_COPY_MIN</span><span class="p">) {</span>
                        <span class="cm">/* Repeat last len 3--6 times. */</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">CODELEN_COPY_MIN</span> <span class="o">&amp;&amp;</span>
                               <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">CODELEN_COPY_MAX</span><span class="p">);</span>
                        <span class="n">encoded</span><span class="p">[</span><span class="n">num_encoded</span><span class="p">].</span><span class="n">sym</span> <span class="o">=</span> <span class="n">CODELEN_COPY</span><span class="p">;</span>
                        <span class="n">encoded</span><span class="p">[</span><span class="n">num_encoded</span><span class="o">++</span><span class="p">].</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                        <span class="k">continue</span><span class="p">;
                }
        }</span>

        <span class="k">return</span> <span class="n">num_encoded</span><span class="p">;
}</span>
</pre></div>


<p>The symbols used in the encoding above will in turn get written using a Huffman code, the "codelen code". The codeword lengths of the codelen code are written to the block in a certain order, with lengths more likely to be zero coming last. A function is used to count how many of the lengths that need to be written:</p>

<div class="highlight"><pre><span></span><span class="k">static const</span> <span class="kt">int</span> <span class="n">codelen_lengths_order</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15</span> <span class="p">};</span>

<span class="cm">/* Count the number of significant (not trailing zeros) codelen lengths. */</span>
<span class="kt">size_t</span> <span class="nf">count_codelen_lens</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">codelen_lens</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">MAX_CODELEN_LENS</span><span class="p">;</span>

        <span class="cm">/* Drop trailing zero lengths. */</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">codelen_lens</span><span class="p">[</span><span class="n">codelen_lengths_order</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">n</span><span class="o">--</span><span class="p">;
        }</span>

        <span class="cm">/* The first 4 lengths in the order (16, 17, 18, 0) cannot be used to
           encode any non-zero lengths. Since there will always be at least
           one non-zero codeword length (for EOB), n will be &gt;= 4. */</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">MIN_CODELEN_LENS</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">MAX_CODELEN_LENS</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">n</span><span class="p">;
}</span>
</pre></div>


<p>Assuming we have the litlen and dist codes set up, the encoding of their codeword lengths, and the code for that encoding, we can write the dynamic Huffman block:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">write_dynamic_block</span><span class="p">(</span><span class="n">deflate_state_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">final</span><span class="p">,</span>
                                <span class="kt">size_t</span> <span class="n">num_litlen_lens</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">num_dist_lens</span><span class="p">,</span>
                                <span class="kt">size_t</span> <span class="n">num_codelen_lens</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">huffman_encoder_t</span> <span class="o">*</span><span class="n">codelen_enc</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">codelen_sym_t</span> <span class="o">*</span><span class="n">encoded_lens</span><span class="p">,</span>
                                <span class="kt">size_t</span> <span class="n">num_encoded_lens</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">huffman_encoder_t</span> <span class="o">*</span><span class="n">litlen_enc</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">huffman_encoder_t</span> <span class="o">*</span><span class="n">dist_enc</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">codelen</span><span class="p">,</span> <span class="n">sym</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">nbits</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">bits</span><span class="p">,</span> <span class="n">hlit</span><span class="p">,</span> <span class="n">hdist</span><span class="p">,</span> <span class="n">hclen</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

        <span class="cm">/* Block header. */</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x2</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">final</span><span class="p">;</span>
        <span class="n">nbits</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

        <span class="cm">/* hlit (5 bits) */</span>
        <span class="n">hlit</span> <span class="o">=</span> <span class="n">num_litlen_lens</span> <span class="o">-</span> <span class="n">MIN_LITLEN_LENS</span><span class="p">;</span>
        <span class="n">bits</span> <span class="o">|=</span> <span class="n">hlit</span> <span class="o">&lt;&lt;</span> <span class="n">nbits</span><span class="p">;</span>
        <span class="n">nbits</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>

        <span class="cm">/* hdist (5 bits) */</span>
        <span class="n">hdist</span> <span class="o">=</span> <span class="n">num_dist_lens</span> <span class="o">-</span> <span class="n">MIN_DIST_LENS</span><span class="p">;</span>
        <span class="n">bits</span> <span class="o">|=</span> <span class="n">hdist</span> <span class="o">&lt;&lt;</span> <span class="n">nbits</span><span class="p">;</span>
        <span class="n">nbits</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>

        <span class="cm">/* hclen (4 bits) */</span>
        <span class="n">hclen</span> <span class="o">=</span> <span class="n">num_codelen_lens</span> <span class="o">-</span> <span class="n">MIN_CODELEN_LENS</span><span class="p">;</span>
        <span class="n">bits</span> <span class="o">|=</span> <span class="n">hclen</span> <span class="o">&lt;&lt;</span> <span class="n">nbits</span><span class="p">;</span>
        <span class="n">nbits</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="cm">/* Codelen lengths. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_codelen_lens</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">codelen</span> <span class="o">=</span> <span class="n">codelen_enc</span><span class="o">-&gt;</span><span class="n">lengths</span><span class="p">[</span><span class="n">codelen_lengths_order</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">codelen</span><span class="p">,</span> <span class="mi">3</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }
        }</span>

        <span class="cm">/* Litlen and dist code lengths. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_encoded_lens</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">sym</span> <span class="o">=</span> <span class="n">encoded_lens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sym</span><span class="p">;</span>

                <span class="n">bits</span> <span class="o">=</span> <span class="n">codelen_enc</span><span class="o">-&gt;</span><span class="n">codewords</span><span class="p">[</span><span class="n">sym</span><span class="p">];</span>
                <span class="n">nbits</span> <span class="o">=</span> <span class="n">codelen_enc</span><span class="o">-&gt;</span><span class="n">lengths</span><span class="p">[</span><span class="n">sym</span><span class="p">];</span>

                <span class="n">count</span> <span class="o">=</span> <span class="n">encoded_lens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sym</span> <span class="o">==</span> <span class="n">CODELEN_COPY</span><span class="p">) {</span> <span class="cm">/* 2 ebits */</span>
                        <span class="n">bits</span> <span class="o">|=</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="n">CODELEN_COPY_MIN</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">nbits</span><span class="p">;</span>
                        <span class="n">nbits</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;
                }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">sym</span> <span class="o">==</span> <span class="n">CODELEN_ZEROS</span><span class="p">) {</span> <span class="cm">/* 3 ebits */</span>
                        <span class="n">bits</span> <span class="o">|=</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="n">CODELEN_ZEROS_MIN</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">nbits</span><span class="p">;</span>
                        <span class="n">nbits</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;
                }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">sym</span> <span class="o">==</span> <span class="n">CODELEN_ZEROS2</span><span class="p">) {</span> <span class="cm">/* 7 ebits */</span>
                        <span class="n">bits</span> <span class="o">|=</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="n">CODELEN_ZEROS2_MIN</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">nbits</span><span class="p">;</span>
                        <span class="n">nbits</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">;
                }</span>

                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }
        }</span>

        <span class="k">return</span> <span class="n">write_huffman_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">litlen_enc</span><span class="p">,</span> <span class="n">dist_enc</span><span class="p">);
}</span>
</pre></div>


<p>For each block, we want to use the type that needs the smallest number of bits. For an uncompressed block, the length can be computed quickly:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Calculate the number of bits for an uncompressed block, including header. */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">uncomp_block_len</span><span class="p">(</span><span class="k">const</span> <span class="n">deflate_state_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">bit_pos</span><span class="p">,</span> <span class="n">padding</span><span class="p">;</span>

        <span class="cm">/* Bit position after writing the block header. */</span>
        <span class="n">bit_pos</span> <span class="o">=</span> <span class="n">ostream_bit_pos</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="n">round_up</span><span class="p">(</span><span class="n">bit_pos</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="n">bit_pos</span><span class="p">;</span>

        <span class="cm">/* Header + padding + len/nlen + block contents. */</span>
        <span class="k">return</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">padding</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len_bytes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;
}</span>
</pre></div>


<p>For Huffman encoded blocks, we can compute the length of the body using the litlen and dist symbol frequencies and codeword lengths:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Calculate the number of bits for a Huffman encoded block body. */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">huffman_block_body_len</span><span class="p">(</span><span class="k">const</span> <span class="n">deflate_state_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
                                     <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">litlen_lens</span><span class="p">,</span>
                                     <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dist_lens</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>

        <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">LITLEN_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">freq</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">litlen_freqs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">len</span> <span class="o">+=</span> <span class="n">litlen_lens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">freq</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">LITLEN_TBL_OFFSET</span><span class="p">) {</span>
                        <span class="n">len</span> <span class="o">+=</span> <span class="n">litlen_tbl</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">LITLEN_TBL_OFFSET</span><span class="p">].</span><span class="n">ebits</span> <span class="o">*</span> <span class="n">freq</span><span class="p">;
                }
        }</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">DISTSYM_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">freq</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dist_freqs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">len</span> <span class="o">+=</span> <span class="n">dist_lens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">freq</span><span class="p">;</span>
                <span class="n">len</span> <span class="o">+=</span> <span class="n">dist_tbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ebits</span> <span class="o">*</span> <span class="n">freq</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="n">len</span><span class="p">;
}</span>
</pre></div>


<p>For a static block, the total length is 3 bits for the header plus the length of the body. For a dynamic block, computing the size of the header requires a bit more work:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Calculate the number of bits for a dynamic Huffman block. */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">dyn_block_len</span><span class="p">(</span><span class="k">const</span> <span class="n">deflate_state_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">num_codelen_lens</span><span class="p">,</span>
                            <span class="k">const</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">codelen_freqs</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">huffman_encoder_t</span> <span class="o">*</span><span class="n">codelen_enc</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">huffman_encoder_t</span> <span class="o">*</span><span class="n">litlen_enc</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">huffman_encoder_t</span> <span class="o">*</span><span class="n">dist_enc</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span><span class="p">;</span>

        <span class="cm">/* Block header. */</span>
        <span class="n">len</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

        <span class="cm">/* Nbr of litlen, dist, and codelen lengths. */</span>
        <span class="n">len</span> <span class="o">+=</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>

        <span class="cm">/* Codelen lengths. */</span>
        <span class="n">len</span> <span class="o">+=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">num_codelen_lens</span><span class="p">;</span>

        <span class="cm">/* Codelen encoding. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_CODELEN_LENS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">freq</span> <span class="o">=</span> <span class="n">codelen_freqs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">len</span> <span class="o">+=</span> <span class="n">codelen_enc</span><span class="o">-&gt;</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">freq</span><span class="p">;</span>

                <span class="cm">/* Extra bits. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">CODELEN_COPY</span><span class="p">) {</span>
                        <span class="n">len</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">freq</span><span class="p">;
                }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">CODELEN_ZEROS</span><span class="p">) {</span>
                        <span class="n">len</span> <span class="o">+=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">freq</span><span class="p">;
                }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">CODELEN_ZEROS2</span><span class="p">) {</span>
                        <span class="n">len</span> <span class="o">+=</span> <span class="mi">7</span> <span class="o">*</span> <span class="n">freq</span><span class="p">;
                }
        }</span>

        <span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="n">huffman_block_body_len</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">litlen_enc</span><span class="o">-&gt;</span><span class="n">lengths</span><span class="p">,</span>
                                            <span class="n">dist_enc</span><span class="o">-&gt;</span><span class="n">lengths</span><span class="p">);
}</span>
</pre></div>


<p>With all this in place, we can write the master block writing function:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Write the current deflate block, marking it final if that parameter is true,
   returning false if there is not enough room in the output stream. */</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">write_block</span><span class="p">(</span><span class="n">deflate_state_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">final</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">old_bit_pos</span><span class="p">,</span> <span class="n">uncomp_len</span><span class="p">,</span> <span class="n">static_len</span><span class="p">,</span> <span class="n">dynamic_len</span><span class="p">;</span>
        <span class="n">huffman_encoder_t dyn_litlen_enc</span><span class="p">,</span> <span class="n">dyn_dist_enc</span><span class="p">,</span> <span class="n">codelen_enc</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">num_encoded_lens</span><span class="p">,</span> <span class="n">num_litlen_lens</span><span class="p">,</span> <span class="n">num_dist_lens</span><span class="p">;</span>
        <span class="n">codelen_sym_t encoded_lens</span><span class="p">[</span><span class="n">LITLEN_MAX</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">DISTSYM_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="kt">uint16_t</span> <span class="n">codelen_freqs</span><span class="p">[</span><span class="n">MAX_CODELEN_LENS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
        <span class="kt">size_t</span> <span class="n">num_codelen_lens</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

        <span class="n">old_bit_pos</span> <span class="o">=</span> <span class="n">ostream_bit_pos</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">);</span>

        <span class="cm">/* Add the end-of-block marker in case we write a Huffman block. */</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">litlen_freqs</span><span class="p">[</span><span class="n">LITLEN_EOB</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len</span>  <span class="p">].</span><span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block_len</span><span class="o">++</span><span class="p">].</span><span class="n">u</span><span class="p">.</span><span class="n">lit</span> <span class="o">=</span> <span class="n">LITLEN_EOB</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">litlen_freqs</span><span class="p">[</span><span class="n">LITLEN_EOB</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>


        <span class="n">uncomp_len</span> <span class="o">=</span> <span class="n">uncomp_block_len</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

        <span class="n">static_len</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">huffman_block_body_len</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">fixed_litlen_lengths</span><span class="p">,</span>
                                                <span class="n">fixed_dist_lengths</span><span class="p">);</span>


        <span class="cm">/* Compute "dynamic" Huffman codes. */</span>
        <span class="n">huffman_encoder_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dyn_litlen_enc</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">litlen_freqs</span><span class="p">,</span>
                             <span class="n">LITLEN_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
        <span class="n">huffman_encoder_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dyn_dist_enc</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dist_freqs</span><span class="p">,</span> <span class="n">DISTSYM_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
        <span class="n">tweak_dist_encoder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dyn_dist_enc</span><span class="p">);</span>

        <span class="cm">/* Encode the litlen and dist code lengths. */</span>
        <span class="n">num_encoded_lens</span> <span class="o">=</span> <span class="n">encode_dist_litlen_lens</span><span class="p">(</span><span class="n">dyn_litlen_enc</span><span class="p">.</span><span class="n">lengths</span><span class="p">,</span>
                                                   <span class="n">dyn_dist_enc</span><span class="p">.</span><span class="n">lengths</span><span class="p">,</span>
                                                   <span class="n">encoded_lens</span><span class="p">,</span>
                                                   <span class="o">&amp;</span><span class="n">num_litlen_lens</span><span class="p">,</span>
                                                   <span class="o">&amp;</span><span class="n">num_dist_lens</span><span class="p">);</span>

        <span class="cm">/* Compute the codelen code. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_encoded_lens</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">codelen_freqs</span><span class="p">[</span><span class="n">encoded_lens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sym</span><span class="p">]</span><span class="o">++</span><span class="p">;
        }</span>
        <span class="n">huffman_encoder_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codelen_enc</span><span class="p">,</span> <span class="n">codelen_freqs</span><span class="p">,</span> <span class="n">MAX_CODELEN_LENS</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
        <span class="n">num_codelen_lens</span> <span class="o">=</span> <span class="n">count_codelen_lens</span><span class="p">(</span><span class="n">codelen_enc</span><span class="p">.</span><span class="n">lengths</span><span class="p">);</span>

        <span class="n">dynamic_len</span> <span class="o">=</span> <span class="n">dyn_block_len</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">num_codelen_lens</span><span class="p">,</span> <span class="n">codelen_freqs</span><span class="p">,</span>
                                    <span class="o">&amp;</span><span class="n">codelen_enc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dyn_litlen_enc</span><span class="p">,</span>
                                    <span class="o">&amp;</span><span class="n">dyn_dist_enc</span><span class="p">);</span>


        <span class="k">if</span> <span class="p">(</span><span class="n">uncomp_len</span> <span class="o">&lt;=</span> <span class="n">dynamic_len</span> <span class="o">&amp;&amp;</span> <span class="n">uncomp_len</span> <span class="o">&lt;=</span> <span class="n">static_len</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_uncomp_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">final</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">ostream_bit_pos</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">)</span> <span class="o">-</span> <span class="n">old_bit_pos</span> <span class="o">==</span> <span class="n">uncomp_len</span><span class="p">);
        }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">static_len</span> <span class="o">&lt;=</span> <span class="n">dynamic_len</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_static_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">final</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">ostream_bit_pos</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">)</span> <span class="o">-</span> <span class="n">old_bit_pos</span> <span class="o">==</span> <span class="n">static_len</span><span class="p">);
        }</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_dynamic_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">final</span><span class="p">,</span> <span class="n">num_litlen_lens</span><span class="p">,</span>
                                         <span class="n">num_dist_lens</span><span class="p">,</span> <span class="n">num_codelen_lens</span><span class="p">,</span>
                                         <span class="o">&amp;</span><span class="n">codelen_enc</span><span class="p">,</span> <span class="n">encoded_lens</span><span class="p">,</span>
                                         <span class="n">num_encoded_lens</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dyn_litlen_enc</span><span class="p">,</span>
                                         <span class="o">&amp;</span><span class="n">dyn_dist_enc</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">ostream_bit_pos</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">)</span> <span class="o">-</span> <span class="n">old_bit_pos</span> <span class="o">==</span> <span class="n">dynamic_len</span><span class="p">);
        }</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<p>Finally, the driver of the whole deflation process simply has to set up the initial state, kick off the Lempel–Ziv compression, and write the final block:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Compress (deflate) the data in src into dst. The number of bytes output, at
   most dst_cap, is stored in *dst_used. Returns false if there is not enough
   room in dst. src and dst must not overlap. */</span>
<span class="kt">bool</span> <span class="nf">hwdeflate</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">src_len</span><span class="p">,</span>
               <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">dst_used</span><span class="p">)
{</span>
        <span class="n">deflate_state_t s</span><span class="p">;</span>

        <span class="n">ostream_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">.</span><span class="n">os</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">dst_cap</span><span class="p">);</span>
        <span class="n">reset_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
        <span class="n">s</span><span class="p">.</span><span class="n">block_src</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lz77_compress</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">src_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lit_callback</span><span class="p">,</span>
                           <span class="o">&amp;</span><span class="n">backref_callback</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="nb">true</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="cm">/* The end of the final block should match the end of src. */</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">block_src</span> <span class="o">+</span> <span class="n">s</span><span class="p">.</span><span class="n">block_len_bytes</span> <span class="o">==</span> <span class="n">src</span> <span class="o">+</span> <span class="n">src_len</span><span class="p">);</span>

        <span class="o">*</span><span class="n">dst_used</span> <span class="o">=</span> <span class="n">ostream_bytes_written</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">.</span><span class="n">os</span><span class="p">);</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>



<a name="zip"></a>
<h2>The Zip File Format</h2>

<p>We have seen above exactly how the Deflate compression used in Zip files works, but what about the file format itself? This section explains it in detail and provides an implementation. The code is available in <a href="https://www.hanshq.net/files/hwzip/zip.h"><span class="code">zip.h</span></a> and <a href="https://www.hanshq.net/files/hwzip/zip.c"><span class="code">zip.c</span></a>.</p>

<a name="zipintro"></a>
<h3>Overview</h3>

<p>The file format is described in PKZip's <a href="https://www.pkware.com/documents/APPNOTE/APPNOTE-2.0.txt">Application Note</a>:</p>

<ol>
<li>Each file, or archive member, in the Zip file has a <em>Local File Header</em> with metadata about the member, such as its filename etc.</li>

<li>The <em>Central Directory</em> serves as an index of the archive. It contains a <em>Central File Header</em> for each archive member and holds a copy of the metadata from the Local File Header, and more information such as the member's offset in the ZIP file.</li>

<li>At the end of the file, directly after the Central Directory, comes the <em>End of Central Directory Record</em>. This contains the size and position of the Central Directory, and an optional comment about the whole archive. It is the starting point for reading a Zip file.</li>
</ol>

<div style="text-align: center">
<div class="latex"><p style="margin-left: 2em"><img src="./zip_files/tex_b8b86b0a.svg" alt="LaTeX"></p></div>
</div>

<p>Each archive member is compressed and stored individually. This means that even if there are similarities between files in the archive, those similarities are not exploited to generate better compression.</p>

<p>Having the Central Directory at the end enables an archive to be created gradually. As each member file is compressed, it gets written to the archive, and the index is written afterwards when all the compressed sizes, and therefore the file offsets, are known. A file can also be added to an existing archive fairly easily, by putting it after the last member and re-writing the Central Directory.</p>

<p>The ability to create archives gradually was especially important for archives spanning multiple floppy disks, or volumes. As compression progressed, PKZip would prompt the user to insert new floppies, and finally write the Central Directory to the last one(s). To extract a multi-volume archive, PKZip would first ask for the last floppy in order to read the Central Directory, and then for whatever floppies were needed to extract the requested files.</p>

<p>Perhaps surprisingly, there is no rule against having multiple files with the same name in an archive. This can lead to great confusion during file extraction: if there are multiple files with the specified name, which one should be extracted? Such confusion can turn into security problems. In the Android "Master Key" Bug (<a href="https://nvd.nist.gov/vuln/detail/CVE-2013-4787">CVE-2013-4787</a>, Black Hat <a href="https://media.blackhat.com/us-13/US-13-Forristal-Android-One-Root-to-Own-Them-All-Slides.pdf">slides</a> / <a href="https://www.youtube.com/watch?v=mCF5kaCt4NI">video</a>), this allowed malicious actors to bypass the operating system's cryptographic signature checks when installing programs. Android programs are distributed in <a href="https://en.wikipedia.org/wiki/Android_application_package">APK</a> files, which are essentially Zip files. As it turned out, if an APK contained multiple files with the same name, the signature checking code would pick the <i>last</i> file with that name, whereas the installation code would pick the <i>first</i> file, meaning its signature was never checked. In other words, this minor difference between two Zip libraries made it possible to bypass the entire security model of the operating system.</p>

<p>Unlike most file formats, Zip files are not required to start with a signature or <a href="https://en.wikipedia.org/wiki/File_format#Magic_number">magic number</a>. In fact, it is not specified that a Zip file must start in any particular way at all, making it easy to create a file which is both a valid Zip file and a valid file of another format at the same time, a so called <em>polyglot file</em>. For example, a self-extracting Zip file (such as <a href="https://www.hanshq.net/files/pkz204g.exe">pkz204g.exe</a>) is usually both a valid executable and a Zip file: the first part is an executable, and after that follows the Zip file (which the executable extracts). The operating system can run it as an executable, but a Zip program will open it as a Zip file. This ability for Zip files to also be valid executables may have been the motivation for not requiring a signature at the beginning of the file.</p>

<p>While the self-extracting Zip/executable files are clever, polyglots can also cause security problems, as they may trick software that tries to determine the contents of a file, or allow delivering malicious code along with a file of a different type. For example, <a href="https://en.wikipedia.org/wiki/Gifar">GIFARs</a>, files that are both valid GIF images and Java Archives (JARs, a form of Zip file), have been used in security exploits on the web. For more thoughts on these kinds of problems, see Ange Albertini's <a href="https://www.alchemistowl.org/pocorgtfo/pocorgtfo07.pdf">Abusing file formats article</a> (begins on page 18).</p>

<p>As we will see below, Zip files use 32-bit fields for offsets and sizes, limiting the size of the archive and its members to 4 GB. In <a href="https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-4.5.0.txt">Version 4.5 of the Application Note</a>, PKWare added format extensions to allow 64-bit offsets and sizes. Files using those extensions are said to be in Zip64 format, but that is not covered in this article.</p>


<a name="zipstructs"></a>
<h3>Data Structures</h3>

<a name="eocdr"></a>
<h4>End of Central Directory Record</h4>

<p>The EOCDR is normally used as the starting point for reading a Zip file. It contains the location and size of the Central Directory, and an optional comment about the whole archive.</p>

<p>For Zip files spanning multiple floppy disks, or volumes, the EOCDR also contains information about which disk we are currently on, on what disk the Central Directory begins, etc. This functionality is rarely used these days, and the code in this article does not handle such files.</p>

<p>The EOCDR is identified by the signature <span class="code">'P'</span> <span class="code">'K'</span>, followed by the bytes 5 and 6. It then has the following structure, with integers stored in little-endian byte order:</p>

<div class="highlight"><pre><span></span><span class="cm">/* End of Central Directory Record. */</span>
<span class="k">struct</span> <span class="n">eocdr</span> <span class="p">{</span>
        <span class="kt">uint16_t</span> <span class="n">disk_nbr</span><span class="p">;</span>        <span class="cm">/* Number of this disk. */</span>
        <span class="kt">uint16_t</span> <span class="n">cd_start_disk</span><span class="p">;</span>   <span class="cm">/* Nbr. of disk with start of the CD. */</span>
        <span class="kt">uint16_t</span> <span class="n">disk_cd_entries</span><span class="p">;</span> <span class="cm">/* Nbr. of CD entries on this disk. */</span>
        <span class="kt">uint16_t</span> <span class="n">cd_entries</span><span class="p">;</span>      <span class="cm">/* Nbr. of Central Directory entries. */</span>
        <span class="kt">uint32_t</span> <span class="n">cd_size</span><span class="p">;</span>         <span class="cm">/* Central Directory size in bytes. */</span>
        <span class="kt">uint32_t</span> <span class="n">cd_offset</span><span class="p">;</span>       <span class="cm">/* Central Directory file offset. */</span>
        <span class="kt">uint16_t</span> <span class="n">comment_len</span><span class="p">;</span>     <span class="cm">/* Archive comment length. */</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">comment</span><span class="p">;</span>   <span class="cm">/* Archive comment. */</span>
<span class="p">};</span>
</pre></div>


<p>The EOCDR should be located at the end of the file. However, since it can have a trailing comment of arbitrary 16-bit length, we may have to search to find the exact position:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Read 16/32 bits little-endian and bump p forward afterwards. */</span>
<span class="cp">#define READ16(p) ((p) += 2, read16le((p) - 2))
#define READ32(p) ((p) += 4, read32le((p) - 4))</span>

<span class="cm">/* Size of the End of Central Directory Record, not including comment. */</span>
<span class="cp">#define EOCDR_BASE_SZ 22
#define EOCDR_SIGNATURE 0x06054b50  </span><span class="cm">/* "PK\5\6" little-endian. */</span><span class="cp">

#define MAX_BACK_OFFSET (1024 * 100)</span>

<span class="k">static</span> <span class="kt">bool</span> <span class="nf">find_eocdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">eocdr</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">src_len</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">back_offset</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">signature</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">back_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">back_offset</span> <span class="o">&lt;=</span> <span class="n">MAX_BACK_OFFSET</span><span class="p">;</span> <span class="n">back_offset</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">src_len</span> <span class="o">&lt;</span> <span class="n">EOCDR_BASE_SZ</span> <span class="o">+</span> <span class="n">back_offset</span><span class="p">) {</span>
                        <span class="k">break</span><span class="p">;
                }</span>

                <span class="n">p</span> <span class="o">= &amp;</span><span class="n">src</span><span class="p">[</span><span class="n">src_len</span> <span class="o">-</span> <span class="n">EOCDR_BASE_SZ</span> <span class="o">-</span> <span class="n">back_offset</span><span class="p">];</span>
                <span class="n">signature</span> <span class="o">=</span> <span class="n">READ32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">signature</span> <span class="o">==</span> <span class="n">EOCDR_SIGNATURE</span><span class="p">) {</span>
                        <span class="n">r</span><span class="o">-&gt;</span><span class="n">disk_nbr</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
                        <span class="n">r</span><span class="o">-&gt;</span><span class="n">cd_start_disk</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
                        <span class="n">r</span><span class="o">-&gt;</span><span class="n">disk_cd_entries</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
                        <span class="n">r</span><span class="o">-&gt;</span><span class="n">cd_entries</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
                        <span class="n">r</span><span class="o">-&gt;</span><span class="n">cd_size</span> <span class="o">=</span> <span class="n">READ32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
                        <span class="n">r</span><span class="o">-&gt;</span><span class="n">cd_offset</span> <span class="o">=</span> <span class="n">READ32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
                        <span class="n">r</span><span class="o">-&gt;</span><span class="n">comment_len</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
                        <span class="n">r</span><span class="o">-&gt;</span><span class="n">comment</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">p</span> <span class="o">== &amp;</span><span class="n">src</span><span class="p">[</span><span class="n">src_len</span> <span class="o">-</span> <span class="n">back_offset</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
                               <span class="s">"All fields read."</span><span class="p">);</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">comment_len</span> <span class="o">&gt;</span> <span class="n">back_offset</span><span class="p">) {</span>
                                <span class="k">return</span> <span class="nb">false</span><span class="p">;
                        }</span>

                        <span class="k">return</span> <span class="nb">true</span><span class="p">;
                }
        }</span>

        <span class="k">return</span> <span class="nb">false</span><span class="p">;
}</span>
</pre></div>


<p>Writing an EOCDR is straight-forward. The function below does that and returns the number of bytes written.</p>

<div class="highlight"><pre><span></span><span class="cm">/* Write 16/32 bits little-endian and bump p forward afterwards. */</span>
<span class="cp">#define WRITE16(p, x) (write16le((p), (x)), (p) += 2)
#define WRITE32(p, x) (write32le((p), (x)), (p) += 4)</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">write_eocdr</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const struct</span> <span class="n">eocdr</span> <span class="o">*</span><span class="n">r</span><span class="p">)
{</span>
        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>

        <span class="n">WRITE32</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">EOCDR_SIGNATURE</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">disk_nbr</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">cd_start_disk</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">disk_cd_entries</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">cd_entries</span><span class="p">);</span>
        <span class="n">WRITE32</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">cd_size</span><span class="p">);</span>
        <span class="n">WRITE32</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">cd_offset</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">comment_len</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">dst</span> <span class="o">==</span> <span class="n">EOCDR_BASE_SZ</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">comment_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">comment</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">comment_len</span><span class="p">);</span>
                <span class="n">p</span> <span class="o">+=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">comment_len</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">dst</span><span class="p">);
}</span>
</pre></div>



<a name="cfh"></a>
<h4>Central File Header</h4>

<p>The Central Directory consists of Central File Headers written back-to-back, one for each member of the archive. Each header starts with the signature 'P', 'K', 1, 2, and then has the following structure:</p>

<div class="highlight"><pre><span></span><span class="cp">#define EXT_ATTR_DIR (1U &lt;&lt; 4)
#define EXT_ATTR_ARC (1U &lt;&lt; 5)</span>

<span class="cm">/* Central File Header (Central Directory Entry) */</span>
<span class="k">struct</span> <span class="n">cfh</span> <span class="p">{</span>
        <span class="kt">uint16_t</span> <span class="n">made_by_ver</span><span class="p">;</span>    <span class="cm">/* Version made by. */</span>
        <span class="kt">uint16_t</span> <span class="n">extract_ver</span><span class="p">;</span>    <span class="cm">/* Version needed to extract. */</span>
        <span class="kt">uint16_t</span> <span class="n">gp_flag</span><span class="p">;</span>        <span class="cm">/* General-purpose bit flag. */</span>
        <span class="kt">uint16_t</span> <span class="n">method</span><span class="p">;</span>         <span class="cm">/* Compression method. */</span>
        <span class="kt">uint16_t</span> <span class="n">mod_time</span><span class="p">;</span>       <span class="cm">/* Modification time. */</span>
        <span class="kt">uint16_t</span> <span class="n">mod_date</span><span class="p">;</span>       <span class="cm">/* Modification date. */</span>
        <span class="kt">uint32_t</span> <span class="n">crc32</span><span class="p">;</span>          <span class="cm">/* CRC-32 checksum. */</span>
        <span class="kt">uint32_t</span> <span class="n">comp_size</span><span class="p">;</span>      <span class="cm">/* Compressed size. */</span>
        <span class="kt">uint32_t</span> <span class="n">uncomp_size</span><span class="p">;</span>    <span class="cm">/* Uncompressed size. */</span>
        <span class="kt">uint16_t</span> <span class="n">name_len</span><span class="p">;</span>       <span class="cm">/* Filename length. */</span>
        <span class="kt">uint16_t</span> <span class="n">extra_len</span><span class="p">;</span>      <span class="cm">/* Extra data length. */</span>
        <span class="kt">uint16_t</span> <span class="n">comment_len</span><span class="p">;</span>    <span class="cm">/* Comment length. */</span>
        <span class="kt">uint16_t</span> <span class="n">disk_nbr_start</span><span class="p">;</span> <span class="cm">/* Disk nbr. where file begins. */</span>
        <span class="kt">uint16_t</span> <span class="n">int_attrs</span><span class="p">;</span>      <span class="cm">/* Internal file attributes. */</span>
        <span class="kt">uint32_t</span> <span class="n">ext_attrs</span><span class="p">;</span>      <span class="cm">/* External file attributes. */</span>
        <span class="kt">uint32_t</span> <span class="n">lfh_offset</span><span class="p">;</span>     <span class="cm">/* Local File Header offset. */</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>     <span class="cm">/* Filename. */</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">extra</span><span class="p">;</span>    <span class="cm">/* Extra data. */</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">comment</span><span class="p">;</span>  <span class="cm">/* File comment. */</span>
<span class="p">};</span>
</pre></div>


<p><span class="code">made_by_ver</span> and <span class="code">extract_ver</span> encode operating system and version information of the program used to add this member, and what version is required to extract it, respectively. The most significant eight bits encode the operating system (for example, 0 means DOS, 3 Unix, 10 Windows NTFS) and the lower eight bits the software version. We will set that version to decimal 20, indicating compatibility with PKZip 2.0.</p>

<p><span class="code">gp_flag</span> contains various flags. Some interesting ones are bit 0, which indicates whether the member is encrypted (out of scope for this article), and bits 1 and 2 which encode the Deflate compression level (0 for normal, 1 for maximum, 2 for fast, 3 for super fast).</p>

<p><span class="code">method</span> encodes the compression method. Method 0 means the data is uncompressed, method 8 means it is deflated. Other values refer to historic or newer algorithms, but almost all Zip files use only these two values.</p>

<p><span class="code">mod_time</span> and <span class="code">mod_date</span> contain the file's modification date and time, encoded in <a href="http://www.ctyme.com/intr/rb-2992.htm#table1665">MS-DOS date/time format</a>. We use the code below to convert to and from regular C <span class="code">time_t</span> timestamps.</p>

<div class="highlight"><pre><span></span><span class="cm">/* Convert DOS date and time to time_t. */</span>
<span class="k">static</span> <span class="kt">time_t</span> <span class="nf">dos2ctime</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">dos_date</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">dos_time</span><span class="p">)
{</span>
        <span class="k">struct</span> <span class="n">tm tm</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

        <span class="n">tm</span><span class="p">.</span><span class="n">tm_sec</span> <span class="o">=</span> <span class="p">(</span><span class="n">dos_time</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>  <span class="cm">/* Bits 0--4:  Secs divided by 2. */</span>
        <span class="n">tm</span><span class="p">.</span><span class="n">tm_min</span> <span class="o">=</span> <span class="p">(</span><span class="n">dos_time</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span> <span class="cm">/* Bits 5--10: Minute. */</span>
        <span class="n">tm</span><span class="p">.</span><span class="n">tm_hour</span> <span class="o">=</span> <span class="p">(</span><span class="n">dos_time</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">);</span>      <span class="cm">/* Bits 11-15: Hour (0--23). */</span>

        <span class="n">tm</span><span class="p">.</span><span class="n">tm_mday</span> <span class="o">=</span> <span class="p">(</span><span class="n">dos_date</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>          <span class="cm">/* Bits 0--4: Day (1--31). */</span>
        <span class="n">tm</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="p">((</span><span class="n">dos_date</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Bits 5--8: Month (1--12). */</span>
        <span class="n">tm</span><span class="p">.</span><span class="n">tm_year</span> <span class="o">=</span> <span class="p">(</span><span class="n">dos_date</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="mi">80</span><span class="p">;</span>       <span class="cm">/* Bits 9--15: Year-1980. */</span>

        <span class="n">tm</span><span class="p">.</span><span class="n">tm_isdst</span> <span class="o">= -</span><span class="mi">1</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">mktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm</span><span class="p">);
}</span>

<span class="cm">/* Convert time_t to DOS date and time. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ctime2dos</span><span class="p">(</span><span class="kt">time_t</span> <span class="n">t</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">dos_date</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">dos_time</span><span class="p">)
{</span>
        <span class="k">struct</span> <span class="n">tm</span> <span class="o">*</span><span class="n">tm</span> <span class="o">=</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>

        <span class="o">*</span><span class="n">dos_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="o">*</span><span class="n">dos_time</span> <span class="o">|=</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">tm_sec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>    <span class="cm">/* Bits 0--4:  Second divided by two. */</span>
        <span class="o">*</span><span class="n">dos_time</span> <span class="o">|=</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">tm_min</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>   <span class="cm">/* Bits 5--10: Minute. */</span>
        <span class="o">*</span><span class="n">dos_time</span> <span class="o">|=</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">tm_hour</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">;</span> <span class="cm">/* Bits 11-15: Hour. */</span>

        <span class="o">*</span><span class="n">dos_date</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="o">*</span><span class="n">dos_date</span> <span class="o">|=</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">tm_mday</span><span class="p">;</span>             <span class="cm">/* Bits 0--4:  Day (1--31). */</span>
        <span class="o">*</span><span class="n">dos_date</span> <span class="o">|=</span> <span class="p">(</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">tm_mon</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>   <span class="cm">/* Bits 5--8:  Month (1--12). */</span>
        <span class="o">*</span><span class="n">dos_date</span> <span class="o">|=</span> <span class="p">(</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">tm_year</span> <span class="o">-</span> <span class="mi">80</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="cm">/* Bits 9--15: Year from 1980. */</span>
<span class="p">}</span>
</pre></div>


<p>The <span class="code">crc32</span> field contains a <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">cyclic redundancy check</a> value of the uncompressed data. This is used to verify the intergity of the data after extraction. See <a href="https://www.hanshq.net/files/hwzip/crc32.c"><span class="code">crc32.c</span></a> for an implementation.</p>

<p><span class="code">comp_size</span> and <span class="code">uncomp_size</span> contain the compressed and uncompressed size of the member file's data, respectively. The next three fields contain the lengths of the <span class="code">name</span>, <span class="code">comment</span>, and <span class="code">extra</span> data that follow immediately after the header. <span class="code">disk_nbr_start</span> is for archives spanning multiple floppy disks.</p>

<p><span class="code">int_attrs</span> and <span class="code">ext_attrs</span> describe internal and external attributes of the file. Internal attributes pertain to the contents of the file, such as the lowest bit which indicates that it only contains text. The external attributes are such as whether the file is read-only, hidden, etc. The encoding of this field varies by operating system, that is, it depends on <span class="code">made_by_ver</span>. On DOS, the lowest 8 bits contain the file's attributes byte that one would get from an <a href="http://www.ctyme.com/intr/rb-2802.htm">Int 21/AX=4300h</a> system call. For example, bit 4 means it is a directory and bit 5 means the "archive" attribute is set (which is true for most files on DOS). From what I understand, those bits will be set similarly on other operating systems for compatibility. On Unix, the upper 16 bits of this field hold the file mode bits, as returned by <a href="https://linux.die.net/man/2/stat">stat(2)</a> in <span class="code">st_mode</span>.</p>

<p><span class="code">lfh_offset</span> tells us where to find the file's Local File Header, <span class="code">name</span> is the filename (not null terminated), and <span class="code">comment</span> is an optional comment for this archive member (not null terminated). <span class="code">extra</span> can hold optional extra data such as Unix file ownership information, higher resolution modification date and time, or Zip64 fields.</p>

<p>The functions below are used to read and write CFHs.</p>

<div class="highlight"><pre><span></span><span class="cm">/* Size of a Central File Header, not including name, extra, and comment. */</span>
<span class="cp">#define CFH_BASE_SZ 46
#define CFH_SIGNATURE 0x02014b50 </span><span class="cm">/* "PK\1\2" little-endian. */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">bool</span> <span class="nf">read_cfh</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfh</span> <span class="o">*</span><span class="n">cfh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">src_len</span><span class="p">,</span>
                     <span class="kt">size_t</span> <span class="n">offset</span><span class="p">)
{</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">signature</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">src_len</span> <span class="o">||</span> <span class="n">src_len</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">CFH_BASE_SZ</span><span class="p">) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="n">p</span> <span class="o">= &amp;</span><span class="n">src</span><span class="p">[</span><span class="n">offset</span><span class="p">];</span>
        <span class="n">signature</span> <span class="o">=</span> <span class="n">READ32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">signature</span> <span class="o">!=</span> <span class="n">CFH_SIGNATURE</span><span class="p">) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">made_by_ver</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">extract_ver</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">gp_flag</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">method</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">mod_time</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">mod_date</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">crc32</span> <span class="o">=</span> <span class="n">READ32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">comp_size</span> <span class="o">=</span> <span class="n">READ32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">uncomp_size</span> <span class="o">=</span> <span class="n">READ32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">extra_len</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">comment_len</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">disk_nbr_start</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">int_attrs</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">ext_attrs</span> <span class="o">=</span> <span class="n">READ32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">lfh_offset</span> <span class="o">=</span> <span class="n">READ32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">extra</span> <span class="o">=</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">+</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">;</span>
        <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">comment</span> <span class="o">=</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">extra</span> <span class="o">+</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">extra_len</span><span class="p">;</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">p</span> <span class="o">== &amp;</span><span class="n">src</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">CFH_BASE_SZ</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="s">"All fields read."</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">src_len</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">CFH_BASE_SZ</span> <span class="o">&lt;</span>
            <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">cfh</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">+</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">extra_len</span> <span class="o">+</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">comment_len</span><span class="p">) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">write_cfh</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const struct</span> <span class="n">cfh</span> <span class="o">*</span><span class="n">cfh</span><span class="p">)
{</span>
        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>

        <span class="n">WRITE32</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">CFH_SIGNATURE</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">made_by_ver</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">extract_ver</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">gp_flag</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">method</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">mod_time</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">mod_date</span><span class="p">);</span>
        <span class="n">WRITE32</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">crc32</span><span class="p">);</span>
        <span class="n">WRITE32</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">comp_size</span><span class="p">);</span>
        <span class="n">WRITE32</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">uncomp_size</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">extra_len</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">comment_len</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">disk_nbr_start</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">int_attrs</span><span class="p">);</span>
        <span class="n">WRITE32</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">ext_attrs</span><span class="p">);</span>
        <span class="n">WRITE32</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">lfh_offset</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">dst</span> <span class="o">==</span> <span class="n">CFH_BASE_SZ</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">cfh</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">);</span>
                <span class="n">p</span> <span class="o">+=</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">cfh</span><span class="o">-&gt;</span><span class="n">extra_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">extra_len</span><span class="p">);</span>
                <span class="n">p</span> <span class="o">+=</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">extra_len</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">cfh</span><span class="o">-&gt;</span><span class="n">comment_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">comment</span><span class="p">,</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">comment_len</span><span class="p">);</span>
                <span class="n">p</span> <span class="o">+=</span> <span class="n">cfh</span><span class="o">-&gt;</span><span class="n">comment_len</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">dst</span><span class="p">);
}</span>
</pre></div>



<a name="lfh"></a>
<h4>Local File Header</h4>

<p>The data of each archive member is preceded by a Local File Header, which repeats most of the information from the Central File Header.</p>

<p>This redundancy between the central and local file headers was perhaps designed in order to allow PKZip not to have to keep the entire central directory in memory during extraction. Instead, as each file was extracted, the names and other information could be read from the local headers. Additionally, the local headers can be useful for recovering files from a Zip archive where the central directory is missing or corrupted. However, this redundancy is also a major source of ambiguity. For example, what happens when the filenames in the central and local headers mismatch? Such ambiguities often lead to bugs and security problems.</p>

<p>Not everything from the Central File Header is replicated, though. For example, there are no fields for the file's attributes. Also, if the third least significant bit of <span class="code">gp_flags</span> is set, the CRC-32, compressed and uncompressed size fields will be set to zero, and that information will instead be found in a <em>Data Descriptor</em> block after the file's data (not covered here). This allows writing the LFH before knowing how large the member file is or what size it will compress to.</p>

<p>The Local File Header starts with the signature 'P', 'K', 3, 4, and then has the following structure:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Local File Header. */</span>
<span class="k">struct</span> <span class="n">lfh</span> <span class="p">{</span>
        <span class="kt">uint16_t</span> <span class="n">extract_ver</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">gp_flag</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">method</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">mod_time</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">mod_date</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">crc32</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">comp_size</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">uncomp_size</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">name_len</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">extra_len</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">extra</span><span class="p">;
};</span>
</pre></div>


<p>The functions below read and write LFHs similarly to the other data structures:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Size of a Local File Header, not including name and extra. */</span>
<span class="cp">#define LFH_BASE_SZ 30
#define LFH_SIGNATURE 0x04034b50 </span><span class="cm">/* "PK\3\4" little-endian. */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">bool</span> <span class="nf">read_lfh</span><span class="p">(</span><span class="k">struct</span> <span class="n">lfh</span> <span class="o">*</span><span class="n">lfh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">src_len</span><span class="p">,</span>
                     <span class="kt">size_t</span> <span class="n">offset</span><span class="p">)
{</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">signature</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">src_len</span> <span class="o">||</span> <span class="n">src_len</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">LFH_BASE_SZ</span><span class="p">) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="n">p</span> <span class="o">= &amp;</span><span class="n">src</span><span class="p">[</span><span class="n">offset</span><span class="p">];</span>
        <span class="n">signature</span> <span class="o">=</span> <span class="n">READ32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">signature</span> <span class="o">!=</span> <span class="n">LFH_SIGNATURE</span><span class="p">) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">extract_ver</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">gp_flag</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">method</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">mod_time</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">mod_date</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">crc32</span> <span class="o">=</span> <span class="n">READ32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">comp_size</span> <span class="o">=</span> <span class="n">READ32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">uncomp_size</span> <span class="o">=</span> <span class="n">READ32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">extra_len</span> <span class="o">=</span> <span class="n">READ16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">extra</span> <span class="o">=</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">+</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">;</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">p</span> <span class="o">== &amp;</span><span class="n">src</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">LFH_BASE_SZ</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="s">"All fields read."</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">src_len</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">LFH_BASE_SZ</span> <span class="o">&lt;</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">+</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">extra_len</span><span class="p">) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">write_lfh</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const struct</span> <span class="n">lfh</span> <span class="o">*</span><span class="n">lfh</span><span class="p">)
{</span>
        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>

        <span class="n">WRITE32</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">LFH_SIGNATURE</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">extract_ver</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">gp_flag</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">method</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">mod_time</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">mod_date</span><span class="p">);</span>
        <span class="n">WRITE32</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">crc32</span><span class="p">);</span>
        <span class="n">WRITE32</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">comp_size</span><span class="p">);</span>
        <span class="n">WRITE32</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">uncomp_size</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">);</span>
        <span class="n">WRITE16</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">extra_len</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">dst</span> <span class="o">==</span> <span class="n">LFH_BASE_SZ</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">lfh</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">);</span>
                <span class="n">p</span> <span class="o">+=</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">lfh</span><span class="o">-&gt;</span><span class="n">extra_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">,</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">extra_len</span><span class="p">);</span>
                <span class="n">p</span> <span class="o">+=</span> <span class="n">lfh</span><span class="o">-&gt;</span><span class="n">extra_len</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">dst</span><span class="p">);
}</span>
</pre></div>


<a name="zipreader"></a>
<h3>Zip Reader Implementation</h3>

<p>Using the functions above, we provide a function to read a Zip file in memory and get an iterator for accessing the members:</p>

<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="kt">size_t</span> <span class="n">zipiter_t</span><span class="p">;</span> <span class="cm">/* Zip archive member iterator. */</span>

<span class="k">typedef struct</span> <span class="n">zip_t zip_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">zip_t</span> <span class="p">{</span>
        <span class="kt">uint16_t</span> <span class="n">num_members</span><span class="p">;</span>    <span class="cm">/* Number of members. */</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">comment</span><span class="p">;</span>  <span class="cm">/* Zip file comment (not terminated). */</span>
        <span class="kt">uint16_t</span> <span class="n">comment_len</span><span class="p">;</span>    <span class="cm">/* Zip file comment length. */</span>
        <span class="n">zipiter_t members_begin</span><span class="p">;</span> <span class="cm">/* Iterator to the first member. */</span>
        <span class="n">zipiter_t members_end</span><span class="p">;</span>   <span class="cm">/* Iterator to the end of members. */</span>

        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">src_len</span><span class="p">;
};</span>

<span class="cm">/* Initialize zip based on the source data. Returns true on success, or false
   if the data could not be parsed as a valid Zip file. */</span>
<span class="kt">bool</span> <span class="nf">zip_read</span><span class="p">(</span><span class="n">zip_t</span> <span class="o">*</span><span class="n">zip</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">src_len</span><span class="p">)
{</span>
        <span class="k">struct</span> <span class="n">eocdr eocdr</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">cfh cfh</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">lfh lfh</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">comp_data</span><span class="p">;</span>

        <span class="n">zip</span><span class="o">-&gt;</span><span class="n">src</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
        <span class="n">zip</span><span class="o">-&gt;</span><span class="n">src_len</span> <span class="o">=</span> <span class="n">src_len</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">find_eocdr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eocdr</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">src_len</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">eocdr</span><span class="p">.</span><span class="n">disk_nbr</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">eocdr</span><span class="p">.</span><span class="n">cd_start_disk</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
            <span class="n">eocdr</span><span class="p">.</span><span class="n">disk_cd_entries</span> <span class="o">!=</span> <span class="n">eocdr</span><span class="p">.</span><span class="n">cd_entries</span><span class="p">) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* Cannot handle multi-volume archives. */</span>
        <span class="p">}</span>

        <span class="n">zip</span><span class="o">-&gt;</span><span class="n">num_members</span> <span class="o">=</span> <span class="n">eocdr</span><span class="p">.</span><span class="n">cd_entries</span><span class="p">;</span>
        <span class="n">zip</span><span class="o">-&gt;</span><span class="n">comment</span> <span class="o">=</span> <span class="n">eocdr</span><span class="p">.</span><span class="n">comment</span><span class="p">;</span>
        <span class="n">zip</span><span class="o">-&gt;</span><span class="n">comment_len</span> <span class="o">=</span> <span class="n">eocdr</span><span class="p">.</span><span class="n">comment_len</span><span class="p">;</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">eocdr</span><span class="p">.</span><span class="n">cd_offset</span><span class="p">;</span>
        <span class="n">zip</span><span class="o">-&gt;</span><span class="n">members_begin</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

        <span class="cm">/* Read the member info and do a few checks. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">eocdr</span><span class="p">.</span><span class="n">cd_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_cfh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfh</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">src_len</span><span class="p">,</span> <span class="n">offset</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">cfh</span><span class="p">.</span><span class="n">gp_flag</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* The member is encrypted. */</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cfh</span><span class="p">.</span><span class="n">method</span> <span class="o">!=</span> <span class="n">ZIP_STORE</span>   <span class="o">&amp;&amp;</span>
                    <span class="n">cfh</span><span class="p">.</span><span class="n">method</span> <span class="o">!=</span> <span class="n">ZIP_SHRINK</span>  <span class="o">&amp;&amp;</span>
                    <span class="n">cfh</span><span class="p">.</span><span class="n">method</span> <span class="o">!=</span> <span class="n">ZIP_REDUCE1</span> <span class="o">&amp;&amp;</span>
                    <span class="n">cfh</span><span class="p">.</span><span class="n">method</span> <span class="o">!=</span> <span class="n">ZIP_REDUCE2</span> <span class="o">&amp;&amp;</span>
                    <span class="n">cfh</span><span class="p">.</span><span class="n">method</span> <span class="o">!=</span> <span class="n">ZIP_REDUCE3</span> <span class="o">&amp;&amp;</span>
                    <span class="n">cfh</span><span class="p">.</span><span class="n">method</span> <span class="o">!=</span> <span class="n">ZIP_REDUCE4</span> <span class="o">&amp;&amp;</span>
                    <span class="n">cfh</span><span class="p">.</span><span class="n">method</span> <span class="o">!=</span> <span class="n">ZIP_IMPLODE</span> <span class="o">&amp;&amp;</span>
                    <span class="n">cfh</span><span class="p">.</span><span class="n">method</span> <span class="o">!=</span> <span class="n">ZIP_DEFLATE</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* Unsupported compression method. */</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cfh</span><span class="p">.</span><span class="n">method</span> <span class="o">==</span> <span class="n">ZIP_STORE</span> <span class="o">&amp;&amp;</span>
                    <span class="n">cfh</span><span class="p">.</span><span class="n">uncomp_size</span> <span class="o">!=</span> <span class="n">cfh</span><span class="p">.</span><span class="n">comp_size</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cfh</span><span class="p">.</span><span class="n">disk_nbr_start</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* Cannot handle multi-volume archives. */</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">memchr</span><span class="p">(</span><span class="n">cfh</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="sc">'\0'</span><span class="p">,</span> <span class="n">cfh</span><span class="p">.</span><span class="n">name_len</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* Bad filename. */</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_lfh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lfh</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">src_len</span><span class="p">,</span> <span class="n">cfh</span><span class="p">.</span><span class="n">lfh_offset</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>

                <span class="n">comp_data</span> <span class="o">=</span> <span class="n">lfh</span><span class="p">.</span><span class="n">extra</span> <span class="o">+</span> <span class="n">lfh</span><span class="p">.</span><span class="n">extra_len</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cfh</span><span class="p">.</span><span class="n">comp_size</span> <span class="o">&gt;</span> <span class="n">src_len</span> <span class="o">-</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">comp_data</span> <span class="o">-</span> <span class="n">src</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* Member data does not fit in src. */</span>
                <span class="p">}</span>

                <span class="n">offset</span> <span class="o">+=</span> <span class="n">CFH_BASE_SZ</span> <span class="o">+</span> <span class="n">cfh</span><span class="p">.</span><span class="n">name_len</span> <span class="o">+</span> <span class="n">cfh</span><span class="p">.</span><span class="n">extra_len</span> <span class="o">+</span>
                          <span class="n">cfh</span><span class="p">.</span><span class="n">comment_len</span><span class="p">;
        }</span>

        <span class="n">zip</span><span class="o">-&gt;</span><span class="n">members_end</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<p>As hinted at above, member iterators are really just Central File Header offsets, through which the members data can be accessed:</p>

<div class="highlight"><pre><span></span><span class="k">typedef enum</span> <span class="p">{</span>
        <span class="n">ZIP_STORE</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">ZIP_SHRINK</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">ZIP_REDUCE1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">ZIP_REDUCE2</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">ZIP_REDUCE3</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">ZIP_REDUCE4</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">ZIP_IMPLODE</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
        <span class="n">ZIP_DEFLATE</span> <span class="o">=</span> <span class="mi">8</span>
<span class="p">}</span> <span class="n">method_t</span><span class="p">;</span>

<span class="k">typedef struct</span> <span class="n">zipmemb_t zipmemb_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">zipmemb_t</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>      <span class="cm">/* Member name (not null terminated). */</span>
        <span class="kt">uint16_t</span> <span class="n">name_len</span><span class="p">;</span>        <span class="cm">/* Member name length. */</span>
        <span class="kt">time_t</span> <span class="n">mtime</span><span class="p">;</span>             <span class="cm">/* Modification time. */</span>
        <span class="kt">uint32_t</span> <span class="n">comp_size</span><span class="p">;</span>       <span class="cm">/* Compressed size. */</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">comp_data</span><span class="p">;</span> <span class="cm">/* Compressed data. */</span>
        <span class="kt">uint16_t</span> <span class="n">made_by_ver</span><span class="p">;</span>     <span class="cm">/* Made-by version, e.g. 20 for PKZip 2.0. */</span>
        <span class="n">method_t method</span><span class="p">;</span>          <span class="cm">/* Compression method. */</span>
        <span class="kt">bool</span> <span class="n">imp_large_wnd</span><span class="p">;</span>       <span class="cm">/* For implode: compressed with 8K window? */</span>
        <span class="kt">bool</span> <span class="n">imp_lit_tree</span><span class="p">;</span>        <span class="cm">/* For implode: Huffman coded literals? */</span>
        <span class="kt">uint32_t</span> <span class="n">uncomp_size</span><span class="p">;</span>     <span class="cm">/* Uncompressed size. */</span>
        <span class="kt">uint32_t</span> <span class="n">crc32</span><span class="p">;</span>           <span class="cm">/* CRC-32 checksum. */</span>
        <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">comment</span><span class="p">;</span>   <span class="cm">/* Comment (not null terminated). */</span>
        <span class="kt">uint16_t</span> <span class="n">comment_len</span><span class="p">;</span>     <span class="cm">/* Comment length. */</span>
        <span class="kt">bool</span> <span class="n">is_dir</span><span class="p">;</span>              <span class="cm">/* Whether this is a directory. */</span>
        <span class="n">zipiter_t next</span><span class="p">;</span>           <span class="cm">/* Iterator to the next member. */</span>
<span class="p">};</span>

<span class="cm">/* Get the Zip archive member through iterator it. */</span>
<span class="n">zipmemb_t</span> <span class="nf">zip_member</span><span class="p">(</span><span class="k">const</span> <span class="n">zip_t</span> <span class="o">*</span><span class="n">zip</span><span class="p">,</span> <span class="n">zipiter_t it</span><span class="p">)
{</span>
        <span class="k">struct</span> <span class="n">cfh cfh</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">lfh lfh</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">ok</span><span class="p">;</span>
        <span class="n">zipmemb_t m</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">it</span> <span class="o">&gt;=</span> <span class="n">zip</span><span class="o">-&gt;</span><span class="n">members_begin</span> <span class="o">&amp;&amp;</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="n">zip</span><span class="o">-&gt;</span><span class="n">members_end</span><span class="p">);</span>

        <span class="n">ok</span> <span class="o">=</span> <span class="n">read_cfh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfh</span><span class="p">,</span> <span class="n">zip</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span> <span class="n">zip</span><span class="o">-&gt;</span><span class="n">src_len</span><span class="p">,</span> <span class="n">it</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">ok</span><span class="p">);</span>

        <span class="n">ok</span> <span class="o">=</span> <span class="n">read_lfh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lfh</span><span class="p">,</span> <span class="n">zip</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span> <span class="n">zip</span><span class="o">-&gt;</span><span class="n">src_len</span><span class="p">,</span> <span class="n">cfh</span><span class="p">.</span><span class="n">lfh_offset</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">ok</span><span class="p">);</span>

        <span class="n">m</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">cfh</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
        <span class="n">m</span><span class="p">.</span><span class="n">name_len</span> <span class="o">=</span> <span class="n">cfh</span><span class="p">.</span><span class="n">name_len</span><span class="p">;</span>
        <span class="n">m</span><span class="p">.</span><span class="n">mtime</span> <span class="o">=</span> <span class="n">dos2ctime</span><span class="p">(</span><span class="n">cfh</span><span class="p">.</span><span class="n">mod_date</span><span class="p">,</span> <span class="n">cfh</span><span class="p">.</span><span class="n">mod_time</span><span class="p">);</span>
        <span class="n">m</span><span class="p">.</span><span class="n">comp_size</span> <span class="o">=</span> <span class="n">cfh</span><span class="p">.</span><span class="n">comp_size</span><span class="p">;</span>
        <span class="n">m</span><span class="p">.</span><span class="n">comp_data</span> <span class="o">=</span> <span class="n">lfh</span><span class="p">.</span><span class="n">extra</span> <span class="o">+</span> <span class="n">lfh</span><span class="p">.</span><span class="n">extra_len</span><span class="p">;</span>
        <span class="n">m</span><span class="p">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">cfh</span><span class="p">.</span><span class="n">method</span><span class="p">;</span>
        <span class="n">m</span><span class="p">.</span><span class="n">made_by_ver</span> <span class="o">=</span> <span class="n">cfh</span><span class="p">.</span><span class="n">made_by_ver</span><span class="p">;</span>
        <span class="n">m</span><span class="p">.</span><span class="n">imp_large_wnd</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">method</span> <span class="o">==</span> <span class="n">ZIP_IMPLODE</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">cfh</span><span class="p">.</span><span class="n">gp_flag</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">m</span><span class="p">.</span><span class="n">imp_lit_tree</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">method</span> <span class="o">==</span> <span class="n">ZIP_IMPLODE</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">cfh</span><span class="p">.</span><span class="n">gp_flag</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">m</span><span class="p">.</span><span class="n">uncomp_size</span> <span class="o">=</span> <span class="n">cfh</span><span class="p">.</span><span class="n">uncomp_size</span><span class="p">;</span>
        <span class="n">m</span><span class="p">.</span><span class="n">crc32</span> <span class="o">=</span> <span class="n">cfh</span><span class="p">.</span><span class="n">crc32</span><span class="p">;</span>
        <span class="n">m</span><span class="p">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">cfh</span><span class="p">.</span><span class="n">comment</span><span class="p">;</span>
        <span class="n">m</span><span class="p">.</span><span class="n">comment_len</span> <span class="o">=</span> <span class="n">cfh</span><span class="p">.</span><span class="n">comment_len</span><span class="p">;</span>
        <span class="n">m</span><span class="p">.</span><span class="n">is_dir</span> <span class="o">=</span> <span class="p">(</span><span class="n">cfh</span><span class="p">.</span><span class="n">ext_attrs</span> <span class="o">&amp;</span> <span class="n">EXT_ATTR_DIR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">m</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">it</span> <span class="o">+</span> <span class="n">CFH_BASE_SZ</span> <span class="o">+</span>
                 <span class="n">cfh</span><span class="p">.</span><span class="n">name_len</span> <span class="o">+</span> <span class="n">cfh</span><span class="p">.</span><span class="n">extra_len</span> <span class="o">+</span> <span class="n">cfh</span><span class="p">.</span><span class="n">comment_len</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">next</span> <span class="o">&lt;=</span> <span class="n">zip</span><span class="o">-&gt;</span><span class="n">members_end</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">m</span><span class="p">;
}</span>
</pre></div>



<a name="zipwriter"></a>
<h3>Zip Writer Implementation</h3>

<p>To write a Zip file into a memory buffer, we first need to know how much memory to allocate. Since we do not know how much the data will compress before we try it, we calculate an upper bound by using the uncompressed member sizes:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Compute an upper bound on the dst size required by zip_write() for an
 * archive with num_memb members with certain filenames, sizes, and archive
 * comment. Returns zero on error, e.g. if a filename is longer than 2^16-1, or
 * if the total file size is larger than 2^32-1. */</span>
<span class="kt">uint32_t</span> <span class="nf">zip_max_size</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">num_memb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="o">*</span><span class="n">filenames</span><span class="p">,</span>
                      <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">file_sizes</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">comment</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">comment_len</span><span class="p">,</span> <span class="n">name_len</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">total</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">i</span><span class="p">;</span>

        <span class="n">comment_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">comment</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">strlen</span><span class="p">(</span><span class="n">comment</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">comment_len</span> <span class="o">&gt;</span> <span class="n">UINT16_MAX</span><span class="p">) {</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;
        }</span>

        <span class="n">total</span> <span class="o">=</span> <span class="n">EOCDR_BASE_SZ</span> <span class="o">+</span> <span class="n">comment_len</span><span class="p">;</span> <span class="cm">/* EOCDR */</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_memb</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">filenames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
                <span class="n">name_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">filenames</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name_len</span> <span class="o">&gt;</span> <span class="n">UINT16_MAX</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="mi">0</span><span class="p">;
                }</span>

                <span class="n">total</span> <span class="o">+=</span> <span class="n">CFH_BASE_SZ</span> <span class="o">+</span> <span class="n">name_len</span><span class="p">;</span> <span class="cm">/* Central File Header */</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">LFH_BASE_SZ</span> <span class="o">+</span> <span class="n">name_len</span><span class="p">;</span> <span class="cm">/* Local File Header */</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">file_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>          <span class="cm">/* Uncompressed data size. */</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="n">UINT32_MAX</span><span class="p">) {</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">total</span><span class="p">;
}</span>
</pre></div>


<p>The code below writes a Zip file using Deflate compression for each member where that yields a smaller size:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Write a Zip file containing num_memb members into dst, which must be large
   enough to hold the resulting data. Returns the number of bytes written, which
   is guaranteed to be less than or equal to the result of zip_max_size() when
   called with the corresponding arguments. comment shall be a null-terminated
   string or null. callback shall be null or point to a function which will
   get called after the compression of each member. */</span>
<span class="kt">uint32_t</span> <span class="nf">zip_write</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">num_memb</span><span class="p">,</span>
                   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="o">*</span><span class="n">filenames</span><span class="p">,</span>
                   <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="k">const</span> <span class="o">*</span><span class="n">file_data</span><span class="p">,</span>
                   <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">file_sizes</span><span class="p">,</span>
                   <span class="k">const</span> <span class="kt">time_t</span> <span class="o">*</span><span class="n">mtimes</span><span class="p">,</span>
                   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">comment</span><span class="p">,</span>
                   <span class="n">method_t method</span><span class="p">,</span>
                   <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="n">method_t method</span><span class="p">,</span>
                                    <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">comp_size</span><span class="p">))
{</span>
        <span class="kt">uint16_t</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">eocdr eocdr</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">cfh cfh</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">lfh lfh</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">ok</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">name_len</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data_dst</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">data_dst_sz</span><span class="p">,</span> <span class="n">comp_sz</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">lfh_offset</span><span class="p">,</span> <span class="n">cd_offset</span><span class="p">,</span> <span class="n">eocdr_offset</span><span class="p">;</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>

        <span class="cm">/* Write Local File Headers and compressed or stored data. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_memb</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">filenames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">filenames</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">UINT16_MAX</span><span class="p">);</span>
                <span class="n">name_len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">strlen</span><span class="p">(</span><span class="n">filenames</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

                <span class="n">data_dst</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">LFH_BASE_SZ</span> <span class="o">+</span> <span class="n">name_len</span><span class="p">;</span>
                <span class="n">data_dst_sz</span> <span class="o">=</span> <span class="p">(</span><span class="n">file_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">file_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="n">ZIP_SHRINK</span> <span class="o">&amp;&amp;</span> <span class="n">file_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
                    <span class="n">hwshrink</span><span class="p">(</span><span class="n">file_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">file_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                             <span class="n">data_dst</span><span class="p">,</span> <span class="n">data_dst_sz</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comp_sz</span><span class="p">)) {</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">ZIP_SHRINK</span><span class="p">;</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">comp_sz</span> <span class="o">&lt;=</span> <span class="n">UINT32_MAX</span><span class="p">);</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">comp_size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">comp_sz</span><span class="p">;</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">gp_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">extract_ver</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mi">10</span><span class="p">;</span> <span class="cm">/* DOS | PKZip 1.0 */</span>
                <span class="p">}</span> <span class="k">else if</span> <span class="p">(</span><span class="n">method</span> <span class="o">&gt;=</span> <span class="n">ZIP_REDUCE1</span> <span class="o">&amp;&amp;</span> <span class="n">method</span> <span class="o">&lt;=</span> <span class="n">ZIP_REDUCE4</span> <span class="o">&amp;&amp;</span>
                           <span class="n">hwreduce</span><span class="p">(</span><span class="n">file_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">file_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">],
                           (</span><span class="kt">int</span><span class="p">)(</span><span class="n">method</span> <span class="o">-</span> <span class="n">ZIP_REDUCE1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                           <span class="n">data_dst</span><span class="p">,</span> <span class="n">data_dst_sz</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comp_sz</span><span class="p">)) {</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">method</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">method</span><span class="p">;</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">comp_sz</span> <span class="o">&lt;=</span> <span class="n">UINT32_MAX</span><span class="p">);</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">comp_size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">comp_sz</span><span class="p">;</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">gp_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">extract_ver</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mi">10</span><span class="p">;</span> <span class="cm">/* DOS | PKZip 1.0 */</span>
                <span class="p">}</span> <span class="k">else if</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="n">ZIP_IMPLODE</span> <span class="o">&amp;&amp;</span>
                           <span class="n">hwimplode</span><span class="p">(</span><span class="n">file_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">file_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                     <span class="cm">/*large_wnd=*/</span><span class="nb">true</span><span class="p">,</span> <span class="cm">/*lit_tree=*/</span><span class="nb">true</span><span class="p">,</span>
                                     <span class="n">data_dst</span><span class="p">,</span> <span class="n">data_dst_sz</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comp_sz</span><span class="p">)) {</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">ZIP_IMPLODE</span><span class="p">;</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">comp_sz</span> <span class="o">&lt;=</span> <span class="n">UINT32_MAX</span><span class="p">);</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">comp_size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">comp_sz</span><span class="p">;</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">gp_flag</span>  <span class="o">=</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* large_wnd */</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">gp_flag</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span> <span class="cm">/* lit_tree */</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">extract_ver</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mi">10</span><span class="p">;</span> <span class="cm">/* DOS | PKZip 1.0 */</span>
                <span class="p">}</span> <span class="k">else if</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="n">ZIP_DEFLATE</span> <span class="o">&amp;&amp;</span>
                           <span class="n">hwdeflate</span><span class="p">(</span><span class="n">file_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">file_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                     <span class="n">data_dst</span><span class="p">,</span> <span class="n">data_dst_sz</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comp_sz</span><span class="p">)) {</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">ZIP_DEFLATE</span><span class="p">;</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">comp_sz</span> <span class="o">&lt;=</span> <span class="n">UINT32_MAX</span><span class="p">);</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">comp_size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">comp_sz</span><span class="p">;</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">gp_flag</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">extract_ver</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mi">20</span><span class="p">;</span> <span class="cm">/* DOS | PKZip 2.0 */</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">memcpy</span><span class="p">(</span><span class="n">data_dst</span><span class="p">,</span> <span class="n">file_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">file_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">ZIP_STORE</span><span class="p">;</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">comp_size</span> <span class="o">=</span> <span class="n">file_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">gp_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                        <span class="n">lfh</span><span class="p">.</span><span class="n">extract_ver</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mi">10</span><span class="p">;</span> <span class="cm">/* DOS | PKZip 1.0 */</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">callback</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">) {</span>
                        <span class="n">callback</span><span class="p">(</span><span class="n">filenames</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lfh</span><span class="p">.</span><span class="n">method</span><span class="p">,</span>
                                 <span class="n">file_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lfh</span><span class="p">.</span><span class="n">comp_size</span><span class="p">);
                }</span>

                <span class="n">ctime2dos</span><span class="p">(</span><span class="n">mtimes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">lfh</span><span class="p">.</span><span class="n">mod_date</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lfh</span><span class="p">.</span><span class="n">mod_time</span><span class="p">);</span>
                <span class="n">lfh</span><span class="p">.</span><span class="n">crc32</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">file_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">file_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="n">lfh</span><span class="p">.</span><span class="n">uncomp_size</span> <span class="o">=</span> <span class="n">file_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">lfh</span><span class="p">.</span><span class="n">name_len</span> <span class="o">=</span> <span class="n">name_len</span><span class="p">;</span>
                <span class="n">lfh</span><span class="p">.</span><span class="n">extra_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">lfh</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">filenames</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">p</span> <span class="o">+=</span> <span class="n">write_lfh</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lfh</span><span class="p">);</span>
                <span class="n">p</span> <span class="o">+=</span> <span class="n">lfh</span><span class="p">.</span><span class="n">comp_size</span><span class="p">;
        }</span>

        <span class="n">assert</span><span class="p">((</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">dst</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">UINT32_MAX</span><span class="p">);</span>
        <span class="n">cd_offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">dst</span><span class="p">);</span>

        <span class="cm">/* Write the Central Directory based on the Local File Headers. */</span>
        <span class="n">lfh_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_memb</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="n">read_lfh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lfh</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">SIZE_MAX</span><span class="p">,</span> <span class="n">lfh_offset</span><span class="p">);</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">ok</span><span class="p">);</span>

                <span class="n">cfh</span><span class="p">.</span><span class="n">made_by_ver</span> <span class="o">=</span> <span class="n">lfh</span><span class="p">.</span><span class="n">extract_ver</span><span class="p">;</span>
                <span class="n">cfh</span><span class="p">.</span><span class="n">extract_ver</span> <span class="o">=</span> <span class="n">lfh</span><span class="p">.</span><span class="n">extract_ver</span><span class="p">;</span>
                <span class="n">cfh</span><span class="p">.</span><span class="n">gp_flag</span> <span class="o">=</span> <span class="n">lfh</span><span class="p">.</span><span class="n">gp_flag</span><span class="p">;</span>
                <span class="n">cfh</span><span class="p">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">lfh</span><span class="p">.</span><span class="n">method</span><span class="p">;</span>
                <span class="n">cfh</span><span class="p">.</span><span class="n">mod_time</span> <span class="o">=</span> <span class="n">lfh</span><span class="p">.</span><span class="n">mod_time</span><span class="p">;</span>
                <span class="n">cfh</span><span class="p">.</span><span class="n">mod_date</span> <span class="o">=</span> <span class="n">lfh</span><span class="p">.</span><span class="n">mod_date</span><span class="p">;</span>
                <span class="n">cfh</span><span class="p">.</span><span class="n">crc32</span> <span class="o">=</span> <span class="n">lfh</span><span class="p">.</span><span class="n">crc32</span><span class="p">;</span>
                <span class="n">cfh</span><span class="p">.</span><span class="n">comp_size</span> <span class="o">=</span> <span class="n">lfh</span><span class="p">.</span><span class="n">comp_size</span><span class="p">;</span>
                <span class="n">cfh</span><span class="p">.</span><span class="n">uncomp_size</span> <span class="o">=</span> <span class="n">lfh</span><span class="p">.</span><span class="n">uncomp_size</span><span class="p">;</span>
                <span class="n">cfh</span><span class="p">.</span><span class="n">name_len</span> <span class="o">=</span> <span class="n">lfh</span><span class="p">.</span><span class="n">name_len</span><span class="p">;</span>
                <span class="n">cfh</span><span class="p">.</span><span class="n">extra_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">cfh</span><span class="p">.</span><span class="n">comment_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">cfh</span><span class="p">.</span><span class="n">disk_nbr_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">cfh</span><span class="p">.</span><span class="n">int_attrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">cfh</span><span class="p">.</span><span class="n">ext_attrs</span> <span class="o">=</span> <span class="n">EXT_ATTR_ARC</span><span class="p">;</span>
                <span class="n">cfh</span><span class="p">.</span><span class="n">lfh_offset</span> <span class="o">=</span> <span class="n">lfh_offset</span><span class="p">;</span>
                <span class="n">cfh</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">lfh</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
                <span class="n">p</span> <span class="o">+=</span> <span class="n">write_cfh</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfh</span><span class="p">);</span>

                <span class="n">lfh_offset</span> <span class="o">+=</span> <span class="n">LFH_BASE_SZ</span> <span class="o">+</span> <span class="n">lfh</span><span class="p">.</span><span class="n">name_len</span> <span class="o">+</span> <span class="n">lfh</span><span class="p">.</span><span class="n">comp_size</span><span class="p">;
        }</span>

        <span class="n">assert</span><span class="p">((</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">dst</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">UINT32_MAX</span><span class="p">);</span>
        <span class="n">eocdr_offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">dst</span><span class="p">);</span>

        <span class="cm">/* Write the End of Central Directory Record. */</span>
        <span class="n">eocdr</span><span class="p">.</span><span class="n">disk_nbr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">eocdr</span><span class="p">.</span><span class="n">cd_start_disk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">eocdr</span><span class="p">.</span><span class="n">disk_cd_entries</span> <span class="o">=</span> <span class="n">num_memb</span><span class="p">;</span>
        <span class="n">eocdr</span><span class="p">.</span><span class="n">cd_entries</span> <span class="o">=</span> <span class="n">num_memb</span><span class="p">;</span>
        <span class="n">eocdr</span><span class="p">.</span><span class="n">cd_size</span> <span class="o">=</span> <span class="n">eocdr_offset</span> <span class="o">-</span> <span class="n">cd_offset</span><span class="p">;</span>
        <span class="n">eocdr</span><span class="p">.</span><span class="n">cd_offset</span> <span class="o">=</span> <span class="n">cd_offset</span><span class="p">;</span>
        <span class="n">eocdr</span><span class="p">.</span><span class="n">comment_len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="n">comment</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">strlen</span><span class="p">(</span><span class="n">comment</span><span class="p">));</span>
        <span class="n">eocdr</span><span class="p">.</span><span class="n">comment</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">comment</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">+=</span> <span class="n">write_eocdr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eocdr</span><span class="p">);</span>

        <span class="n">assert</span><span class="p">((</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">dst</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">zip_max_size</span><span class="p">(</span><span class="n">num_memb</span><span class="p">,</span> <span class="n">filenames</span><span class="p">,</span>
                                                 <span class="n">file_sizes</span><span class="p">,</span> <span class="n">comment</span><span class="p">));</span>

        <span class="k">return</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">dst</span><span class="p">);
}</span>
</pre></div>


<a name="hwzip"></a>
<h2>HWZip</h2>

<p>We now know how to read and write Zip files, and how to compress and decompress the data stored within. Let us write a simple Zip program to put it all together. The code is available in <a href="https://www.hanshq.net/files/hwzip/hwzip.c">hwzip.c</a>.</p>

<p>We will use a macro for simple error handling, and a few helper functions for checked memory allocation:</p>

<div class="highlight"><pre><span></span><span class="cp">#define PERROR_IF(cnd, msg) do { if (cnd) { perror(msg); exit(1); } } while (0)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">xmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)
{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
        <span class="n">PERROR_IF</span><span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">"malloc"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ptr</span><span class="p">;
}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">xrealloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)
{</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
        <span class="n">PERROR_IF</span><span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">"realloc"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ptr</span><span class="p">;
}</span>
</pre></div>


<p>Another two functions are used for reading and writing files:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="nf">read_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">file_sz</span><span class="p">)
{</span>
        <span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">buf_cap</span><span class="p">;</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">);</span>
        <span class="n">PERROR_IF</span><span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">"fopen"</span><span class="p">);</span>

        <span class="n">buf_cap</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">xmalloc</span><span class="p">(</span><span class="n">buf_cap</span><span class="p">);</span>

        <span class="o">*</span><span class="n">file_sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">feof</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">buf_cap</span> <span class="o">- *</span><span class="n">file_sz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="n">buf_cap</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
                        <span class="n">buf</span> <span class="o">=</span> <span class="n">xrealloc</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">buf_cap</span><span class="p">);
                }</span>

                <span class="o">*</span><span class="n">file_sz</span> <span class="o">+=</span> <span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="o">*</span><span class="n">file_sz</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buf_cap</span> <span class="o">- *</span><span class="n">file_sz</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
                <span class="n">PERROR_IF</span><span class="p">(</span><span class="n">ferror</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="s">"fread"</span><span class="p">);
        }</span>

        <span class="n">PERROR_IF</span><span class="p">(</span><span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"fclose"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">buf</span><span class="p">;
}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)
{</span>
        <span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"wb"</span><span class="p">);</span>
        <span class="n">PERROR_IF</span><span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">"fopen"</span><span class="p">);</span>
        <span class="n">PERROR_IF</span><span class="p">(</span><span class="n">fwrite</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">,</span> <span class="s">"fwrite"</span><span class="p">);</span>
        <span class="n">PERROR_IF</span><span class="p">(</span><span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"fclose"</span><span class="p">);
}</span>
</pre></div>


<p>Our ZIP program can be used to perform three functions: to list the contents of, extract, or create a ZIP file. Listing is easiest:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">list_zip</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">)
{</span>
        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">zip_data</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">zip_sz</span><span class="p">;</span>
        <span class="n">zip_t z</span><span class="p">;</span>
        <span class="n">zipiter_t it</span><span class="p">;</span>
        <span class="n">zipmemb_t m</span><span class="p">;</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"Listing ZIP archive: %s</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>

        <span class="n">zip_data</span> <span class="o">=</span> <span class="n">read_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zip_sz</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zip_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="p">,</span> <span class="n">zip_data</span><span class="p">,</span> <span class="n">zip_sz</span><span class="p">)) {</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to parse ZIP file!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">comment_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%.*s</span><span class="se">\n\n</span><span class="s">"</span><span class="p">, (</span><span class="kt">int</span><span class="p">)</span><span class="n">z</span><span class="p">.</span><span class="n">comment_len</span><span class="p">,</span> <span class="n">z</span><span class="p">.</span><span class="n">comment</span><span class="p">);
        }</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">it</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">members_begin</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">z</span><span class="p">.</span><span class="n">members_end</span><span class="p">;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">next</span><span class="p">) {</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">zip_member</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="p">,</span> <span class="n">it</span><span class="p">);</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%.*s</span><span class="se">\n</span><span class="s">"</span><span class="p">, (</span><span class="kt">int</span><span class="p">)</span><span class="n">m</span><span class="p">.</span><span class="n">name_len</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">name</span><span class="p">);
        }</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">free</span><span class="p">(</span><span class="n">zip_data</span><span class="p">);
}</span>
</pre></div>


<p>Extraction is slightly more involved. We will use a helper function in <a href="https://www.hanshq.net/files/hwzip/zip.c"><span class="code">zip.c</span></a> to decompress a member. Besides Deflate, it also handles the legacy compression methods discussed in the <a href="https://www.hanshq.net/zip2.html">follow-up article</a>.</p>

<div class="highlight"><pre><span></span><span class="cm">/* Extract a zip member into dst. Returns true on success. The CRC-32 is not
   checked. */</span>
<span class="kt">bool</span> <span class="nf">zip_extract_member</span><span class="p">(</span><span class="k">const</span> <span class="n">zipmemb_t</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">src_used</span><span class="p">,</span> <span class="n">dst_used</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">comp_factor</span><span class="p">;</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">method</span><span class="p">) {</span>
        <span class="k">case</span> <span class="nl">ZIP_STORE</span><span class="p">:</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_size</span> <span class="o">==</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">uncomp_size</span><span class="p">);</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_data</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_size</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">ZIP_SHRINK</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">hwunshrink</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_data</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src_used</span><span class="p">,</span>
                               <span class="n">dst</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">uncomp_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst_used</span><span class="p">)</span>
                                <span class="o">!=</span> <span class="n">HWUNSHRINK_OK</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">src_used</span> <span class="o">!=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_size</span> <span class="o">||</span> <span class="n">dst_used</span> <span class="o">!=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">uncomp_size</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">ZIP_REDUCE1</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">ZIP_REDUCE2</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">ZIP_REDUCE3</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">ZIP_REDUCE4</span><span class="p">:</span>
                <span class="n">comp_factor</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">method</span> <span class="o">-</span> <span class="n">ZIP_REDUCE1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">hwexpand</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_data</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_size</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">uncomp_size</span><span class="p">,</span>
                             <span class="n">comp_factor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src_used</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span> <span class="o">!=</span> <span class="n">HWEXPAND_OK</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">src_used</span> <span class="o">!=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_size</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">ZIP_IMPLODE</span><span class="p">:</span>
                <span class="cm">/* If the compressed data assumes an incorrect minimum backref
                   length because of the PKZip 1.01/1.02 bug, the length of the
                   decompressed data will likely not match the expectations, in
                   which case we try pk101_bug_compat mode. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">hwexplode</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_data</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_size</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">uncomp_size</span><span class="p">,</span>
                              <span class="n">m</span><span class="o">-&gt;</span><span class="n">imp_large_wnd</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">imp_lit_tree</span><span class="p">,</span>
                              <span class="cm">/*pk101_bug_compat=*/</span><span class="nb">false</span><span class="p">,</span>
                              <span class="o">&amp;</span><span class="n">src_used</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span> <span class="o">==</span> <span class="n">HWEXPLODE_OK</span> <span class="o">&amp;&amp;</span>
                    <span class="n">src_used</span> <span class="o">==</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_size</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="nb">true</span><span class="p">;
                }</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">hwexplode</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_data</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_size</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">uncomp_size</span><span class="p">,</span>
                              <span class="n">m</span><span class="o">-&gt;</span><span class="n">imp_large_wnd</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">imp_lit_tree</span><span class="p">,</span>
                              <span class="cm">/*pk101_bug_compat=*/</span><span class="nb">true</span><span class="p">,</span>
                              <span class="o">&amp;</span><span class="n">src_used</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span> <span class="o">==</span> <span class="n">HWEXPLODE_OK</span> <span class="o">&amp;&amp;</span>
                    <span class="n">src_used</span> <span class="o">==</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_size</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="nb">true</span><span class="p">;
                }</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">ZIP_DEFLATE</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">hwinflate</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_data</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src_used</span><span class="p">,</span>
                              <span class="n">dst</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">uncomp_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst_used</span><span class="p">)</span> <span class="o">!=</span> <span class="n">HWINF_OK</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">src_used</span> <span class="o">!=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">comp_size</span> <span class="o">||</span> <span class="n">dst_used</span> <span class="o">!=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">uncomp_size</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;
        }</span>

        <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">"Invalid method."</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;
}</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="n">A small helper function is used to null</span><span class="o">-</span><span class="n">terminate the filename</span> <span class="p">(</span><span class="n">so it can be passed to</span> <span class="o">&lt;</span><span class="n">span class</span><span class="o">=</span><span class="s">"code"</span><span class="o">&gt;</span><span class="n">fopen</span><span class="o">&lt;/</span><span class="n">span</span><span class="o">&gt;</span><span class="p">)</span><span class="o">:&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">terminate_str</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)
{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">xmalloc</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">;
}</span>
</pre></div>


<p>Our program will skip any archive member that is in a directory. The reason for this is to avoid so called <a href="https://www.owasp.org/index.php/Path_Traversal">path traversal attacks</a>, where a malicious archive is used to write a file outside the directory specified by the user. See <a href="http://infozip.sourceforge.net/FAQ.html#corruption">Info-ZIP's FAQ</a> for some discussion.</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">extract_zip</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">)
{</span>
        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">zip_data</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">zip_sz</span><span class="p">;</span>
        <span class="n">zip_t z</span><span class="p">;</span>
        <span class="n">zipiter_t it</span><span class="p">;</span>
        <span class="n">zipmemb_t m</span><span class="p">;</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">tname</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">uncomp_data</span><span class="p">;</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"Extracting ZIP archive: %s</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>

        <span class="n">zip_data</span> <span class="o">=</span> <span class="n">read_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zip_sz</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zip_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="p">,</span> <span class="n">zip_data</span><span class="p">,</span> <span class="n">zip_sz</span><span class="p">)) {</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to read ZIP file!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">comment_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%.*s</span><span class="se">\n\n</span><span class="s">"</span><span class="p">, (</span><span class="kt">int</span><span class="p">)</span><span class="n">z</span><span class="p">.</span><span class="n">comment_len</span><span class="p">,</span> <span class="n">z</span><span class="p">.</span><span class="n">comment</span><span class="p">);
        }</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">it</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">members_begin</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">z</span><span class="p">.</span><span class="n">members_end</span><span class="p">;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">next</span><span class="p">) {</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">zip_member</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="p">,</span> <span class="n">it</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">is_dir</span><span class="p">) {</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">" (Skipping dir: %.*s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,
                               (</span><span class="kt">int</span><span class="p">)</span><span class="n">m</span><span class="p">.</span><span class="n">name_len</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
                        <span class="k">continue</span><span class="p">;
                }</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">memchr</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="sc">'/'</span><span class="p">,</span>  <span class="n">m</span><span class="p">.</span><span class="n">name_len</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span>
                    <span class="n">memchr</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="sc">'\\'</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">name_len</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">) {</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">" (Skipping file in dir: %.*s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,
                               (</span><span class="kt">int</span><span class="p">)</span><span class="n">m</span><span class="p">.</span><span class="n">name_len</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
                        <span class="k">continue</span><span class="p">;
                }</span>

                <span class="k">switch</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">method</span><span class="p">) {</span>
                <span class="k">case</span> <span class="nl">ZIP_STORE</span><span class="p">:</span>   <span class="n">printf</span><span class="p">(</span><span class="s">"  Extracting: "</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="nl">ZIP_SHRINK</span><span class="p">:</span>  <span class="n">printf</span><span class="p">(</span><span class="s">" Unshrinking: "</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="nl">ZIP_REDUCE1</span><span class="p">:</span>
                <span class="k">case</span> <span class="nl">ZIP_REDUCE2</span><span class="p">:</span>
                <span class="k">case</span> <span class="nl">ZIP_REDUCE3</span><span class="p">:</span>
                <span class="k">case</span> <span class="nl">ZIP_REDUCE4</span><span class="p">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">"   Expanding: "</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="nl">ZIP_IMPLODE</span><span class="p">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">"   Exploding: "</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="nl">ZIP_DEFLATE</span><span class="p">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">"   Inflating: "</span><span class="p">);</span> <span class="k">break</span><span class="p">;
                }</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%.*s"</span><span class="p">, (</span><span class="kt">int</span><span class="p">)</span><span class="n">m</span><span class="p">.</span><span class="n">name_len</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
                <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

                <span class="n">uncomp_data</span> <span class="o">=</span> <span class="n">xmalloc</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">uncomp_size</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zip_extract_member</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">uncomp_data</span><span class="p">)) {</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">"  Error: decompression failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);
                }</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">crc32</span><span class="p">(</span><span class="n">uncomp_data</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">uncomp_size</span><span class="p">)</span> <span class="o">!=</span> <span class="n">m</span><span class="p">.</span><span class="n">crc32</span><span class="p">) {</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">"  Error: CRC-32 mismatch!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);
                }</span>

                <span class="n">tname</span> <span class="o">=</span> <span class="n">terminate_str</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">name_len</span><span class="p">);</span>
                <span class="n">write_file</span><span class="p">(</span><span class="n">tname</span><span class="p">,</span> <span class="n">uncomp_data</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">uncomp_size</span><span class="p">);</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

                <span class="n">free</span><span class="p">(</span><span class="n">uncomp_data</span><span class="p">);</span>
                <span class="n">free</span><span class="p">(</span><span class="n">tname</span><span class="p">);
        }</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">zip_data</span><span class="p">);
}</span>
</pre></div>


<p>To create a Zip archive, we read the input files and feed them to <span class="code">zip_write</span>. Since the C standard library does not provide a way to get the modification time of a file, we use the current time instead (fixing this is left as an exercise to the reader).</p>

<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">zip_callback</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="n">method_t method</span><span class="p">,</span>
                  <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">comp_size</span><span class="p">)
{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">method</span><span class="p">) {</span>
        <span class="k">case</span> <span class="nl">ZIP_STORE</span><span class="p">:</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"   Stored: "</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">ZIP_SHRINK</span><span class="p">:</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"   Shrunk: "</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">ZIP_REDUCE1</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">ZIP_REDUCE2</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">ZIP_REDUCE3</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">ZIP_REDUCE4</span><span class="p">:</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"  Reduced: "</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">ZIP_IMPLODE</span><span class="p">:</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">" Imploded: "</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">ZIP_DEFLATE</span><span class="p">:</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">" Deflated: "</span><span class="p">);</span> <span class="k">break</span><span class="p">;
        }</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">method</span> <span class="o">!=</span> <span class="n">ZIP_STORE</span><span class="p">) {</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">"Empty files should use Store."</span><span class="p">);</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">" (%u%%)"</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">comp_size</span> <span class="o">/</span> <span class="n">size</span><span class="p">);
        }</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);
}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">create_zip</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zip_filename</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">comment</span><span class="p">,</span>
                       <span class="n">method_t method</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">n</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="o">*</span><span class="n">filenames</span><span class="p">)
{</span>
        <span class="kt">time_t</span> <span class="n">mtime</span><span class="p">;</span>
        <span class="kt">time_t</span> <span class="o">*</span><span class="n">mtimes</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="o">**</span><span class="n">file_data</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">file_sizes</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">file_size</span><span class="p">,</span> <span class="n">zip_size</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">zip_data</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">i</span><span class="p">;</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"Creating ZIP archive: %s</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">zip_filename</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">comment</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">) {</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">comment</span><span class="p">);
        }</span>

        <span class="n">mtime</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

        <span class="n">file_data</span> <span class="o">=</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">file_sizes</span> <span class="o">=</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">mtimes</span> <span class="o">=</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mtimes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">file_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_file</span><span class="p">(</span><span class="n">filenames</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">file_size</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">file_size</span> <span class="o">&gt;=</span> <span class="n">UINT32_MAX</span><span class="p">) {</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">"%s is too large!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">filenames</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);
                }</span>
                <span class="n">file_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">file_size</span><span class="p">;</span>
                <span class="n">mtimes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mtime</span><span class="p">;
        }</span>

        <span class="n">zip_size</span> <span class="o">=</span> <span class="n">zip_max_size</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">filenames</span><span class="p">,</span> <span class="n">file_sizes</span><span class="p">,</span> <span class="n">comment</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">zip_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"zip writing not possible"</span><span class="p">);</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);
        }</span>

        <span class="n">zip_data</span> <span class="o">=</span> <span class="n">xmalloc</span><span class="p">(</span><span class="n">zip_size</span><span class="p">);</span>
        <span class="n">zip_size</span> <span class="o">=</span> <span class="n">zip_write</span><span class="p">(</span><span class="n">zip_data</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">filenames</span><span class="p">,
                             (</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="k">const</span> <span class="o">*</span><span class="p">)</span><span class="n">file_data</span><span class="p">,</span>
                             <span class="n">file_sizes</span><span class="p">,</span> <span class="n">mtimes</span><span class="p">,</span> <span class="n">comment</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">zip_callback</span><span class="p">);</span>

        <span class="n">write_file</span><span class="p">(</span><span class="n">zip_filename</span><span class="p">,</span> <span class="n">zip_data</span><span class="p">,</span> <span class="n">zip_size</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">free</span><span class="p">(</span><span class="n">zip_data</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">free</span><span class="p">(</span><span class="n">file_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);
        }</span>
        <span class="n">free</span><span class="p">(</span><span class="n">mtimes</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">file_sizes</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">file_data</span><span class="p">);
}</span>
</pre></div>


<p>Finally, <span class="code">main</span> inspects the command-line arguments and decides what to do:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">print_usage</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv0</span><span class="p">)
{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Usage:</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"  %s list &lt;zipfile&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv0</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"  %s extract &lt;zipfile&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv0</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"  %s create &lt;zipfile&gt; "
               "[-m &lt;method&gt;] [-c &lt;comment&gt;] &lt;files...&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv0</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"  Supported compression methods: </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"  store, shrink, reduce, implode, deflate (default).</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);
}</span>

<span class="k">static</span> <span class="kt">bool</span> <span class="nf">parse_method_flag</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">method_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)
{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">argc</span><span class="p">) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="o">*</span><span class="n">i</span><span class="p">],</span> <span class="s">"-m"</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="s">"store"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">ZIP_STORE</span><span class="p">;
        }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="s">"shrink"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">ZIP_SHRINK</span><span class="p">;
        }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="s">"reduce"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">ZIP_REDUCE4</span><span class="p">;
        }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="s">"implode"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">ZIP_IMPLODE</span><span class="p">;
        }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="s">"deflate"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">ZIP_DEFLATE</span><span class="p">;
        }</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">print_usage</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Unknown compression method: '%s'.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);
        }</span>
        <span class="o">*</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>

<span class="k">static</span> <span class="kt">bool</span> <span class="nf">parse_comment_flag</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">c</span><span class="p">)
{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">argc</span><span class="p">) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="o">*</span><span class="n">i</span><span class="p">],</span> <span class="s">"-c"</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>
        <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="o">*</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">) {</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">comment</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">method_t method</span> <span class="o">=</span> <span class="n">ZIP_DEFLATE</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"HWZIP "</span> <span class="n">VERSION</span> <span class="s">" -- A simple ZIP program "</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"from https://www.hanshq.net/zip.html</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"list"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">list_zip</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);
        }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"extract"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">extract_zip</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);
        }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"create"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">parse_method_flag</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">method</span><span class="p">)</span> <span class="o">||</span>
                       <span class="n">parse_comment_flag</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comment</span><span class="p">)) {
                }</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">argc</span><span class="p">);</span>

                <span class="n">create_zip</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">comment</span><span class="p">,</span> <span class="n">method</span><span class="p">, (</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="n">argc</span> <span class="o">-</span> <span class="n">i</span><span class="p">),
                           (</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);
        }</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">print_usage</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;
}</span>
</pre></div>


<a name="build"></a>
<h3>Build Instructions</h3>

<p>The full set of source files is available in <a href="https://www.hanshq.net/files/hwzip/hwzip-2.0.zip">hwzip-2.0.zip</a>. To compile HWZip on Linux or Mac:</p>

<!--If the build instructions change, also update the README file.-->

<div class="highlight"><pre><span></span>$ clang generate_tables.c &amp;&amp; ./a.out &gt; tables.c
$ clang -O3 -DNDEBUG -march=native -o hwzip crc32.c deflate.c huffman.c \
        hwzip.c implode.c lz77.c reduce.c shrink.c tables.c zip.c
</pre></div>


<p>Or on Windows, in a Visual Studio Developer Command Prompt (if you do not have Visual Studio, download the <a href="https://aka.ms/buildtools">Build Tools</a>):</p>

<div class="highlight"><pre><span></span>cl /TC generate_tables.c &amp;&amp; generate_tables &gt; tables.c
cl /O2 /DNDEBUG /MT /Fehwzip.exe /TC crc32.c deflate.c huffman.c hwzip.c
        implode.c lz77.c reduce.c shrink.c tables.c zip.c /link setargv.obj
</pre></div>


<p>(setargv.obj is for <a href="https://docs.microsoft.com/en-us/cpp/c-language/expanding-wildcard-arguments">expanding wildcard command-line arguments</a>.)</p>

<a name="conclusion"></a>
<h2>Conclusion</h2>

<p>It is fascinating how the evolution of technology is both fast and slow. The Zip format was created 30 years ago based on technology from the fifties and seventies, and while much has changed since then, Zip files are essentially the same and more prevalent than ever. I think it is useful to have a good understanding of how they work.</p>

<a name="exercises"></a>
<h2>Exercises</h2>

<ul>
<li>Make HWZip write each file's modification time rather than the current time when creating archives. Use <a href="https://linux.die.net/man/2/stat">stat(2)</a> on Linux or Mac, and <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfiletime">GetFileTime</a> on Windows. Alternatively, add a command-line flag that allows the user to specify the modification time for the files.</li>

<li>Using the deflation and inflation code from this article, write a program to create and extract gzip files. The format is a simple wrapper around Deflate-compressed data (normally just one file). It is described in <a href="https://tools.ietf.org/html/rfc1952">RFC 1952</a>.

</li><li>Add callbacks to report progress from the <span class="code">hwdeflate</span> and <span class="code">hwinflate</span> functions. For example, they could invoke the callback after each completed Deflate block and report the number of bytes processed. Use this to add progress indicators to hwzip.</li>

<li>The Zip reader and writer implementations are designed to work with <a href="https://en.wikipedia.org/wiki/Memory-mapped_file">memory-mapped files</a>. Change HWZip to not use <span class="code">read_file</span>, but <a href="https://linux.die.net/man/2/mmap">mmap(2)</a> on Linux or Mac, and <a href="https://docs.microsoft.com/en-us/windows/win32/memory/creating-a-file-mapping-object">CreateFileMapping</a> on Windows.</li>

<li>Change HWZip to support extracting and creating archives using the Zip64 format. See <a href="https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.3.6.TXT">the most recent appnote.txt</a> for details.</li>
</ul>


<a name="reading"></a>
<h2>Further Reading</h2>

<ul>
<li>For more information about BBS culture, see Jason Scott's <a href="http://www.bbsdocumentary.com/">BBS: The Documentary</a>. The videos can be found <a href="https://www.youtube.com/playlist?list=PLgE-9Sxs2IBVgJkY-1ZMj0tIFxsJ-vOkv">on YouTube</a>. <a href="https://www.youtube.com/watch?v=MLNXmrF3a9c">Part 8: Compression</a> covers the SEA vs. PKWare "Arc Wars". The web site has an <a href="http://www.bbsdocumentary.com/library/CONTROVERSY/LAWSUITS/SEA/">archive of related historical material</a>. Phil Katz appeared <a href="https://youtu.be/ALfkAjCUSLg?t=309">on an episode of Computer Chronicles</a>.</li>

<li>David Fifield's <a href="https://www.bamsoftware.com/hacks/zipbomb/">A better Zip bomb</a> is a great article explaining how to create a Zip file that "explodes" into a very large amount of data when extracted.</li>

<li>Russ Cox's <a href="https://research.swtch.com/zip">Zip Files All The Way Down</a> shows how to create a <em>Zip quine</em>, a Zip file which contains a copy of itself.</li>

<li>Gábor Molnár's <a href="https://github.com/molnarg/ascii-zip">ascii-zip</a> is a program that emits a Deflate stream which is entirely ASCII. It was used in Michele Spagnuolo's <a href="https://blog.miki.it/2014/7/8/abusing-jsonp-with-rosetta-flash/">Rosetta Flash</a> exploit.</li>

<li>Gynvael Coldwind's <a href="https://gynvael.coldwind.pl/?id=682">Ten Thousand Security Pitfalls: the Zip File Format</a> is a detailed presentation about the format from a security perspective.</li>

<li>Fabian Giesen's <a href="https://fgiesen.wordpress.com/2018/02/19/reading-bits-in-far-too-many-ways-part-1/">Reading bits in far too many ways part 1</a>, <a href="https://fgiesen.wordpress.com/2018/02/20/reading-bits-in-far-too-many-ways-part-2/">part 2</a> and <a href="https://fgiesen.wordpress.com/2018/09/27/reading-bits-in-far-too-many-ways-part-3/">part 3</a> are a great source of information on implementing bitstreams.</li>

<li>Colton McAnlis and Aleks Haecky's <a href="http://shop.oreilly.com/product/0636920052036.do">Understanding Compression</a> gives a broad introduction to the subject of data compression.</li>
</ul>

<a name="files"></a>
<h2>Linked Files</h2>

<p>These are the files linked from this article and their SHA-256 hash values.</p>

<div style="overflow-x: auto">
<table border="1">
<tbody><tr><td><a href="https://www.hanshq.net/files/hwzip/hwzip-1.0.zip">hwzip-1.0.zip</a></td> <td><span class="code">583fd0ca05bf28f6d7991cc1e7c4eb078389e4957878390d660de4a83cc6486d</span></td></tr>
<tr><td><a href="https://www.hanshq.net/files/hwzip/hwzip-1.1.zip">hwzip-1.1.zip</a></td> <td><span class="code">480893d4f11f196c33f566247fa221335b3916b4cb231ad1259989ef8e188b8f</span></td></tr>
<tr><td><a href="https://www.hanshq.net/files/hwzip/hwzip-1.2.zip">hwzip-1.2.zip</a></td> <td><span class="code">780d8f5dd2acc52f150cf4e4396c439280014527995d16c09463a6f1ab42ba8b</span></td></tr>
<tr><td><a href="https://www.hanshq.net/files/hwzip/hwzip-1.3.zip">hwzip-1.3.zip</a></td> <td><span class="code">32d03b3092fef3cafd99fff231e53fd5452a115978af586a2cf700855866bd52</span></td></tr>
<tr><td><a href="https://www.hanshq.net/files/hwzip/hwzip-1.4.zip">hwzip-1.4.zip</a></td> <td><span class="code">8b9f955037ac8ade5a98666429012f88a02a27221d0fc746ab1bc80942fbe011</span></td></tr>
<tr><td><a href="https://www.hanshq.net/files/hwzip/hwzip-2.0.zip">hwzip-2.0.zip</a></td> <td><span class="code">2136285dd19024fba551307d3cc32a429e2db9e0fb91f0ce6bf11563efe15510</span></td></tr>
<tr><td><a href="https://www.hanshq.net/files/pkz204g.exe">pkz204g.exe</a></td> <td><span class="code">004b48f1cdfe0f31888d213e94ae3997aa5fc02bed8a2d75addaf34ae02d1024</span></td></tr>
<tr><td><a href="https://www.hanshq.net/files/winzip1.zip">winzip1.zip</a></td> <td><span class="code">a894387a28b3155c6ec073402a73788204fe8077b90605c7cad30483ec82da84</span></td></tr>
<tr><td><a href="https://ftp.sunet.se/mirror/archive/ftp.sunet.se/pub/simtelnet/win3/compress/wz16v_63.exe">wz16v_63.exe</a></td> <td><span class="code">a2e3aadf86d6cb91e8c2119172f1e58fc7fc91381156840514dd1f57c59c07ad</span></td></tr>
</tbody></table>
</div>

<div style="text-align: center">
<p><img src="./zip_files/hwzip_easter_egg.jpg" alt="PKWARE &#39;Get Zipped&#39; button from Comdex Computer Trade Show." style="max-width: 100%"></p>
</div>

                        </div>
                </div>
                <div id="footer">
                        Hans Wennborg |
                        <a href="https://www.hanshq.net/">www.hanshq.net</a> |
                        hans (at) hanshq.net |
                        <a href="https://twitter.com/hansw2000">@hansw2000</a> |
                        <a href="https://www.hanshq.net/feed.rss">RSS</a>
                </div>
        </div>
</div>


<div style="background-color: rgb(255, 143, 0); display: none; color: white; text-align: center; position: fixed; top: 0px; left: 0px; width: 100%; height: auto; min-width: 100%; min-height: auto; max-width: 100%; font: 12px &quot;Helvetica Neue&quot;, Helvetica, Arial, Geneva, sans-serif; cursor: pointer; padding: 5px;"><span style="color: white; font: 12px &quot;Helvetica Neue&quot;, Helvetica, Arial, Geneva, sans-serif;">You have turned off the paragraph player. You can turn it on again from the options page.</span><img src="chrome-extension://gfjopfpjmkcfgjpogepmdjmcnihfpokn/img/icons/icon-close_16.png" style="width: 20px; height: auto; min-width: 20px; min-height: auto; max-width: 20px; float: right; margin-right: 10px;"></div></body></html>