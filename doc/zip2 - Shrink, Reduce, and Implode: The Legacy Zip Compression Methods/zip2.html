<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0032)https://www.hanshq.net/zip2.html -->
<html lang="en"><script type="text/javascript">window["_gaUserPrefs"] = { ioo : function() { return true; } }</script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        
        <title>Shrink, Reduce, and Implode: The Legacy Zip Compression Methods</title>
        <link rel="stylesheet" type="text/css" href="./zip2_files/style.css">
        <link rel="stylesheet" type="text/css" href="./zip2_files/code-style.css">
        <link rel="alternate" type="application/rss+xml" href="https://www.hanshq.net/feed.rss">
        <meta name="viewport" content="width=device-width, initial-scale=1">

<style type="text/css">
.lzsrc { background: rgba(255,230,0,0.3);   color-adjust: exact; -webkit-print-color-adjust: exact; }
.lzdst { background: rgba(125,125,250,0.3); color-adjust: exact; -webkit-print-color-adjust: exact; }
</style>
</head>
<body>
<div id="main">
        <a href="https://www.hanshq.net/"><img src="./zip2_files/header_img_0156.jpg" id="header" alt="hanshq.net" style="max-width: 900px; max-height: 400px"></a>
        <div id="container">
                <div id="center">
                        <h1>Shrink, Reduce, and Implode: <br>The Legacy Zip Compression Methods<br><span class="date">(12&nbsp;March&nbsp;2021)</span></h1>
                        <div id="left">
<p>Last year I wrote <a href="https://www.hanshq.net/zip.html">a long article about Zip files</a>, covering the history, describing the Deflate compression method in great detail, and showing the implementation of a simple Zip program. I was fascinated by the subject: the magic of data compression, and how this truly ubiquitous file format works.</p>

<p>Zip files support many different compression methods, however, and although Deflate is the one most commonly used today, it was not added until several years after the introduction of the Zip file format. While the earlier methods are not in themselves relevant anymore, the techniques involved are still both interesting and relevant. For example, the first method used LZW compression, which popularized dictionary compression, gained notoriety due to patent issues, and is still widely used in GIF files. From a historical perspective, the older methods allow us to trace the evolution from the roots of PKZip to the Deflate method that we use today.</p>

<p>This article describes and implements the Shrink, Reduce, and Implode compression methods. The previous article is not required reading, but provides useful background for readers without previous knowledge about Zip files. All the code is available in <a href="https://www.hanshq.net/files/hwzip/hwzip-2.0.zip"><span class="code">hwzip-2.0.zip</span></a>.</p>

<p>Let's do data compression like it's 1989!</p>




<p>Many thanks to
<a href="https://twitter.com/angealbertini">Ange Albertini</a>,
<a href="https://marknelson.us/">Mark Nelson</a>,
<a href="https://entropymine.wordpress.com/">Jason Summers</a>,
<a href="https://www.sigbus.info/">Rui Ueyama</a>, and
<a href="https://twitter.com/thakis">Nico Weber</a>
who provided valuable feedback on drafts of this article.</p>

<a name="toc"></a>
<h2>Table of Contents</h2>

<ul>
<li><a href="https://www.hanshq.net/zip2.html#shrink">Method 1: Shrink / Unshrink</a><ul>
        <li><a href="https://www.hanshq.net/zip2.html#lzw">LZW History</a></li>
        <li><a href="https://www.hanshq.net/zip2.html#lzwalg">The LZW Algorithm</a></li>
        <li><a href="https://www.hanshq.net/zip2.html#lzwdict">Maintaining the Dictionary</a></li>
        <li><a href="https://www.hanshq.net/zip2.html#lzwcodes">Reading and Writing Codes</a></li>
        <li><a href="https://www.hanshq.net/zip2.html#lzwfull">When the Dictionary Gets Full</a></li>
        <li><a href="https://www.hanshq.net/zip2.html#lzwsurprise">Surprising Effects of Partial Clearing</a></li>
        <li><a href="https://www.hanshq.net/zip2.html#lzwfinish">Finishing the Implementation</a></li>
</ul></li>

<li><a href="https://www.hanshq.net/zip2.html#reduce">Methods 2–5: Reduce / Expand</a><ul>
        <li><a href="https://www.hanshq.net/zip2.html#expfollowers">Expand: Follower Sets</a></li>
        <li><a href="https://www.hanshq.net/zip2.html#explz77">Expand: LZ77</a></li>
        <li><a href="https://www.hanshq.net/zip2.html#reducefollowers">Reduce: Follower Sets</a></li>
        <li><a href="https://www.hanshq.net/zip2.html#reducelz77">Reduce: LZ77</a></li>
</ul></li>


<li><a href="https://www.hanshq.net/zip2.html#implode">Method 6: Implode / Explode</a><ul>
        <li><a href="https://www.hanshq.net/zip2.html#explode">Explode</a></li>
        <li><a href="https://www.hanshq.net/zip2.html#implodeimp">Implode</a></li>
        <li><a href="https://www.hanshq.net/zip2.html#deflate">From Implode to Deflate</a></li>
</ul></li>

<li><a href="https://www.hanshq.net/zip2.html#conclusion">Conclusion</a></li>
<li><a href="https://www.hanshq.net/zip2.html#exercises">Exercises</a></li>
<li><a href="https://www.hanshq.net/zip2.html#reading">Further Reading</a></li>
<li><a href="https://www.hanshq.net/zip2.html#files">Linked Files</a></li>

</ul>

<div style="text-align: center">
<div class="latex"><p style="margin-left: 2em"><img src="./zip2_files/tex_fa4cb6fe.svg" alt="LaTeX"></p></div>
</div>

<a name="shrink"></a>
<h2>Method 1: Shrink / Unshrink</h2>

<p>Phil Katz started out in the compression business by creating his own version of the then-popular Arc program, which he called PKArc. Following a legal dispute with the original program's creators, the "Arc Wars", Katz created his own file format: the Zip file. (For more history, <a href="https://www.hanshq.net/zip.html#history">see the previous article</a>.)</p>

<p>Arc used a compression algorithm called LZW. Since Katz had implemented and made various improvements to the algorithm in his PKArc program, it was natural to use that experience when creating his new file format. The original PKZip compression method is an LZW variant which Katz called Shrink. It was first released in a beta version, <a href="http://cd.textfiles.com/originalsw/25/pkz080.zip">PKZip 0.80</a>, and then publicly released in <a href="http://cd.textfiles.com/originalsw/25/pkz090.exe">PKZip 0.90</a> early 1989.</p>

<p>Like all Zip compression methods, Shrink is described in the <a href="https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-2.0.txt">application note</a> that comes with PKZip. The description is very brief however, and assumes intimate familiarity with LZW.</p>

<a name="lzw"></a>
<h3>LZW History</h3>

<p>LZW was introduced in a 1984 paper by <a href="https://en.wikipedia.org/wiki/Terry_Welch">Terry Welch</a> called <a href="https://www2.cs.duke.edu/courses/spring03/cps296.5/papers/welch_1984_technique_for.pdf">A Technique for High-Performance Data Compression</a>. It builds on an algorithm in a <a href="https://pzs.dstu.dp.ua/ComputerGraphics/ic/bibl/ziv_lempel_1978.pdf">1978 paper by Abraham Lempel and Jacob Ziv</a>, hence the name: Lempel–Ziv–Welch (LZW) compression.</p>

<div style="text-align: center">
<img src="./zip2_files/welch.jpg" alt="Photo of Terry Welch" style="max-width: 90%">

<p>Terry Welch (1939–1988)</p>
</div>

<p>In contrast to Lempel and Ziv's paper (LZ78), which was published in a specialized scientific journal and focused more on theoretical results than a practical compression algorithm, Welch's paper was published in IEEE's Computer, a widely read magazine, and it introduced a practical and effective compression method in a very accessible way.</p>

<div style="text-align: center">
<a href="https://www.hanshq.net/gfx/lzw_computer_large.jpg"><img src="./zip2_files/lzw_computer.jpg" alt="Cover of IEEE Computer, June 1984" style="max-width: 90%"></a>

<p>IEEE Computer, June 1984</p>
</div>


<p>In fact, the algorithm is so simple and well explained in Welch's paper that the reader is tempted to sit down and implement it—which is exactly what Spencer W. Thomas, then an Assistant Professor in the University of Utah's computer graphics group (the folks with <a href="https://en.wikipedia.org/wiki/Utah_teapot">the teapot</a>) did. Thomas called his program <a href="https://en.wikipedia.org/wiki/Compress">Compress</a>, and shared it with the world in a <a href="https://groups.google.com/forum/#!topic/net.sources/fonve4JCDpQ/discussion">net.sources Usenet post</a>.</p>

<p>Before LZW, the common compression programs were all based on variants of <a href="https://www.hanshq.net/zip.html#huffman">Huffman coding</a>. Thomas's Usenet post makes comparisons with the Unix <a href="http://fileformats.archiveteam.org/wiki/Compact_(Unix)">Compact</a> and <a href="http://fileformats.archiveteam.org/wiki/Pack_(Unix)">Pack</a> programs, and <a href="http://fileformats.archiveteam.org/wiki/Squeeze">Squeeze</a> was popular in the PC world to the extent that Huffman coding was sometimes referred to as "squeezing". Those programs compress data by translating bytes to variable-length codes assigned by Huffman's algorithm: common bytes get shorter codes, yielding a smaller overall representation of the data. LZW, however, works on a higher level: instead of operating on individual bytes, it assigns codes to sequences of bytes, which can lead to much greater compression for sequences that occur repeatedly.</p>

<p>Compress soon became the de facto standard program for data compression on Unix, to the point that it was added to the <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/compress.html">Posix standard</a>. LZW was also used in many other programs, in hardware, and in file formats—most notably the <a href="https://en.wikipedia.org/wiki/GIF">GIF</a> image file format, which is perhaps its most common use today.</p>

<p>(Compress creates files with a <span class="code">.Z</span> extension, which many people assume has something to do with Zip files. However, Compress predates the Zip file format by several years. Instead, the extension was probably inspired by Pack, which uses a lower-case <span class="code">.z</span> for its output files. The origins of Pack are not entirely clear, but one early version was written by Steve Zucker at RAND. If that was the first version, perhaps the z is for Zucker.)</p>

<p>While Welch's paper did an excellent job of explaining LZW, it left out one important detail: the algorithm was patented. That caused major controversy in the software community a few years later when Unisys, the company who owned the patents, realized how widely used the algorithm was and started extracting licensing fees for it. This was <a href="https://en.wikipedia.org/wiki/GIF#Unisys_and_LZW_patent_enforcement">especially problematic for GIF files</a>. Though the patents have now thankfully expired, that ordeal made the algorithm infamous.</p>


<a name="lzwalg"></a>
<h3>The LZW Algorithm</h3>

<p>LZW is a dictionary-based compression method: the source data is parsed into substrings which occur in a dictionary, and the result of the algorithm is a sequence of codes referring to those dictionary entries. New entries are added to the dictionary as the input gets processed.</p>

<p>The dictionary is represented as a set of codes and their corresponding strings.
Initially, it consists of all possible one-byte strings.
The input data is then processed one byte at a time, accumulating into the "current string" as long as that string exists in the dictionary.
When the current string extended with the next byte no longer exists in the dictionary, the code corresponding to the current string is output, the new string (current string + next byte) is added to the dictionary for later use, and the process continues with the next byte as current string.
In the end, the sequence of output codes is the result of the compression.</p>

<p>For example, if we restrict the input to the English alphabet, the initial dictionary could look like this:</p>

<div style="overflow-x: auto">
<table border="1">
<tbody><tr>
<th>Code</th>
<td style="width: 2em; text-align: center">1</td>
<td style="width: 2em; text-align: center">2</td>
<td style="width: 2em; text-align: center">3</td>
<td style="width: 2em; text-align: center">4</td>
<td style="width: 2em; text-align: center">5</td>
<td style="width: 2em; text-align: center">6</td>
<td style="width: 2em; text-align: center">7</td>
<td style="width: 2em; text-align: center">8</td>
<td style="width: 2em; text-align: center">9</td>
<td style="width: 2em; text-align: center">10</td>
<td style="width: 2em; text-align: center">11</td>
<td style="width: 2em; text-align: center">12</td>
<td style="width: 2em; text-align: center">13</td>
<td style="width: 2em; text-align: center">14</td>
<td style="width: 2em; text-align: center">15</td>
<td style="width: 2em; text-align: center">16</td>
<td style="width: 2em; text-align: center">17</td>
<td style="width: 2em; text-align: center">18</td>
<td style="width: 2em; text-align: center">19</td>
<td style="width: 2em; text-align: center">20</td>
<td style="width: 2em; text-align: center">21</td>
<td style="width: 2em; text-align: center">22</td>
<td style="width: 2em; text-align: center">23</td>
<td style="width: 2em; text-align: center">24</td>
<td style="width: 2em; text-align: center">25</td>
<td style="width: 2em; text-align: center">26</td>
</tr>

<tr>
<th>String</th>
<td style="text-align: center">A</td>
<td style="text-align: center">B</td>
<td style="text-align: center">C</td>
<td style="text-align: center">D</td>
<td style="text-align: center">E</td>
<td style="text-align: center">F</td>
<td style="text-align: center">G</td>
<td style="text-align: center">H</td>
<td style="text-align: center">I</td>
<td style="text-align: center">J</td>
<td style="text-align: center">K</td>
<td style="text-align: center">L</td>
<td style="text-align: center">M</td>
<td style="text-align: center">N</td>
<td style="text-align: center">O</td>
<td style="text-align: center">P</td>
<td style="text-align: center">Q</td>
<td style="text-align: center">R</td>
<td style="text-align: center">S</td>
<td style="text-align: center">T</td>
<td style="text-align: center">U</td>
<td style="text-align: center">V</td>
<td style="text-align: center">W</td>
<td style="text-align: center">X</td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Z</td>
</tr>
</tbody></table>
</div>

<a name="londoner"></a>
<p>And to compress the string "LONDONER", the algorithm would proceed as follows:</p>

<table border="1">
<tbody><tr><th>Input Character</th>  <th>Output Code</th> <th>Added String</th> <th>Current Code</th></tr>
<tr><td>L</td>                <td>—</td>     <td>—</td>      <td>12 ("L")</td></tr>
<tr><td>O</td>                <td>12 ("L")</td>    <td>"LO" (27)</td>    <td>15 ("O")</td></tr>
<tr><td>N</td>                <td>15 ("O")</td>    <td>"ON" (28)</td>    <td>14 ("N")</td></tr>
<tr><td>D</td>                <td>14 ("N")</td>    <td>"ND" (29)</td>    <td>4 ("D")</td></tr>
<tr><td>O</td>                <td>4 ("D")</td>     <td>"DO" (30)</td>    <td>15 ("O")</td></tr>
<tr><td>N</td>                <td>—</td>     <td>—</td>      <td>28 ("ON")</td></tr>
<tr><td>E</td>                <td>28 ("ON")</td>   <td>"ONE" (31)</td>   <td>5 ("E")</td></tr>
<tr><td>R</td>                <td>5 ("E")</td>     <td>"ER" (32)</td>    <td>18 ("R")</td></tr>
<tr><td>—</td>          <td>18 ("R")</td>    <td>—</td>      <td>—</td></tr>
</tbody></table>

<p>The eight-character input has been compressed to the seven output codes: 12, 15, 14, 4, 28, 5, 18.</p>

<p>Expressed in pseudo-code, the algorithm goes like this:</p>

<div class="highlight"><pre><span></span><span class="n">initialize_dictionary</span><span class="p">();</span>
<span class="n">current_code</span> <span class="o">=</span> <span class="n">get_input_byte</span><span class="p">();</span>

<span class="k">while</span> <span class="p">(</span><span class="n">more_input_available</span><span class="p">()) {</span>
        <span class="n">current_byte</span> <span class="o">=</span> <span class="n">get_input_byte</span><span class="p">();</span>
        <span class="n">new_string</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">current_code</span><span class="p">]</span> <span class="o">+</span> <span class="n">current_byte</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">new_string exists in dictionary</span><span class="p">) {</span>
                <span class="n">current_code</span> <span class="o">=</span> <span class="n">get_code_for</span><span class="p">(</span><span class="n">new_string</span><span class="p">);
        }</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">output</span><span class="p">(</span><span class="n">current_code</span><span class="p">);</span>
                <span class="n">dictionary</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_string</span><span class="p">);</span>
                <span class="n">current_code</span> <span class="o">=</span> <span class="n">current_byte</span><span class="p">;
        }
}</span>
<span class="n">output</span><span class="p">(</span><span class="n">current_code</span><span class="p">);</span>
</pre></div>


<p>LZW decompression also begins with a dictionary consisting of all one-byte strings. Input codes are processed by looking up and outputting the corresponding strings from the dictionary. The tricky part is updating the dictionary. When the compressor outputs a code, that code represents the "current string", and then the compressor adds that "current string" plus next byte to the dictionary. The decompressor cannot observe those updates to the dictionary directly, as it only sees the output codes. However, it can deduce the updates, because it knows that when it receives a new code, the string represented by the previous code plus the following byte was added to the dictionary, and that "following byte" is the first byte of the string represented by the current code.</p>

<p>Let's decompress the previous example:</p>

<table border="1">
<tbody><tr><th>Input Code</th>  <th>Output String</th> <th>Added String</th></tr>
<tr><td>12 ("L")</td>    <td>"L"</td>           <td>—</td></tr>
<tr><td>15 ("O")</td>    <td>"O"</td>           <td>"LO" (27)</td></tr>
<tr><td>14 ("N")</td>    <td>"N"</td>           <td>"ON" (28)</td></tr>
<tr><td>4 ("D")</td>     <td>"D"</td>           <td>"ND" (29)</td></tr>
<tr><td>28 ("ON")</td>   <td>"ON"</td>          <td>"DO" (30)</td></tr>
<tr><td>5 ("E")</td>     <td>"E"</td>           <td>"ONE" (31)</td></tr>
<tr><td>18 ("R")</td>    <td>"R"</td>           <td>"ER" (32)</td></tr>
</tbody></table>

<p>Note how each added string is the previously output string plus the first byte of the next string.</p>

<p>There is however a snag here. Because the decompressor is always one step behind the compressor in adding to the dictionary, it's possible that a code gets used before the decompressor has added it to the dictionary.</p>

<p>Consider compression of the string "TAN BANANAS", ignoring the space:</p>

<table border="1">
<tbody><tr><th>Input Character</th>  <th>Output Code</th> <th>Added String</th> <th>Current Code</th></tr>
<tr><td>T</td>              <td>—</td>     <td>—</td>      <td>20 ("T")</td></tr>
<tr><td>A</td>              <td>20 ("T")</td>    <td>"TA" (27)</td>    <td>1 ("A")</td></tr>
<tr><td>N</td>              <td>1 ("A")</td>     <td>"AN" (28)</td>    <td>14 ("N")</td></tr>
<tr><td>B</td>              <td>14 ("N")</td>    <td>"NB" (29)</td>    <td>2 ("B")</td></tr>
<tr><td>A</td>              <td>2 ("B")</td>     <td>"BA" (30)</td>    <td>1 ("A")</td></tr>
<tr><td>N</td>              <td>—</td>     <td>—</td>      <td>28 ("AN")</td></tr>
<tr><td>A</td>              <td>28 ("AN")</td>   <td>"ANA" (31)</td>   <td>1 ("A")</td></tr>
<tr><td>N</td>              <td>—</td>     <td>—</td>      <td>28 ("AN")</td></tr>
<tr><td>A</td>              <td>—</td>     <td>—</td>      <td>31 ("ANA")</td></tr>
<tr><td>S</td>              <td>31 ("ANA")</td>  <td>"ANAS" (32)</td>  <td>19 ("S")</td></tr>
<tr><td>—</td>          <td>19 ("S")</td>    <td>—</td>      <td>—</td></tr>
</tbody></table>

<p>What's special about this example is that the code 31 ("ANA") is added to the dictionary when processing the third "A", and then immediately gets output, which means that the decompressor will not have had a chance to add it yet:</p>

<table border="1">
<tbody><tr><th>Input Code</th>  <th>Output String</th> <th>Added String</th></tr>
<tr><td>20 ("T")</td>    <td>"T"</td>           <td>—</td></tr>
<tr><td>1 ("A")</td>     <td>"A"</td>           <td>"TA" (27)</td></tr>
<tr><td>14 ("N")</td>    <td>"N"</td>           <td>"AN" (28)</td></tr>
<tr><td>2 ("B")</td>     <td>"B"</td>           <td>"NB" (29)</td></tr>
<tr><td>28 ("AN")</td>   <td>"AN"</td>          <td>"BA" (30)</td></tr>
<tr><td>31 ???</td></tr>
</tbody></table>

<p>This is known as the LZW "KwKwK problem". If <span class="code">K</span> is a byte, <span class="code">w</span> a string of bytes, and <span class="code">Kw</span> already exists in the dictionary, compressing the string <span class="code">KwKwK</span> will cause a code for <span class="code">KwK</span> to be added to the dictionary and then be immediately used, which means the decompressor will see the code before it exists in its dictionary. (In the example, <span class="code">K</span> is "A" and <span class="code">w</span> is "N".)</p>

<p>Luckily, this is the only situation where a code can be used before it's in the decompressor's dictionary, so it can be handled as a special case. When the decompressor receives an input code which is the next code that would be added to the dictionary, it knows it's a "KwKwK" situation, and that the code corresponds to the previously output string (<span class="code">Kw</span>) extended with its first byte (<span class="code">K</span>).</p>

<p>To finish the example:</p>

<table border="1">
<tbody><tr><th>Input Code</th>  <th>Output String</th> <th>Added String</th></tr>
<tr><td>31 ("ANA")</td>  <td>"ANA"</td>         <td>"ANA" (31)</td></tr>
<tr><td>19 ("S")</td>    <td>"S"</td>           <td>"ANAS" (32)</td></tr>
</tbody></table>

<p>Expressed in pseudo-code, the decompression algorithm goes like this:</p>

<div class="highlight"><pre><span></span><span class="n">initialize_dictionary</span><span class="p">();</span>
<span class="n">current_code</span> <span class="o">=</span> <span class="n">get_input_code</span><span class="p">();</span>
<span class="n">output</span><span class="p">(</span><span class="n">current_code</span><span class="p">);</span>

<span class="k">while</span> <span class="p">(</span><span class="n">more_input_available</span><span class="p">()) {</span>
        <span class="n">previous_code</span> <span class="o">=</span> <span class="n">current_code</span><span class="p">;</span>
        <span class="n">current_code</span> <span class="o">=</span> <span class="n">get_input_code</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">current_code</span> <span class="o">==</span> <span class="n">next_unused_code</span><span class="p">()) {</span>
                <span class="cm">/* Handle the KwKwK case. */</span>
                <span class="n">dictionary</span><span class="p">[</span><span class="n">current_code</span><span class="p">]</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">previous_code</span><span class="p">]</span> <span class="o">+</span>
                                           <span class="n">dictionary</span><span class="p">[</span><span class="n">previous_code</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
                <span class="n">output</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">current_code</span><span class="p">]);
        }</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">output</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">current_code</span><span class="p">]);</span>
                <span class="n">dictionary</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">previous_code</span><span class="p">]</span> <span class="o">+</span>
                               <span class="n">dictionary</span><span class="p">[</span><span class="n">current_code</span><span class="p">][</span><span class="mi">0</span><span class="p">]);
        }
}</span>
</pre></div>


<a name="lzwdict"></a>
<h3>Maintaining the Dictionary</h3>

<p>Part of LZW's appeal is that it's relatively easy to implement. The following focuses on a practical implementation of PKZip's LZW variant.</p>

<p>Because of how the algorithm works, strings added to the dictionary are always composed of a prefix string already in the dictionary, extended with a single byte. That means dictionary entries can be represented in a memory-efficient way by storing just the code of the prefix and the extension byte.</p>

<table border="1">
<tbody><tr><th>Code</th>  <th>Prefix Code</th>   <th>Extension Byte</th></tr>
<tr><td>27 ("LO")</td>  <td>12 ("L")</td> <td>"O"</td></tr>
<tr><td>28 ("ON")</td>  <td>15 ("O")</td> <td>"N"</td></tr>
<tr><td>29 ("ND")</td>  <td>14 ("N")</td> <td>"D"</td></tr>
<tr><td>30 ("DO")</td>  <td>4 ("D")</td>  <td>"O"</td></tr>
<tr><td>31 ("ONE")</td> <td>28 ("ON")</td><td>"E"</td></tr>
<tr><td>32 ("ER")</td>  <td>5 ("E")</td>  <td>"R"</td></tr>
</tbody></table>

<p>We can think of the dictionary as a tree structure (a form of <a href="https://en.wikipedia.org/wiki/Trie">trie</a>). For example, the dictionary from <a href="https://www.hanshq.net/zip2.html#londoner">the Londoner example</a> above forms this tree:</p>

<div class="latex"><p style="margin-left: 2em"><img src="./zip2_files/tex_6f507d8f.svg" alt="LaTeX"></p></div>

<p>Each node in the tree corresponds to a code and represents the string formed when walking from the root to the node, concatenating the bytes along the way. For example, the node on the lower-right represents the string "ONE" (code 31).</p>

<p>For compression, the dictionary representation needs to support quickly looking up a string (prefix + extension byte), or to insert the string if it doesn't exist. To accommodate this, we will store the compressor's dictionary tree nodes in a hash table with the prefix code and extension byte acting as key, and the code as the value. Instead of inserting the initial one-byte strings in the dictionary, we will treat them as implicitly present. The code is available in <a href="https://www.hanshq.net/files/hwzip/shrink.c"><span class="code">shrink.c</span></a>.</p>

<div class="highlight"><pre><span></span><span class="cp">#define MAX_CODE_SIZE   13
#define HASH_BITS       (MAX_CODE_SIZE + 1) </span><span class="cm">/* For a load factor of 0.5. */</span><span class="cp">
#define HASHTAB_SIZE    (1U &lt;&lt; HASH_BITS)</span>

<span class="cm">/* Hash table where the keys are (prefix_code, ext_byte) pairs, and the values
 * are the corresponding code. If prefix_code is INVALID_CODE it means the hash
 * table slot is empty. */</span>
<span class="k">typedef struct</span> <span class="n">hashtab_t hashtab_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">hashtab_t</span> <span class="p">{</span>
        <span class="kt">uint16_t</span> <span class="n">prefix_code</span><span class="p">;</span>
        <span class="kt">uint8_t</span>  <span class="n">ext_byte</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">code</span><span class="p">;
};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hashtab_init</span><span class="p">(</span><span class="n">hashtab_t</span> <span class="o">*</span><span class="n">table</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HASHTAB_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">=</span> <span class="n">INVALID_CODE</span><span class="p">;
        }
}</span>
</pre></div>


<p>To look up a string in the dictionary, we hash the prefix code and extension byte, and then scan the hash table linearly starting at the position determined by the hash:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">hash</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">code</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">byte</span><span class="p">)
{</span>
        <span class="k">static const</span> <span class="kt">uint32_t</span> <span class="n">HASH_MUL</span> <span class="o">=</span> <span class="mi">2654435761U</span><span class="p">;</span>

        <span class="cm">/* Knuth's multiplicative hash. */</span>
        <span class="k">return</span> <span class="p">((((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">byte</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">code</span><span class="p">)</span> <span class="o">*</span> <span class="n">HASH_MUL</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">HASH_BITS</span><span class="p">);
}</span>

<span class="cm">/* Return the code corresponding to a prefix code and extension byte if it
   exists in the table, or INVALID_CODE otherwise. */</span>
<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">hashtab_find</span><span class="p">(</span><span class="k">const</span> <span class="n">hashtab_t</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">prefix_code</span><span class="p">,</span>
                             <span class="kt">uint8_t</span> <span class="n">ext_byte</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span><span class="n">prefix_code</span><span class="p">,</span> <span class="n">ext_byte</span><span class="p">);</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">prefix_code</span> <span class="o">!=</span> <span class="n">INVALID_CODE</span><span class="p">);</span>

        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">) {</span>
                <span class="cm">/* Scan until we find the key or an empty slot. */</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">HASHTAB_SIZE</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">==</span> <span class="n">prefix_code</span> <span class="o">&amp;&amp;</span>
                    <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ext_byte</span> <span class="o">==</span> <span class="n">ext_byte</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">code</span><span class="p">;
                }</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">==</span> <span class="n">INVALID_CODE</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="n">INVALID_CODE</span><span class="p">;
                }</span>
                <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">HASHTAB_SIZE</span><span class="p">;</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">hash</span><span class="p">(</span><span class="n">prefix_code</span><span class="p">,</span> <span class="n">ext_byte</span><span class="p">));
        }
}</span>
</pre></div>


<p>Inserting a string works similarly:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">hashtab_insert</span><span class="p">(</span><span class="n">hashtab_t</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">prefix_code</span><span class="p">,</span>
                           <span class="kt">uint8_t</span> <span class="n">ext_byte</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">code</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span><span class="n">prefix_code</span><span class="p">,</span> <span class="n">ext_byte</span><span class="p">);</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">prefix_code</span> <span class="o">!=</span> <span class="n">INVALID_CODE</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">code</span> <span class="o">!=</span> <span class="n">INVALID_CODE</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">hashtab_find</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">prefix_code</span><span class="p">,</span> <span class="n">ext_byte</span><span class="p">)</span> <span class="o">==</span> <span class="n">INVALID_CODE</span><span class="p">);</span>

        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">) {</span>
                <span class="cm">/* Scan until we find an empty slot. */</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">HASHTAB_SIZE</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">==</span> <span class="n">INVALID_CODE</span><span class="p">) {</span>
                        <span class="k">break</span><span class="p">;
                }</span>
                <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">HASHTAB_SIZE</span><span class="p">;</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">hash</span><span class="p">(</span><span class="n">prefix_code</span><span class="p">,</span> <span class="n">ext_byte</span><span class="p">));
        }</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">HASHTAB_SIZE</span><span class="p">);</span>
        <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">code</span> <span class="o">=</span> <span class="n">code</span><span class="p">;</span>
        <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">=</span> <span class="n">prefix_code</span><span class="p">;</span>
        <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ext_byte</span> <span class="o">=</span> <span class="n">ext_byte</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">hashtab_find</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">prefix_code</span><span class="p">,</span> <span class="n">ext_byte</span><span class="p">)</span> <span class="o">==</span> <span class="n">code</span><span class="p">);
}</span>
</pre></div>




<p>For decompression, the dictionary representation needs to support looking up or inserting a string with a specific code. This means we can keep the tree nodes in an array indexed by the code.</p>

<p>One problem with the tree representation is that when retrieving a string corresponding to a certain code, we look up the node for the code, walk from the node to the root, and encounter the string in the wrong order: it's in reverse.</p>

<p>Welch's paper suggests using a stack to output the string for a code in the right order: while walking from the node to the root, push the bytes on the stack, and afterwards output them in reverse by popping the stack until it's empty.</p>

<p>The stack approach, though it is commonly used in practice, is a little annoying because it effectively requires copying the data twice: first from the dictionary onto the stack, and then from the stack to the output destination.</p>

<p>If the length of the string were known before the tree walk, the bytes could be written directly to the output buffer in reverse. For example, if we knew that the string for code 31 ("ONE") is three bytes long, the initial byte in the tree walk (E) could be output directly to the third output position, the next byte (N) to the second, etc. Storing the string lengths in the dictionary requires a little more memory, but they are easy to add when inserting the strings: the length of a new string is the length of its prefix plus one.</p>

<p>Taking that technique one step further (thanks Nico!), observe that when the decompressor adds a new string to the dictionary, that string already exists in the output buffer: the new string is formed by taking the previously output string and appending the first character of the currently output string. So if the previously output string was <span class="code">N</span> bytes long and output at index <span class="code">I</span>, the new string is the <span class="code">N+1</span> bytes in the output buffer at position <span class="code">I</span>. If we keep track of each string's position in the output buffer, we can copy it directly and don't have to walk the tree at all. In fact, we don't even need to store the tree; storing each string's length and output buffer position is enough. (For Shrink, we still need to store the tree to handle Partical Clearing, described <a href="https://www.hanshq.net/zip2.html#lzwfull">below</a>.) This scheme requires all the previous output to be available, so would not be suitable for streaming decompression, but should be much faster when possible. In a sense, this makes in-memory LZW decompression more similar to LZ77, described <a href="https://www.hanshq.net/zip2.html#explz77">below</a>.</p>

<p>We will represent the decompressor's dictionary to support that last approach.</p>

<div class="highlight"><pre><span></span><span class="cp">#define MAX_CODE        ((1U &lt;&lt; MAX_CODE_SIZE) - 1)
#define INVALID_CODE    UINT16_MAX</span>

<span class="k">typedef struct</span> <span class="n">codetab_t codetab_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">codetab_t</span> <span class="p">{</span>
        <span class="kt">uint16_t</span> <span class="n">prefix_code</span><span class="p">;</span>   <span class="cm">/* INVALID_CODE means the entry is invalid. */</span>
        <span class="kt">uint8_t</span>  <span class="n">ext_byte</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">len</span><span class="p">;</span>
        <span class="kt">size_t</span>   <span class="n">last_dst_pos</span><span class="p">;
};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">codetab_init</span><span class="p">(</span><span class="n">codetab_t</span> <span class="o">*</span><span class="n">codetab</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

        <span class="cm">/* Codes for literal bytes. Set a phony prefix_code so they're valid. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">UINT8_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">codetab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
                <span class="n">codetab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ext_byte</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
                <span class="n">codetab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;
        }</span>

        <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">MAX_CODE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">codetab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">=</span> <span class="n">INVALID_CODE</span><span class="p">;
        }
}</span>
</pre></div>


<a name="lzwcodes"></a>
<h3>Reading and Writing Codes</h3>

<p>An important consideration when implementing LZW compression is how many bits to use for the codes, the code size.</p>

<p>When compressing 8-bit bytes, we need to use at least 9-bit codes if we want to put anything besides the initial one-byte strings in the dictionary. Using more bits for the codes allows for a larger dictionary, which can be good for compression, but the larger dictionary does not necessarily pay for the increased size of each output code.</p>

<p>For example, if we use 9-bit codes for the <a href="https://www.hanshq.net/zip2.html#londoner">Londoner example</a> above, the seven output codes would take up 63 bits. If we used 10-bit codes instead, the dictionary could hold more strings, but the output would take 70 bits, which may be larger than the uncompressed size.</p>

<p>While the LZW paper states that using 12-bit codes is common, most implementations actually use variable-length codes. Spencer Thomas's original Compress program starts with 9-bit codes which can grow up to 16 bits. GIF files use between 3 and 9 bits initially depending on the number of colours in the image, and can grow the code size up to 12 bits. The idea is to avoid the overhead of a larger code size until the dictionary grows to potentially take advantage of it.</p>

<p>In the case of Compress and GIF, the compressor starts emitting codes using the initial code size, and then increases the size when inserting a code in the dictionary that doesn't fit within the current code size. For example, if the initial code size is 9 bits, the compressor would increase the size once it inserts code 512 (which requires 10 bits) into the dictionary. The decompressor must always use the same code size as the compressor, and it maintains the size in the same way: starting at the same initial size and increasing it when adding an entry that grows the dictionary beyond the limit of the current code size. In this way, the code size is kept in sync implicitly between the compressor and decompressor, similarly to the dictionary.</p>

<p>While synchronising the code size implicitly between compressor and decompressor is elegant, it has the disadvantage that it increases the code size potentially long before any code which requires the larger size is emitted. Just because a code is added to the dictionary doesn't mean it will be used soon, or ever. Instead, some LZW compressors use a special code to signal code size increases explicitly to the decompressor. That way, they can increase the code size just before emitting a code which requires the larger size.</p>

<p>PKZip's Shrink method uses codes between 9 and 13 bits wide, and signals code size increases explicitly by emitting a control code (256) followed by a one.</p>

<p>The codes are emitted least-significant-bit first, and we will re-use the bitstream implementation <a href="https://www.hanshq.net/zip.html#bitstreams">described in the previously article</a>, which is available in <a href="https://www.hanshq.net/files/hwzip/bitstream.h"><span class="code">bitstream.h</span></a>. For reading and writing the LZW codes, we use helper functions that handle the code size adjustments internally:</p>

<div class="highlight"><pre><span></span><span class="cp">#define MIN_CODE_SIZE   9
#define MAX_CODE_SIZE   13

#define MAX_CODE        ((1U &lt;&lt; MAX_CODE_SIZE) - 1)
#define INVALID_CODE    UINT16_MAX
#define CONTROL_CODE    256
#define INC_CODE_SIZE   1</span>

<span class="cm">/* Write a code to the output bitstream, increasing the code size if necessary.
   Returns true on success. */</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">write_code</span><span class="p">(</span><span class="n">ostream_t</span> <span class="o">*</span><span class="n">os</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">code</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">code_size</span><span class="p">)
{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">code</span> <span class="o">&lt;=</span> <span class="n">MAX_CODE</span><span class="p">);</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">code</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt; *</span><span class="n">code_size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">) {</span>
                <span class="cm">/* Increase the code size. */</span>
                <span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">code_size</span> <span class="o">&lt;</span> <span class="n">MAX_CODE_SIZE</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">CONTROL_CODE</span><span class="p">,</span> <span class="o">*</span><span class="n">code_size</span><span class="p">)</span> <span class="o">||
                    !</span><span class="n">ostream_write</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">INC_CODE_SIZE</span><span class="p">,</span> <span class="o">*</span><span class="n">code_size</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }
                (</span><span class="o">*</span><span class="n">code_size</span><span class="p">)</span><span class="o">++</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="n">ostream_write</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="o">*</span><span class="n">code_size</span><span class="p">);
}</span>
</pre></div>


<p>The decompressor also needs to deal with a second control code, which will be explained in the next subsection.</p>

<div class="highlight"><pre><span></span><span class="cp">#define PARTIAL_CLEAR   2</span>

<span class="cm">/* Read the next code from the input stream and return it in next_code. Returns
   false if the end of the stream is reached. If the stream contains invalid
   data, next_code is set to INVALID_CODE but the return value is still true. */</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">read_code</span><span class="p">(</span><span class="n">istream_t</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">code_size</span><span class="p">,</span> <span class="n">codetab_t</span> <span class="o">*</span><span class="n">codetab</span><span class="p">,</span>
                      <span class="n">code_queue_t</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">next_code</span><span class="p">)
{</span>
        <span class="kt">uint16_t</span> <span class="n">code</span><span class="p">,</span> <span class="n">control_code</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="o">*</span> <span class="n">CHAR_BIT</span> <span class="o">&gt;= *</span><span class="n">code_size</span><span class="p">);</span>

        <span class="n">code</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">lsb</span><span class="p">(</span><span class="n">istream_bits</span><span class="p">(</span><span class="n">is</span><span class="p">),</span> <span class="o">*</span><span class="n">code_size</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="o">*</span><span class="n">code_size</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="cm">/* Handle regular codes (the common case). */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">!=</span> <span class="n">CONTROL_CODE</span><span class="p">) {</span>
                <span class="o">*</span><span class="n">next_code</span> <span class="o">=</span> <span class="n">code</span><span class="p">;</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;
        }</span>

        <span class="cm">/* Handle control codes. */</span>
        <span class="n">control_code</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">lsb</span><span class="p">(</span><span class="n">istream_bits</span><span class="p">(</span><span class="n">is</span><span class="p">),</span> <span class="o">*</span><span class="n">code_size</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="o">*</span><span class="n">code_size</span><span class="p">)) {</span>
                <span class="o">*</span><span class="n">next_code</span> <span class="o">=</span> <span class="n">INVALID_CODE</span><span class="p">;</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;
        }</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">control_code</span> <span class="o">==</span> <span class="n">INC_CODE_SIZE</span> <span class="o">&amp;&amp; *</span><span class="n">code_size</span> <span class="o">&lt;</span> <span class="n">MAX_CODE_SIZE</span><span class="p">) {
                (</span><span class="o">*</span><span class="n">code_size</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">read_code</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">code_size</span><span class="p">,</span> <span class="n">codetab</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">next_code</span><span class="p">);
        }</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">control_code</span> <span class="o">==</span> <span class="n">PARTIAL_CLEAR</span><span class="p">) {</span>
                <span class="n">unshrink_partial_clear</span><span class="p">(</span><span class="n">codetab</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">read_code</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">code_size</span><span class="p">,</span> <span class="n">codetab</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">next_code</span><span class="p">);
        }</span>
        <span class="o">*</span><span class="n">next_code</span> <span class="o">=</span> <span class="n">INVALID_CODE</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<a name="lzwfull"></a>
<h3>When the Dictionary Gets Full</h3>

<p>The maximum code size determines the number of possible codes and thereby the size of the dictionary. Since the LZW algorithm keeps adding strings to the dictionary, it can eventually get full. The LZW paper doesn't really address this, and it's an area where implementers can get creative.</p>

<p>The easiest solution is to do nothing: when the dictionary gets full, the program simply stops adding new strings to it, but still keeps going. This strategy was used by the original Compress program. The downside is that if the characteristics of the data change and the dictionary is no longer updated, the strings in the dictionary become less relevant and the compression suffers.</p>

<p>The solution at the other end of the spectrum is to clear the dictionary as soon as it gets full. This effectively divides the compressed data into blocks, with the algorithm "starting over" on a new block each time the dictionary fills up. This technique is used in GIF files, which have a designated "clear code" to signal when the dictionary gets cleared. The GIF compressor is free to emit this code at any time, not just when the table gets full. <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">The specification</a> points out (on the cover sheet) that the compressor may defer emitting the clear code and keep going with a full dictionary, but the implementations I've seen emit the clear code as soon as the dictionary fills up (<a href="https://github.com/ImageMagick/ImageMagick/blob/7.0.10-48/coders/gif.c#L728">ImageMagick</a>, <a href="https://gitlab.gnome.org/GNOME/gimp/-/blob/GIMP_2_10_22/plug-ins/common/file-gif-save.c#L2301">GIMP</a>).</p>

<p>Other LZW implementations use approaches somewhere in between the two above. Starting with <a href="https://groups.google.com/g/mod.sources/c/fCpRnZZ2GBw/discussion">Version 3.0</a>, the Compress program monitors the compression ratio after the dictionary fills up, and clears the table if the ratio drops, sometimes referred to as an <em>adaptive reset</em>. This allows compression to benefit from the strings in the full dictionary as long as they're useful, but also to adapt if the input changes so the dictionary becomes less relevant.</p>

<p>Phil Katz was presumably well familiar with these options. The LZW variant used by Arc, which Katz had based his PKArc program on, is called <em>Crunch</em>. It's described in the documentation for <a href="http://cd.textfiles.com/originalsw/25/arc520.com">Arc 5.20</a> as using variable-length codes and adaptive reset.
Howard Chu's <a href="https://sourceforge.net/projects/arc/files/arc/arc-5.21p/arc-5.21p.tar.gz/download">Unix port of Arc</a> has the source code and shows that the variable-length codes were between 9 and 12 bits.
In the Revision History section of <a href="http://cd.textfiles.com/originalsw/25/pkx35a35.exe">PKArc 3.5</a>'s documentation, Katz describes his Crunch implementation in version 1.1 as providing superior compression while being fully compatible with Arc. In order to stay compatible, the only thing he can have changed is when to perform adaptive resets.
PKArc 2.0 added a new compression method which Katz called <em>Squash</em>. Katz published <a href="http://cd.textfiles.com/simtel/DISK1/DISC2/ARCHIVER/SQSHINFO.DOC">some notes about the method</a>, explaining that it's similar to Crunch but with variable-length codes up to 13 bits instead of 12.
</p>

<p>Shrink, the LZW method that Katz designed for his new PKZip program, is a more complex variant. What makes it special is that it handles full dictionaries by doing what Katz calls <em>partial clearing</em>. The way it's described in the <a href="https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-2.0.txt">application note</a> is that it clears all leaf nodes from the LZW tree. In other words, it removes all the strings in the dictionary which aren't prefixes of other strings.</p>

<p>Partial clearing means the unassigned codes need to be managed differently. Normally, an LZW implementation keeps track of the next code to assign, increments it after each insert into the dictionary, and starts over when the dictionary is cleared. With partial clearing, however, one must keep track of exactly which codes are available. We will use the queue below for this purpose.</p>

<p>One way (thanks Rui!) to avoid the need for tracking unassigned codes like this would have been to renumber the used codes as part of partial clearing so that they form a contiguous set. I don't know whether Katz considered this.</p>

<div class="highlight"><pre><span></span><span class="k">typedef struct</span> <span class="n">code_queue_t code_queue_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">code_queue_t</span> <span class="p">{</span>
        <span class="kt">uint16_t</span> <span class="n">next_idx</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">codes</span><span class="p">[</span><span class="n">MAX_CODE</span> <span class="o">-</span> <span class="n">CONTROL_CODE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];
};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">code_queue_init</span><span class="p">(</span><span class="n">code_queue_t</span> <span class="o">*</span><span class="n">q</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">code_queue_size</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">code</span><span class="p">;</span>

        <span class="n">code_queue_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">code</span> <span class="o">=</span> <span class="n">CONTROL_CODE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">code</span> <span class="o">&lt;=</span> <span class="n">MAX_CODE</span><span class="p">;</span> <span class="n">code</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">q</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">[</span><span class="n">code_queue_size</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span><span class="p">;
        }</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">code_queue_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">[</span><span class="n">code_queue_size</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVALID_CODE</span><span class="p">;</span> <span class="cm">/* End-of-queue marker. */</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">next_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;
}</span>

<span class="cm">/* Return the next code in the queue, or INVALID_CODE if the queue is empty. */</span>
<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">code_queue_next</span><span class="p">(</span><span class="k">const</span> <span class="n">code_queue_t</span> <span class="o">*</span><span class="n">q</span><span class="p">)
{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next_idx</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
        <span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next_idx</span><span class="p">];
}</span>

<span class="cm">/* Return and remove the next code from the queue, or return INVALID_CODE if
   the queue is empty. */</span>
<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">code_queue_remove_next</span><span class="p">(</span><span class="n">code_queue_t</span> <span class="o">*</span><span class="n">q</span><span class="p">)
{</span>
        <span class="kt">uint16_t</span> <span class="n">code</span> <span class="o">=</span> <span class="n">code_queue_next</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">!=</span> <span class="n">INVALID_CODE</span><span class="p">) {</span>
                <span class="n">q</span><span class="o">-&gt;</span><span class="n">next_idx</span><span class="o">++</span><span class="p">;
        }</span>
        <span class="k">return</span> <span class="n">code</span><span class="p">;
}</span>
</pre></div>


<p>The queue gets updated after partial clearings. For decompression, performing partial clearing of the code table is fairly straight-forward:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">unshrink_partial_clear</span><span class="p">(</span><span class="n">codetab_t</span> <span class="o">*</span><span class="n">codetab</span><span class="p">,</span> <span class="n">code_queue_t</span> <span class="o">*</span><span class="n">queue</span><span class="p">)
{</span>
        <span class="kt">bool</span> <span class="n">is_prefix</span><span class="p">[</span><span class="n">MAX_CODE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">code_queue_size</span><span class="p">;</span>

        <span class="cm">/* Scan for codes that have been used as a prefix. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">CONTROL_CODE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">MAX_CODE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">codetab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">!=</span> <span class="n">INVALID_CODE</span><span class="p">) {</span>
                        <span class="n">is_prefix</span><span class="p">[</span><span class="n">codetab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prefix_code</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;
                }
        }</span>

        <span class="cm">/* Clear "non-prefix" codes in the table; populate the code queue. */</span>
        <span class="n">code_queue_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">CONTROL_CODE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">MAX_CODE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_prefix</span><span class="p">[</span><span class="n">i</span><span class="p">]) {</span>
                        <span class="n">codetab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">=</span> <span class="n">INVALID_CODE</span><span class="p">;</span>
                        <span class="n">queue</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">[</span><span class="n">code_queue_size</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">i</span><span class="p">;
                }
        }</span>
        <span class="n">queue</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">[</span><span class="n">code_queue_size</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVALID_CODE</span><span class="p">;</span> <span class="cm">/* End-of-queue marker. */</span>
        <span class="n">queue</span><span class="o">-&gt;</span><span class="n">next_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;
}</span>
</pre></div>


<p>For compression, partial clearing gets a bit more complicated because of the hash table. Instead of trying to remove entries from the hash table, we insert the non-cleared entries into a new one:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">shrink_partial_clear</span><span class="p">(</span><span class="n">hashtab_t</span> <span class="o">*</span><span class="n">hashtab</span><span class="p">,</span> <span class="n">code_queue_t</span> <span class="o">*</span><span class="n">queue</span><span class="p">)
{</span>
        <span class="kt">bool</span> <span class="n">is_prefix</span><span class="p">[</span><span class="n">MAX_CODE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
        <span class="n">hashtab_t new_hashtab</span><span class="p">[</span><span class="n">HASHTAB_SIZE</span><span class="p">];</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">code_queue_size</span><span class="p">;</span>

        <span class="cm">/* Scan for codes that have been used as a prefix. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HASHTAB_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">hashtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">!=</span> <span class="n">INVALID_CODE</span><span class="p">) {</span>
                        <span class="n">is_prefix</span><span class="p">[</span><span class="n">hashtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prefix_code</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;
                }
        }</span>

        <span class="cm">/* Build a new hash table with only the "prefix codes". */</span>
        <span class="n">hashtab_init</span><span class="p">(</span><span class="n">new_hashtab</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HASHTAB_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">hashtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">==</span> <span class="n">INVALID_CODE</span> <span class="o">||
                    !</span><span class="n">is_prefix</span><span class="p">[</span><span class="n">hashtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">code</span><span class="p">]) {</span>
                        <span class="k">continue</span><span class="p">;
                }</span>
                <span class="n">hashtab_insert</span><span class="p">(</span><span class="n">new_hashtab</span><span class="p">,</span> <span class="n">hashtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prefix_code</span><span class="p">,</span>
                               <span class="n">hashtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ext_byte</span><span class="p">,</span> <span class="n">hashtab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">code</span><span class="p">);
        }</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">hashtab</span><span class="p">,</span> <span class="n">new_hashtab</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">new_hashtab</span><span class="p">));</span>

        <span class="cm">/* Populate the queue with the "non-prefix" codes. */</span>
        <span class="n">code_queue_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">CONTROL_CODE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">MAX_CODE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_prefix</span><span class="p">[</span><span class="n">i</span><span class="p">]) {</span>
                        <span class="n">queue</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">[</span><span class="n">code_queue_size</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">i</span><span class="p">;
                }
        }</span>
        <span class="n">queue</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">[</span><span class="n">code_queue_size</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVALID_CODE</span><span class="p">;</span> <span class="cm">/* End-of-queue marker. */</span>
        <span class="n">queue</span><span class="o">-&gt;</span><span class="n">next_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;
}</span>
</pre></div>


<a name="lzwsurprise"></a>
<h3>Surprising Effects of Partial Clearing</h3>

<p>Partial clearing, at least the way Shrink does it, has a problem which I don't think Katz foresaw. Let's say we're inserting a new string "BANANA" into the dictionary. The prefix ("BANAN") has code 456, but the dictionary is full so no more codes are available. A partial clearing is performed. Now, if "BANAN" was not used as a prefix for any other strings in the dictionary so far, it will be removed from the dictionary and its code put back in the queue of available codes. It would have been reasonable to not remove that code since it's just about to be used as a prefix, but Katz did not make that choice.</p>

<p>Let's say that another code, 345, was also freed up in the partial clearing and is first in the code queue. It will be used for the newly inserted string with prefix code 456 and extension byte "A":</p>

<table border="1">
<tbody><tr><th>Code</th>  <th>Prefix</th> <th>Extension Byte</th> <th>String</th></tr>
<tr><td>345</td>   <td>456</td>    <td>A</td>              <td>???A</td></tr>
</tbody></table>

<p>Note that since 456 was cleared from the dictionary, it no longer represents "BANAN", and now we have code 345 in the dictionary with a prefix that doesn't exist. It's not a catastrophe since the compressor will not emit the code, but it's an odd state to be in.</p>

<div class="latex"><p style="margin-left: 2em"><img src="./zip2_files/tex_c08efa77.svg" alt="LaTeX"></p></div>

<p>If compression continues for a while, it's likely that 456 will get used when a new string is inserted into the dictionary, let's say "ERIC"; now suddenly 456 is a valid prefix for 345:</p>

<table border="1">
<tbody><tr><th>Code</th>  <th>Prefix</th> <th>Extension Byte</th> <th>String</th></tr>
<tr><td>345</td>   <td>456</td>    <td>A</td>              <td>ERICA</td></tr>
<tr><td>456</td>   <td>...</td>    <td>C</td>              <td>ERIC</td></tr>
</tbody></table>

<p>Surprisingly, we've ended up with a code for "ERICA" in the dictionary without intentionally inserting it. In fact, that string might not exist in the source data at all!</p>
<!-- Info-Zip notes the "orphan" node problem here: https://github.com/madler/unzip/blob/v6.00b1/unshrink.c#L29 -->

<p>A second variation of this problem occurs if the prefix code is cleared and then becomes the first code in the queue of available codes. For example, let's say we're again inserting "BANANA", that the prefix ("BANAN") has code 456, and that the dictionary is full. Partial clearing is performed, and 456 becomes the first available code in the queue. Code 456 will now be inserted with itself as its prefix:</p>

<table border="1">
<tbody><tr><th>Code</th>  <th>Prefix</th> <th>Extension Byte</th> <th>String</th></tr>
<tr><td>456</td>   <td>456</td>    <td>A</td>              <td>???</td></tr>
</tbody></table>

<div class="latex"><p style="margin-left: 2em"><img src="./zip2_files/tex_a35a3f12.svg" alt="LaTeX"></p></div>

<p>Again, a most peculiar state. It's not a disaster, since the compressor will never use this code. However, the code is now lost forever: it will not become available after future partial clearings since it is used as a prefix, albeit in a pathological way. Does this ever happen? Yes. For example, when compressing a sufficiently long string of repeated bytes, PKZip's Shrink implementation will eventually tie up all available codes this way, leaving the literal (one-byte) codes as the only usable entries in the dictionary!</p>

<p>Because these pathological codes would never be used by the compressor, it's possible that Katz never noticed them. But for our implementation, where we want to store the length of each string in the dictionary during decompression, we need to handle that a string with an invalid prefix doesn't have a well-defined length until its prefix becomes valid.</p>

<a name="lzwfinish"></a>
<h3>Finishing the Implementation</h3>

<p>With the code for managing the dictionary, reading and emitting codes, and performing partial clearing from above, we can now finish the Shrink implementation:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Compress (shrink) the data in src into dst. The number of bytes output, at
   most dst_cap, is stored in *dst_used. Returns false if there is not enough
   room in dst. */</span>
<span class="kt">bool</span> <span class="nf">hwshrink</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">src_len</span><span class="p">,</span>
              <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">dst_used</span><span class="p">)
{</span>
        <span class="n">hashtab_t table</span><span class="p">[</span><span class="n">HASHTAB_SIZE</span><span class="p">];</span>
        <span class="n">code_queue_t queue</span><span class="p">;</span>
        <span class="n">ostream_t os</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">code_size</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">ext_byte</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">curr_code</span><span class="p">,</span> <span class="n">next_code</span><span class="p">,</span> <span class="n">new_code</span><span class="p">;</span>

        <span class="n">hashtab_init</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
        <span class="n">code_queue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
        <span class="n">ostream_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">dst_cap</span><span class="p">);</span>
        <span class="n">code_size</span> <span class="o">=</span> <span class="n">MIN_CODE_SIZE</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">src_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="o">*</span><span class="n">dst_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;
        }</span>

        <span class="n">curr_code</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">src_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">ext_byte</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                <span class="cm">/* Search for a code with the current prefix + byte. */</span>
                <span class="n">next_code</span> <span class="o">=</span> <span class="n">hashtab_find</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">curr_code</span><span class="p">,</span> <span class="n">ext_byte</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">next_code</span> <span class="o">!=</span> <span class="n">INVALID_CODE</span><span class="p">) {</span>
                        <span class="n">curr_code</span> <span class="o">=</span> <span class="n">next_code</span><span class="p">;</span>
                        <span class="k">continue</span><span class="p">;
                }</span>

                <span class="cm">/* Write out the current code. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_code</span><span class="p">(</span><span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">curr_code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">code_size</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>

                <span class="cm">/* Assign a new code to the current prefix + byte. */</span>
                <span class="n">new_code</span> <span class="o">=</span> <span class="n">code_queue_remove_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">new_code</span> <span class="o">==</span> <span class="n">INVALID_CODE</span><span class="p">) {</span>
                        <span class="cm">/* Try freeing up codes by partial clearing. */</span>
                        <span class="n">shrink_partial_clear</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">CONTROL_CODE</span><span class="p">,</span> <span class="n">code_size</span><span class="p">)</span> <span class="o">||
                            !</span><span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">PARTIAL_CLEAR</span><span class="p">,</span> <span class="n">code_size</span><span class="p">)) {</span>
                                <span class="k">return</span> <span class="nb">false</span><span class="p">;
                        }</span>
                        <span class="n">new_code</span> <span class="o">=</span> <span class="n">code_queue_remove_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);
                }</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">new_code</span> <span class="o">!=</span> <span class="n">INVALID_CODE</span><span class="p">) {</span>
                        <span class="n">hashtab_insert</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">curr_code</span><span class="p">,</span> <span class="n">ext_byte</span><span class="p">,</span> <span class="n">new_code</span><span class="p">);
                }</span>

                <span class="cm">/* Reset the parser starting at the byte. */</span>
                <span class="n">curr_code</span> <span class="o">=</span> <span class="n">ext_byte</span><span class="p">;
        }</span>

        <span class="cm">/* Write out the last code. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_code</span><span class="p">(</span><span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">curr_code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">code_size</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="o">*</span><span class="n">dst_used</span> <span class="o">=</span> <span class="n">ostream_bytes_written</span><span class="p">(</span><span class="o">&amp;</span><span class="n">os</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<p>Decompressing, unshrinking, is a bit more complicated, especially because of the peculiar effects of partial clearing described above. We have split the logic for outputting a string from the dictionary into a separate function:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Output the string represented by a code into dst at dst_pos. Returns
 * HWUNSHRINK_OK on success, and also updates *first_byte and *len with the
 * first byte and length of the output string, respectively. */</span>
<span class="k">static</span> <span class="n">unshrnk_stat_t</span> <span class="nf">output_code</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">code</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dst_pos</span><span class="p">,</span>
                                  <span class="kt">size_t</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">prev_code</span><span class="p">,</span>
                                  <span class="n">codetab_t</span> <span class="o">*</span><span class="n">codetab</span><span class="p">,</span> <span class="n">code_queue_t</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span>
                                  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">first_byte</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">)
{</span>
        <span class="kt">uint16_t</span> <span class="n">prefix_code</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">code</span> <span class="o">&lt;=</span> <span class="n">MAX_CODE</span> <span class="o">&amp;&amp;</span> <span class="n">code</span> <span class="o">!=</span> <span class="n">CONTROL_CODE</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">dst_pos</span> <span class="o">&lt;</span> <span class="n">dst_cap</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">&lt;=</span> <span class="n">UINT8_MAX</span><span class="p">) {</span>
                <span class="cm">/* Output literal byte. */</span>
                <span class="o">*</span><span class="n">first_byte</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">code</span><span class="p">;</span>
                <span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">code</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">HWUNSHRINK_OK</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">codetab</span><span class="p">[</span><span class="n">code</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">==</span> <span class="n">INVALID_CODE</span> <span class="o">||</span>
            <span class="n">codetab</span><span class="p">[</span><span class="n">code</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">==</span> <span class="n">code</span><span class="p">) {</span>
                <span class="cm">/* Reject invalid codes. Self-referential codes may exist in
                 * the table but cannot be used. */</span>
                <span class="k">return</span> <span class="n">HWUNSHRINK_ERR</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">codetab</span><span class="p">[</span><span class="n">code</span><span class="p">].</span><span class="n">len</span> <span class="o">!=</span> <span class="n">UNKNOWN_LEN</span><span class="p">) {</span>
                <span class="cm">/* Output string with known length (the common case). */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dst_cap</span> <span class="o">-</span> <span class="n">dst_pos</span> <span class="o">&lt;</span> <span class="n">codetab</span><span class="p">[</span><span class="n">code</span><span class="p">].</span><span class="n">len</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="n">HWUNSHRINK_FULL</span><span class="p">;
                }</span>
                <span class="n">copy_from_prev_pos</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="n">codetab</span><span class="p">[</span><span class="n">code</span><span class="p">].</span><span class="n">last_dst_pos</span><span class="p">,</span>
                                   <span class="n">dst_pos</span><span class="p">,</span> <span class="n">codetab</span><span class="p">[</span><span class="n">code</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>
                <span class="o">*</span><span class="n">first_byte</span> <span class="o">=</span> <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span><span class="p">];</span>
                <span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">codetab</span><span class="p">[</span><span class="n">code</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">HWUNSHRINK_OK</span><span class="p">;
        }</span>

        <span class="cm">/* Output a string of unknown length. This happens when the prefix
           was invalid (due to partial clearing) when the code was inserted into
           the table. The prefix can then become valid when it's added to the
           table at a later point. */</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">codetab</span><span class="p">[</span><span class="n">code</span><span class="p">].</span><span class="n">len</span> <span class="o">==</span> <span class="n">UNKNOWN_LEN</span><span class="p">);</span>
        <span class="n">prefix_code</span> <span class="o">=</span> <span class="n">codetab</span><span class="p">[</span><span class="n">code</span><span class="p">].</span><span class="n">prefix_code</span><span class="p">;</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">prefix_code</span> <span class="o">&gt;</span> <span class="n">CONTROL_CODE</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">prefix_code</span> <span class="o">==</span> <span class="n">code_queue_next</span><span class="p">(</span><span class="n">queue</span><span class="p">)) {</span>
                <span class="cm">/* The prefix code hasn't been added yet, but we were just
                   about to: the KwKwK case. Add the previous string extended
                   with its first byte. */</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">codetab</span><span class="p">[</span><span class="n">prev_code</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">!=</span> <span class="n">INVALID_CODE</span><span class="p">);</span>
                <span class="n">codetab</span><span class="p">[</span><span class="n">prefix_code</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">=</span> <span class="n">prev_code</span><span class="p">;</span>
                <span class="n">codetab</span><span class="p">[</span><span class="n">prefix_code</span><span class="p">].</span><span class="n">ext_byte</span> <span class="o">= *</span><span class="n">first_byte</span><span class="p">;</span>
                <span class="n">codetab</span><span class="p">[</span><span class="n">prefix_code</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">codetab</span><span class="p">[</span><span class="n">prev_code</span><span class="p">].</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">codetab</span><span class="p">[</span><span class="n">prefix_code</span><span class="p">].</span><span class="n">last_dst_pos</span> <span class="o">=</span>
                        <span class="n">codetab</span><span class="p">[</span><span class="n">prev_code</span><span class="p">].</span><span class="n">last_dst_pos</span><span class="p">;</span>
                <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span><span class="p">]</span> <span class="o">= *</span><span class="n">first_byte</span><span class="p">;
        }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">codetab</span><span class="p">[</span><span class="n">prefix_code</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">==</span> <span class="n">INVALID_CODE</span><span class="p">) {</span>
                <span class="cm">/* The prefix code is still invalid. */</span>
                <span class="k">return</span> <span class="n">HWUNSHRINK_ERR</span><span class="p">;
        }</span>

        <span class="cm">/* Output the prefix string, then the extension byte. */</span>
        <span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">codetab</span><span class="p">[</span><span class="n">prefix_code</span><span class="p">].</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dst_cap</span> <span class="o">-</span> <span class="n">dst_pos</span> <span class="o">&lt; *</span><span class="n">len</span><span class="p">) {</span>
                <span class="k">return</span> <span class="n">HWUNSHRINK_FULL</span><span class="p">;
        }</span>
        <span class="n">copy_from_prev_pos</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="n">codetab</span><span class="p">[</span><span class="n">prefix_code</span><span class="p">].</span><span class="n">last_dst_pos</span><span class="p">,</span>
                           <span class="n">dst_pos</span><span class="p">,</span> <span class="n">codetab</span><span class="p">[</span><span class="n">prefix_code</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>
        <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span> <span class="o">+ *</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">codetab</span><span class="p">[</span><span class="n">code</span><span class="p">].</span><span class="n">ext_byte</span><span class="p">;</span>
        <span class="o">*</span><span class="n">first_byte</span> <span class="o">=</span> <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span><span class="p">];</span>

        <span class="cm">/* Update the code table now that the string has a length and pos. */</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">prev_code</span> <span class="o">!=</span> <span class="n">code</span><span class="p">);</span>
        <span class="n">codetab</span><span class="p">[</span><span class="n">code</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="o">*</span><span class="n">len</span><span class="p">;</span>
        <span class="n">codetab</span><span class="p">[</span><span class="n">code</span><span class="p">].</span><span class="n">last_dst_pos</span> <span class="o">=</span> <span class="n">dst_pos</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">HWUNSHRINK_OK</span><span class="p">;
}</span>
</pre></div>


<p>The routine for actually copying out the string works by copying eight bytes at a time, which means most strings just need one iteration of the copying loop:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Copy len bytes from dst[prev_pos] to dst[dst_pos]. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">copy_from_prev_pos</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dst_cap</span><span class="p">,</span>
                               <span class="kt">size_t</span> <span class="n">prev_pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dst_pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">tmp</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">dst_pos</span> <span class="o">&lt;</span> <span class="n">dst_cap</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">prev_pos</span> <span class="o">&lt;</span> <span class="n">dst_pos</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">dst_cap</span> <span class="o">-</span> <span class="n">dst_pos</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">round_up</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dst_cap</span> <span class="o">-</span> <span class="n">dst_pos</span><span class="p">) {</span>
                <span class="cm">/* Not enough room in dst for the sloppy copy below. */</span>
                <span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">prev_pos</span><span class="p">],</span> <span class="n">len</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">prev_pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">dst_pos</span><span class="p">) {</span>
                <span class="cm">/* Benign one-byte overlap possible in the KwKwK case. */</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">prev_pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">==</span> <span class="n">dst_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">dst</span><span class="p">[</span><span class="n">prev_pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">dst</span><span class="p">[</span><span class="n">prev_pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);
        }</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">do</span> <span class="p">{</span>
                <span class="cm">/* Sloppy copy: 64 bits at a time; a few extra don't matter. */</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">prev_pos</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span> <span class="mi">8</span><span class="p">);</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;
        }</span> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">);
}</span>
</pre></div>


<p>With all that in place we can finally write the decompression function:</p>

<div class="highlight"><pre><span></span><span class="k">typedef enum</span> <span class="p">{</span>
        <span class="n">HWUNSHRINK_OK</span><span class="p">,</span>   <span class="cm">/* Unshrink was successful. */</span>
        <span class="n">HWUNSHRINK_FULL</span><span class="p">,</span> <span class="cm">/* Not enough room in the output buffer. */</span>
        <span class="n">HWUNSHRINK_ERR</span>   <span class="cm">/* Error in the input data. */</span>
<span class="p">}</span> <span class="n">unshrnk_stat_t</span><span class="p">;</span>

<span class="cm">/* Decompress (unshrink) the data in src. The number of input bytes used, at
   most src_len, is stored in *src_used on success. Output is written to dst.
   The number of bytes written, at most dst_cap, is stored in *dst_used on
   success. */</span>
<span class="n">unshrnk_stat_t</span> <span class="nf">hwunshrink</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">src_len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">src_used</span><span class="p">,</span>
                          <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">dst_used</span><span class="p">)
{</span>
        <span class="n">codetab_t codetab</span><span class="p">[</span><span class="n">MAX_CODE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">code_queue_t queue</span><span class="p">;</span>
        <span class="n">istream_t is</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">code_size</span><span class="p">,</span> <span class="n">dst_pos</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">curr_code</span><span class="p">,</span> <span class="n">prev_code</span><span class="p">,</span> <span class="n">new_code</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">first_byte</span><span class="p">;</span>
        <span class="n">unshrnk_stat_t s</span><span class="p">;</span>

        <span class="n">codetab_init</span><span class="p">(</span><span class="n">codetab</span><span class="p">);</span>
        <span class="n">code_queue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
        <span class="n">istream_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">src_len</span><span class="p">);</span>
        <span class="n">code_size</span> <span class="o">=</span> <span class="n">MIN_CODE_SIZE</span><span class="p">;</span>
        <span class="n">dst_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/* Handle the first code separately since there is no previous code. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_code</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">code_size</span><span class="p">,</span> <span class="n">codetab</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr_code</span><span class="p">)) {</span>
                <span class="o">*</span><span class="n">src_used</span> <span class="o">=</span> <span class="n">istream_bytes_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">);</span>
                <span class="o">*</span><span class="n">dst_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">HWUNSHRINK_OK</span><span class="p">;
        }</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">curr_code</span> <span class="o">!=</span> <span class="n">CONTROL_CODE</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">curr_code</span> <span class="o">&gt;</span> <span class="n">UINT8_MAX</span><span class="p">) {</span>
                <span class="k">return</span> <span class="n">HWUNSHRINK_ERR</span><span class="p">;</span> <span class="cm">/* The first code must be a literal. */</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dst_pos</span> <span class="o">==</span> <span class="n">dst_cap</span><span class="p">) {</span>
                <span class="k">return</span> <span class="n">HWUNSHRINK_FULL</span><span class="p">;
        }</span>
        <span class="n">first_byte</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">curr_code</span><span class="p">;</span>
        <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">curr_code</span><span class="p">;</span>
        <span class="n">codetab</span><span class="p">[</span><span class="n">curr_code</span><span class="p">].</span><span class="n">last_dst_pos</span> <span class="o">=</span> <span class="n">dst_pos</span><span class="p">;</span>
        <span class="n">dst_pos</span><span class="o">++</span><span class="p">;</span>

        <span class="n">prev_code</span> <span class="o">=</span> <span class="n">curr_code</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">read_code</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">code_size</span><span class="p">,</span> <span class="n">codetab</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr_code</span><span class="p">)) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">curr_code</span> <span class="o">==</span> <span class="n">INVALID_CODE</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="n">HWUNSHRINK_ERR</span><span class="p">;
                }</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dst_pos</span> <span class="o">==</span> <span class="n">dst_cap</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="n">HWUNSHRINK_FULL</span><span class="p">;
                }</span>

                <span class="cm">/* Handle KwKwK: next code used before being added. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">curr_code</span> <span class="o">==</span> <span class="n">code_queue_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">)) {</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">codetab</span><span class="p">[</span><span class="n">prev_code</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">==</span> <span class="n">INVALID_CODE</span><span class="p">) {</span>
                                <span class="cm">/* The previous code is no longer valid. */</span>
                                <span class="k">return</span> <span class="n">HWUNSHRINK_ERR</span><span class="p">;
                        }</span>
                        <span class="cm">/* Extend the previous code with its first byte. */</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">curr_code</span> <span class="o">!=</span> <span class="n">prev_code</span><span class="p">);</span>
                        <span class="n">codetab</span><span class="p">[</span><span class="n">curr_code</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">=</span> <span class="n">prev_code</span><span class="p">;</span>
                        <span class="n">codetab</span><span class="p">[</span><span class="n">curr_code</span><span class="p">].</span><span class="n">ext_byte</span> <span class="o">=</span> <span class="n">first_byte</span><span class="p">;</span>
                        <span class="n">codetab</span><span class="p">[</span><span class="n">curr_code</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">codetab</span><span class="p">[</span><span class="n">prev_code</span><span class="p">].</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="n">codetab</span><span class="p">[</span><span class="n">curr_code</span><span class="p">].</span><span class="n">last_dst_pos</span> <span class="o">=</span>
                                <span class="n">codetab</span><span class="p">[</span><span class="n">prev_code</span><span class="p">].</span><span class="n">last_dst_pos</span><span class="p">;</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">dst_pos</span> <span class="o">&lt;</span> <span class="n">dst_cap</span><span class="p">);</span>
                        <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_byte</span><span class="p">;
                }</span>

                <span class="cm">/* Output the string represented by the current code. */</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">output_code</span><span class="p">(</span><span class="n">curr_code</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">dst_pos</span><span class="p">,</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="n">prev_code</span><span class="p">,</span>
                                <span class="n">codetab</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_byte</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">HWUNSHRINK_OK</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="n">s</span><span class="p">;
                }</span>

                <span class="cm">/* Verify that the output matches walking the prefixes. */</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">curr_code</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">codetab</span><span class="p">[</span><span class="n">c</span><span class="p">].</span><span class="n">len</span> <span class="o">==</span> <span class="n">len</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">codetab</span><span class="p">[</span><span class="n">c</span><span class="p">].</span><span class="n">ext_byte</span> <span class="o">==</span>
                               <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">codetab</span><span class="p">[</span><span class="n">c</span><span class="p">].</span><span class="n">prefix_code</span><span class="p">;
                }</span>

                <span class="cm">/* Add a new code to the string table if there's room.
                   The string is the previous code's string extended with
                   the first byte of the current code's string. */</span>
                <span class="n">new_code</span> <span class="o">=</span> <span class="n">code_queue_remove_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">new_code</span> <span class="o">!=</span> <span class="n">INVALID_CODE</span><span class="p">) {</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">codetab</span><span class="p">[</span><span class="n">prev_code</span><span class="p">].</span><span class="n">last_dst_pos</span> <span class="o">&lt;</span> <span class="n">dst_pos</span><span class="p">);</span>
                        <span class="n">codetab</span><span class="p">[</span><span class="n">new_code</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">=</span> <span class="n">prev_code</span><span class="p">;</span>
                        <span class="n">codetab</span><span class="p">[</span><span class="n">new_code</span><span class="p">].</span><span class="n">ext_byte</span> <span class="o">=</span> <span class="n">first_byte</span><span class="p">;</span>
                        <span class="n">codetab</span><span class="p">[</span><span class="n">new_code</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">codetab</span><span class="p">[</span><span class="n">prev_code</span><span class="p">].</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="n">codetab</span><span class="p">[</span><span class="n">new_code</span><span class="p">].</span><span class="n">last_dst_pos</span> <span class="o">=</span>
                                <span class="n">codetab</span><span class="p">[</span><span class="n">prev_code</span><span class="p">].</span><span class="n">last_dst_pos</span><span class="p">;</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">codetab</span><span class="p">[</span><span class="n">prev_code</span><span class="p">].</span><span class="n">prefix_code</span> <span class="o">==</span> <span class="n">INVALID_CODE</span><span class="p">) {</span>
                                <span class="cm">/* prev_code was invalidated in a partial
                                 * clearing. Until that code is re-used, the
                                 * string represented by new_code is
                                 * indeterminate. */</span>
                                <span class="n">codetab</span><span class="p">[</span><span class="n">new_code</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">UNKNOWN_LEN</span><span class="p">;
                        }</span>
                        <span class="cm">/* If prev_code was invalidated in a partial clearing,
                         * it's possible that new_code==prev_code, in which
                         * case it will never be used or cleared. */</span>
                <span class="p">}</span>

                <span class="n">codetab</span><span class="p">[</span><span class="n">curr_code</span><span class="p">].</span><span class="n">last_dst_pos</span> <span class="o">=</span> <span class="n">dst_pos</span><span class="p">;</span>
                <span class="n">dst_pos</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

                <span class="n">prev_code</span> <span class="o">=</span> <span class="n">curr_code</span><span class="p">;
        }</span>

        <span class="o">*</span><span class="n">src_used</span> <span class="o">=</span> <span class="n">istream_bytes_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">);</span>
        <span class="o">*</span><span class="n">dst_used</span> <span class="o">=</span> <span class="n">dst_pos</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">HWUNSHRINK_OK</span><span class="p">;
}</span>
</pre></div>



<a name="reduce"></a>
<h2>Methods 2–5: Reduce / Expand</h2>

<p>Access to information was very different back in the late 1980s when PKZip was developed. Even though many fundamental compression techniques are much older, learning about them may not have been so easy. While we can just search the web for information today, the web didn't exist back then. Accessing academic papers, or even books on compression, would have been difficult without access to a good university library.</p>

<p>Katz presumably learned about LZW compression from reading Welch's article and working with SEA's Arc program. PKZip's next compression method, Reduce, uses LZ77 compression, which he appears to have learned about from a program called <a href="http://cd.textfiles.com/simtel/simtel9510/disk2/DISC2/COMPRESS/SCRNC102.ZIP">Scrnch</a>, by Graeme W. McRae. The <span class="code">sdk.doc</span> file in <a href="http://cd.textfiles.com/originalsw/25/pkz080.zip">PKZip 0.80</a> says that Katz licensed the technology from McRae for use in PKZip. This is also discussed in a <a href="http://cd.textfiles.com/rbbsv3n1/pool/pkpolicy.zip">review of PKZip by Robert Blacher</a>.</p>

<p>Reduce is perhaps the most exotic of PKZip's compression methods. It was part of the earliest PKZip versions behind the <span class="code">-e</span> flag for "extra compression", but after the introduction of the Implode method <a href="https://www.hanshq.net/zip2.html#implode">described later</a>, PKZip would no longer perform Reduce compression, preferring Shrink or Implode instead. Decompressing, "expanding", reduced files was still supported, though.</p>

<p>The compression combines LZ77 dictionary compression with a simple statistical compression mechanism, <em>follower sets</em>. Even though method numbers 2–5 refer to this method, it's just one method with four different "compression factors".</p>

<div style="text-align: center">
<div class="latex"><p style="margin-left: 2em"><img src="./zip2_files/tex_659d1fbf.svg" alt="LaTeX"></p></div>
</div>

<p>We will describe the method by walking through an implementation, starting with the code for decompression. The code is available in <a href="https://www.hanshq.net/files/hwzip/reduce.h"><span class="code">reduce.h</span></a> and <a href="https://www.hanshq.net/files/hwzip/reduce.c"><span class="code">reduce.c</span></a>.</p>

<a name="expfollowers"></a>
<h3>Expand: Follower Sets</h3>

<p>Reduce-compressed data starts with 256 <em>follower sets</em>, one for each possible byte. Each set contains up to 32 follower bytes, bytes which commonly occur immediately after the byte whose set they belong to. For example, in English text a <span class="code">T</span> is frequently followed by an <span class="code">H</span>, so <span class="code">H</span> might be included in the follower set for <span class="code">T</span>.</p>

<p>Each follower set is preceded by a 6-bit number indicating the size of the set, followed by the bytes in that set. For some reason the sets come in reverse order, with the set for byte 255 first and byte 0 last.</p>

<div class="highlight"><pre><span></span><span class="cm">/* Number of bits used to represent indices in a follower set of size n. */</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="nf">follower_idx_bw</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)
{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">) {</span> <span class="k">return</span> <span class="mi">5</span><span class="p">; }</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)  {</span> <span class="k">return</span> <span class="mi">4</span><span class="p">; }</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)  {</span> <span class="k">return</span> <span class="mi">3</span><span class="p">; }</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)  {</span> <span class="k">return</span> <span class="mi">2</span><span class="p">; }</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)  {</span> <span class="k">return</span> <span class="mi">1</span><span class="p">; }</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;
}</span>

<span class="k">typedef struct</span> <span class="n">follower_set_t follower_set_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">follower_set_t</span> <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="n">size</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">idx_bw</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">followers</span><span class="p">[</span><span class="mi">32</span><span class="p">];
};</span>

<span class="cm">/* Read the follower sets from is into fsets. Returns true on success. */</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">read_follower_sets</span><span class="p">(</span><span class="n">istream_t</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="n">follower_set_t</span> <span class="o">*</span><span class="n">fsets</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">n</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">) {</span>
                <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">lsb</span><span class="p">(</span><span class="n">istream_bits</span><span class="p">(</span><span class="n">is</span><span class="p">),</span> <span class="mi">6</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="mi">6</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>
                <span class="n">fsets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
                <span class="n">fsets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">idx_bw</span> <span class="o">=</span> <span class="n">follower_idx_bw</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

                <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">fsets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">) {</span>
                        <span class="n">fsets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">followers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">istream_bits</span><span class="p">(</span><span class="n">is</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="mi">8</span><span class="p">)) {</span>
                                <span class="k">return</span> <span class="nb">false</span><span class="p">;
                        }
                }
        }</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<p>After reading the follower sets, the decompressor processes the input bitstream into a series of bytes. To produce a byte, the follower set of the previous byte is checked. If the previous byte has a non-empty follower set, a single bit is read to decide whether to use the set or not. If the set is used, an index into the set is read from the bitstream, with the number of bits read depending on the size of the set.</p>

<p>For example, if the follower set for <span class="code">T</span> consists of the letters <span class="code">H</span> and <span class="code">E</span> (in that order), a single bit would be used for indexing into the set. So if the previous character was <span class="code">T</span>, an <span class="code">E</span> would be represented by a 0 bit to indicate that the follower set is being used, followed by a 1 bit to select <span class="code">E</span> from the set.</p>

<p>This way, fewer bits are used to represent frequent pairs of bytes, a simple context-based statistical compression.</p>

<div class="highlight"><pre><span></span><span class="cm">/* Read the next byte from is, decoded based on prev_byte and the follower sets.
   The byte is returned in *out_byte. The function returns true on success,
   and false on bad data or end of input. */</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">read_next_byte</span><span class="p">(</span><span class="n">istream_t</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">prev_byte</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">follower_set_t</span> <span class="o">*</span><span class="n">fsets</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">out_byte</span><span class="p">)
{</span>
        <span class="kt">uint64_t</span> <span class="n">bits</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">idx_bw</span><span class="p">,</span> <span class="n">follower_idx</span><span class="p">;</span>

        <span class="n">bits</span> <span class="o">=</span> <span class="n">istream_bits</span><span class="p">(</span><span class="n">is</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">fsets</span><span class="p">[</span><span class="n">prev_byte</span><span class="p">].</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="cm">/* No followers; read a literal byte. */</span>
                <span class="o">*</span><span class="n">out_byte</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">bits</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="mi">8</span><span class="p">);
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">) {</span>
                <span class="cm">/* Don't use the follower set; read a literal byte. */</span>
                <span class="o">*</span><span class="n">out_byte</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">bits</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);
        }</span>

        <span class="cm">/* The bits represent the index of a follower byte. */</span>
        <span class="n">idx_bw</span> <span class="o">=</span> <span class="n">fsets</span><span class="p">[</span><span class="n">prev_byte</span><span class="p">].</span><span class="n">idx_bw</span><span class="p">;</span>
        <span class="n">follower_idx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">lsb</span><span class="p">(</span><span class="n">bits</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">idx_bw</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">follower_idx</span> <span class="o">&gt;=</span> <span class="n">fsets</span><span class="p">[</span><span class="n">prev_byte</span><span class="p">].</span><span class="n">size</span><span class="p">) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>
        <span class="o">*</span><span class="n">out_byte</span> <span class="o">=</span> <span class="n">fsets</span><span class="p">[</span><span class="n">prev_byte</span><span class="p">].</span><span class="n">followers</span><span class="p">[</span><span class="n">follower_idx</span><span class="p">];</span>
        <span class="k">return</span> <span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">idx_bw</span><span class="p">);
}</span>
</pre></div>


<a name="explz77"></a>
<h3>Expand: LZ77</h3>

<p>The second ingredient in Reduce compression is an algorithm which, as described in the PKZip <a href="https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-2.0.txt">application note</a>, "compresses repeated byte sequences". This description has led to a common misconception that it's some form of <a href="https://en.wikipedia.org/wiki/Run-length_encoding">run-length encoding</a>, but it actually means a form of LZ77 compression.</p>

<p>LZ77 is described in detail <a href="https://www.hanshq.net/zip.html#lz">in the previous article</a>. The main idea is to represent the data as a sequence of literal bytes and <em>back references</em>, where back references refer to previous parts of the data. For example, in</p>

<blockquote>
<p>
I<span class="lzsrc">t was the </span>best of times,<br>
i<span class="lzdst">t was the </span>worst of times,<br>
</p>
</blockquote>

<p>the string "t was the " is used repeatedly. With LZ77 compression, the second occurrence can be represented by a back reference (26,10) which means that the decompressor should go 26 bytes back—the <em>back reference distance</em>—in the data and copy 10 bytes—the <em>back reference length</em>.</p>

<p>Back references can also overlap with themselves. For example, "Fa<span class="lzsrc">-la</span>-la-la-la" can be compressed as "Fa-la(3,9)". While PKZip's Reduce implementation doesn't appear to ever emit such backrefs, the application note doesn't disallow it. In order to be liberal in what we accept but conservative in what we do, our implementation will handle overlapping backrefs, but never emit them.</p>

<p>Additionally, Reduce allows referencing bytes before the start of the output buffer. Those bytes are treated as implicit zeros.</p>

<p>As opposed to LZW, which updates its dictionary by adding one-byte extensions of existing entries, LZ77 treats all recently processed data as the dictionary, and generally achieves much better compression.</p>

<p>Reduce compression uses a special byte value (144) to mark back references. In the PKZip application note, it's called DLE, which I'm guessing stands for <em>distance-length encoding</em>.</p>

<p>If the DLE byte is followed by a zero byte, it's not a back reference, but should be output as a literal byte. Otherwise, the DLE byte is followed by two or three bytes which encode the length and distance of the back reference.</p>

<p>The first byte following the DLE byte is called <span class="code">V</span> in the application note. Depending on the compression factor, between 4 and 7 of the least significant bits of <span class="code">V</span> are used for the back reference length. If those bits are all ones, they are added to an extra length byte following <span class="code">V</span>. This sum is then offset by the minimum back reference length which is 3. The maximum back reference length can be computed like this:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">size_t</span> <span class="nf">max_len</span><span class="p">(</span><span class="kt">int</span> <span class="n">comp_factor</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">v_len_bits</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="mi">8</span> <span class="o">-</span> <span class="n">comp_factor</span><span class="p">);</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">comp_factor</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">comp_factor</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">);</span>

        <span class="cm">/* Bits in V + extra len byte + implicit 3. */</span>
        <span class="k">return</span> <span class="p">((</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">v_len_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">255</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;
}</span>
</pre></div>


<p>After <span class="code">V</span> and any extra length byte comes a byte which we will call <span class="code">W</span>. Together with the most significant bits of <span class="code">V</span>, those that weren't used for the length, <span class="code">W</span> determines the distance of the back reference. The value is offset by the minimum distance, which is 1. The maximum distance depends on the compression factor like this:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">size_t</span> <span class="nf">max_dist</span><span class="p">(</span><span class="kt">int</span> <span class="n">comp_factor</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">v_dist_bits</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">comp_factor</span><span class="p">);</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">comp_factor</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">comp_factor</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">);</span>

        <span class="cm">/* Bits in V * 256 + W byte + implicit 1. */</span>
        <span class="k">return</span> <span class="p">((</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">v_dist_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">256</span> <span class="o">+</span> <span class="mi">255</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;
}</span>
</pre></div>


<p>That means the maximum length and distance vary between 273–385 and 512–4,096, respectively, depending on the compression factor. Higher compression factors trade shorter back reference length for larger distance, often leading to better compression since a larger search window increases the chances of finding matching substrings.</p>

<p>Reduce-compressed data contains no marker to signal the end of the compressed data, and since compressed artifacts can be smaller than one byte (the smallest follower set reference uses 2 bits), the decompressor needs to know the expected uncompressed size in order to know when to stop.</p>

<p>The decompression code consists of a loop which reads bytes using the procedures above, and decodes the back reference lengths and distances. It uses the <span class="code">lz77_output_backref64()</span> function in <a href="https://www.hanshq.net/files/hwzip/lz77.h"><span class="code">lz77.h</span></a>, described <a href="https://www.hanshq.net/zip.html#lz77_output_backref64">in the previous article</a>, for fast copying of the backrefs.</p>

<div class="highlight"><pre><span></span><span class="cp">#define DLE_BYTE 144</span>

<span class="k">typedef enum</span> <span class="p">{</span>
        <span class="n">HWEXPAND_OK</span><span class="p">,</span>   <span class="cm">/* Expand was successful. */</span>
        <span class="n">HWEXPAND_ERR</span>   <span class="cm">/* Error in the input data. */</span>
<span class="p">}</span> <span class="n">expand_stat_t</span><span class="p">;</span>

<span class="cm">/* Decompress (expand) the data in src. The uncompressed data is uncomp_len
   bytes long and was compressed with comp_factor. The number of input bytes
   used, at most src_len, is written to *src_used on success. Output is written
   to dst. */</span>
<span class="n">expand_stat_t</span> <span class="nf">hwexpand</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">src_len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">uncomp_len</span><span class="p">,</span>
                       <span class="kt">int</span> <span class="n">comp_factor</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">src_used</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">)
{</span>
        <span class="n">istream_t is</span><span class="p">;</span>
        <span class="n">follower_set_t fsets</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
        <span class="kt">size_t</span> <span class="n">v_len_bits</span><span class="p">,</span> <span class="n">dst_pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">curr_byte</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">comp_factor</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">comp_factor</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">);</span>

        <span class="n">istream_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">src_len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_follower_sets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">fsets</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="n">HWEXPAND_ERR</span><span class="p">;
        }</span>

        <span class="cm">/* Number of bits in V used for backref length. */</span>
        <span class="n">v_len_bits</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="mi">8</span> <span class="o">-</span> <span class="n">comp_factor</span><span class="p">);</span>

        <span class="n">dst_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">curr_byte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* The first "previous byte" is implicitly zero. */</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">dst_pos</span> <span class="o">&lt;</span> <span class="n">uncomp_len</span><span class="p">) {</span>
                <span class="cm">/* Read a literal byte or DLE marker. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_next_byte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">curr_byte</span><span class="p">,</span> <span class="n">fsets</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr_byte</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="n">HWEXPAND_ERR</span><span class="p">;
                }</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">curr_byte</span> <span class="o">!=</span> <span class="n">DLE_BYTE</span><span class="p">) {</span>
                        <span class="cm">/* Output a literal byte. */</span>
                        <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_byte</span><span class="p">;</span>
                        <span class="k">continue</span><span class="p">;
                }</span>

                <span class="cm">/* Read the V byte which determines the length. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_next_byte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">curr_byte</span><span class="p">,</span> <span class="n">fsets</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr_byte</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="n">HWEXPAND_ERR</span><span class="p">;
                }</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">curr_byte</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="cm">/* Output a literal DLE byte. */</span>
                        <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">DLE_BYTE</span><span class="p">;</span>
                        <span class="k">continue</span><span class="p">;
                }</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">curr_byte</span><span class="p">;</span>
                <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">lsb</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v_len_bits</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">v_len_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">) {</span>
                        <span class="cm">/* Read an extra length byte. */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_next_byte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">curr_byte</span><span class="p">,</span> <span class="n">fsets</span><span class="p">,</span>
                                            <span class="o">&amp;</span><span class="n">curr_byte</span><span class="p">)) {</span>
                                <span class="k">return</span> <span class="n">HWEXPAND_ERR</span><span class="p">;
                        }</span>
                        <span class="n">len</span> <span class="o">+=</span> <span class="n">curr_byte</span><span class="p">;
                }</span>
                <span class="n">len</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>

                <span class="cm">/* Read the W byte, which together with V gives the distance. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_next_byte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">curr_byte</span><span class="p">,</span> <span class="n">fsets</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr_byte</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="n">HWEXPAND_ERR</span><span class="p">;
                }</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">v_len_bits</span><span class="p">)</span> <span class="o">*</span> <span class="mi">256</span> <span class="o">+</span> <span class="n">curr_byte</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

                <span class="n">assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">max_len</span><span class="p">(</span><span class="n">comp_factor</span><span class="p">));</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">max_dist</span><span class="p">(</span><span class="n">comp_factor</span><span class="p">));</span>

                <span class="cm">/* Output the back reference. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">round_up</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">uncomp_len</span> <span class="o">-</span> <span class="n">dst_pos</span> <span class="o">&amp;&amp;</span>
                    <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">dst_pos</span><span class="p">) {</span>
                        <span class="cm">/* Enough room and no implicit zeros; chunked copy. */</span>
                        <span class="n">lz77_output_backref64</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">dst_pos</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
                        <span class="n">dst_pos</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;
                }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">uncomp_len</span> <span class="o">-</span> <span class="n">dst_pos</span><span class="p">) {</span>
                        <span class="cm">/* Not enough room. */</span>
                        <span class="k">return</span> <span class="n">HWEXPAND_ERR</span><span class="p">;
                }</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="cm">/* Copy, handling overlap and implicit zeros. */</span>
                        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="n">dst_pos</span><span class="p">) {</span>
                                        <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                                        <span class="k">continue</span><span class="p">;
                                }</span>
                                <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span> <span class="o">-</span> <span class="n">dist</span><span class="p">];</span>
                                <span class="n">dst_pos</span><span class="o">++</span><span class="p">;
                        }
                }
        }</span>

        <span class="o">*</span><span class="n">src_used</span> <span class="o">=</span> <span class="n">istream_bytes_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">HWEXPAND_OK</span><span class="p">;
}</span>
</pre></div>


<a name="reducefollowers"></a>
<h3>Reduce: Follower Sets</h3>

<p>For compression, we will again tackle the two layers of Reduce separately, starting with the follower sets.</p>

<p>We will provide a function, <span class="code">write_byte()</span>, as an interface for feeding bytes through the follower set compression to an output bitstream.</p>

<p>In order to choose the follower sets which yield the best compression for a sequence of bytes, the entire byte sequence would need to be considered. Either our compressor would need to store those bytes internally until the follower sets are computed, or it could do two passes: first analysing the byte stream to build the follower sets, and then using the follower sets to write the byte stream in the second pass. Both approaches are inelegant since they would potentially require a lot of memory, or extra time to process the data twice.</p>

<p>Instead, our compressor will accumulate a certain number of bytes into a fixed-sized buffer, and then compute the follower sets based on those bytes. That "raw bytes buffer" and other state, is held in a struct:</p>

<div class="highlight"><pre><span></span><span class="cp">#define RAW_BYTES_SZ    (64 * 1024)
#define NO_FOLLOWER_IDX UINT8_MAX</span>

<span class="k">typedef struct</span> <span class="n">reduce_state_t reduce_state_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">reduce_state_t</span> <span class="p">{</span>
        <span class="n">ostream_t os</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">comp_factor</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">prev_byte</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">raw_bytes_flushed</span><span class="p">;</span>

        <span class="cm">/* Raw bytes buffer. */</span>
        <span class="kt">uint8_t</span> <span class="n">raw_bytes</span><span class="p">[</span><span class="n">RAW_BYTES_SZ</span><span class="p">];</span>
        <span class="kt">size_t</span> <span class="n">num_raw_bytes</span><span class="p">;</span>

        <span class="cm">/* Map from (prev_byte,curr_byte) to follower_idx or NO_FOLLOWER_IDX. */</span>
        <span class="kt">uint8_t</span> <span class="n">follower_idx</span><span class="p">[</span><span class="mi">256</span><span class="p">][</span><span class="mi">256</span><span class="p">];</span>
        <span class="kt">uint8_t</span> <span class="n">follower_idx_bw</span><span class="p">[</span><span class="mi">256</span><span class="p">];
};</span>
</pre></div>


<p>The <span class="code">write_byte()</span> function stores bytes into the buffer. Once the buffer is full, the follower sets are computed, written to the output stream, and the contents of the buffer as well as any subsequent writes are written to the stream using the follower sets:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">write_byte</span><span class="p">(</span><span class="n">reduce_state_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">byte</span><span class="p">)
{</span>
        <span class="kt">uint8_t</span> <span class="n">follower_idx</span><span class="p">,</span> <span class="n">follower_idx_bw</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">raw_bytes_flushed</span><span class="p">) {</span>
                <span class="cm">/* Accumulate bytes which will be used for computing the
                   follower sets. */</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">num_raw_bytes</span> <span class="o">&lt;</span> <span class="n">RAW_BYTES_SZ</span><span class="p">);</span>
                <span class="n">s</span><span class="o">-&gt;</span><span class="n">raw_bytes</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">num_raw_bytes</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">byte</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">num_raw_bytes</span> <span class="o">==</span> <span class="n">RAW_BYTES_SZ</span><span class="p">) {</span>
                        <span class="cm">/* Write follower sets and flush the bytes. */</span>
                        <span class="k">return</span> <span class="n">flush_raw_bytes</span><span class="p">(</span><span class="n">s</span><span class="p">);
                }</span>

                <span class="k">return</span> <span class="nb">true</span><span class="p">;
        }</span>

        <span class="n">follower_idx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">follower_idx</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_byte</span><span class="p">][</span><span class="n">byte</span><span class="p">];</span>
        <span class="n">follower_idx_bw</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">follower_idx_bw</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_byte</span><span class="p">];</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_byte</span> <span class="o">=</span> <span class="n">byte</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">follower_idx</span> <span class="o">!=</span> <span class="n">NO_FOLLOWER_IDX</span><span class="p">) {</span>
                <span class="cm">/* Write (LSB-first) a 0 bit followed by the follower index. */</span>
                <span class="k">return</span> <span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,
                                     (</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">follower_idx</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
                                     <span class="n">follower_idx_bw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">follower_idx_bw</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="cm">/* Not using the follower set.
                   Write (LSB-first) a 1 bit followed by the literal byte. */</span>
                <span class="k">return</span> <span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">, (</span><span class="kt">uint64_t</span><span class="p">)(</span><span class="n">byte</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x1</span><span class="p">,</span> <span class="mi">9</span><span class="p">);
        }</span>

        <span class="cm">/* No follower set; write the literal byte. */</span>
        <span class="k">return</span> <span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">byte</span><span class="p">,</span> <span class="mi">8</span><span class="p">);
}</span>
</pre></div>


<p>When flushing the raw bytes buffer, the follower sets are computed first, and then <span class="code">write_byte()</span> can be re-used for writing out the bytes:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">flush_raw_bytes</span><span class="p">(</span><span class="n">reduce_state_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

        <span class="n">s</span><span class="o">-&gt;</span><span class="n">raw_bytes_flushed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_follower_sets</span><span class="p">(</span><span class="n">s</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">num_raw_bytes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_byte</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">raw_bytes</span><span class="p">[</span><span class="n">i</span><span class="p">])) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }
        }</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<p>To compute the follower set for a byte, we will count how many times each possible follower occurs directly after that byte, and then sort those followers in descending order of frequency using the struct and comparison function below:</p>

<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">follower</span> <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="n">byte</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">count</span><span class="p">;
};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">follower_cmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">)
{</span>
        <span class="k">const struct</span> <span class="n">follower</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="k">const struct</span> <span class="n">follower</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>

        <span class="cm">/* Sort descending by count. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">) {</span> <span class="k">return</span>  <span class="mi">1</span><span class="p">; }</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">) {</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">; }</span>

        <span class="cm">/* Break ties by sorting ascending by byte. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">byte</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">byte</span><span class="p">) {</span> <span class="k">return</span>  <span class="mi">1</span><span class="p">; }</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">byte</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">byte</span><span class="p">) {</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">; }</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">byte</span> <span class="o">==</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">byte</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;
}</span>
</pre></div>


<p>A follower set should contain the most frequently occurring followers, so once they are sorted, the remaining task is to decide how many of them to include. This is an optimization problem: a larger follower set requires more bits to represent and more bits for the index each time a follower is used. On the other hand, a literal byte requires more bits than a follower set reference.</p>

<p>Since the number of possible sizes is small, and we only need to compute the follower sets once, we will use a brute force approach: consider each size and pick the one which yields the lowest total cost based on the follower counts.</p>

<div class="highlight"><pre><span></span><span class="cm">/* The cost in bits for writing the follower bytes using follower set size n. */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">followers_cost</span><span class="p">(</span><span class="k">const struct</span> <span class="n">follower</span> <span class="o">*</span><span class="n">followers</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">cost</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

        <span class="cm">/* Cost for storing the follower set. */</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>

        <span class="cm">/* Cost for follower bytes in the set. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">cost</span> <span class="o">+=</span> <span class="n">followers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">follower_idx_bw</span><span class="p">(</span><span class="n">n</span><span class="p">));
        }</span>
        <span class="cm">/* Cost for follower bytes not in the set. */</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="n">cost</span> <span class="o">+=</span> <span class="n">followers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;
                }</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">cost</span> <span class="o">+=</span> <span class="n">followers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);
                }
        }</span>

        <span class="k">return</span> <span class="n">cost</span><span class="p">;
}</span>
</pre></div>


<p>The code below computes and writes the follower sets.</p>

<div class="highlight"><pre><span></span><span class="cm">/* Compute and write the follower sets based on the raw bytes buffer. */</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">write_follower_sets</span><span class="p">(</span><span class="n">reduce_state_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">follower_count</span><span class="p">[</span><span class="mi">256</span><span class="p">][</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">0</span><span class="p">}};</span>
        <span class="k">struct</span> <span class="n">follower followers</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">prev_byte</span><span class="p">,</span> <span class="n">curr_byte</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">min_cost</span><span class="p">,</span> <span class="n">min_cost_size</span><span class="p">;</span>

        <span class="cm">/* Count followers. */</span>
        <span class="n">prev_byte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">num_raw_bytes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">curr_byte</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">raw_bytes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">follower_count</span><span class="p">[</span><span class="n">prev_byte</span><span class="p">][</span><span class="n">curr_byte</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
                <span class="n">prev_byte</span> <span class="o">=</span> <span class="n">curr_byte</span><span class="p">;
        }</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">curr_byte</span> <span class="o">=</span> <span class="n">UINT8_MAX</span><span class="p">;</span> <span class="n">curr_byte</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">curr_byte</span><span class="o">--</span><span class="p">) {</span>
                <span class="cm">/* Initialize follower indices to invalid. */</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">UINT8_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                        <span class="n">s</span><span class="o">-&gt;</span><span class="n">follower_idx</span><span class="p">[</span><span class="n">curr_byte</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">NO_FOLLOWER_IDX</span><span class="p">;
                }</span>

                <span class="cm">/* Sort the followers for curr_byte. */</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">UINT8_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                        <span class="n">followers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">byte</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
                        <span class="n">followers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span> <span class="o">=</span> <span class="n">follower_count</span><span class="p">[</span><span class="n">curr_byte</span><span class="p">][</span><span class="n">i</span><span class="p">];
                }</span>
                <span class="n">qsort</span><span class="p">(</span><span class="n">followers</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">followers</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">follower_cmp</span><span class="p">);</span>

                <span class="cm">/* Find the follower set size with the lowest cost. */</span>
                <span class="n">min_cost_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">min_cost</span> <span class="o">=</span> <span class="n">followers_cost</span><span class="p">(</span><span class="n">followers</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                        <span class="n">cost</span> <span class="o">=</span> <span class="n">followers_cost</span><span class="p">(</span><span class="n">followers</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">cost</span> <span class="o">&lt;</span> <span class="n">min_cost</span><span class="p">) {</span>
                                <span class="n">min_cost_size</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                                <span class="n">min_cost</span> <span class="o">=</span> <span class="n">cost</span><span class="p">;
                        }
                }</span>

                <span class="cm">/* Save the follower indices. */</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">min_cost_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                        <span class="n">s</span><span class="o">-&gt;</span><span class="n">follower_idx</span><span class="p">[</span><span class="n">curr_byte</span><span class="p">][</span><span class="n">followers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">byte</span><span class="p">]</span> <span class="o">=</span>
                                <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">i</span><span class="p">;
                }</span>
                <span class="n">s</span><span class="o">-&gt;</span><span class="n">follower_idx_bw</span><span class="p">[</span><span class="n">curr_byte</span><span class="p">]</span> <span class="o">=</span> <span class="n">follower_idx_bw</span><span class="p">(</span><span class="n">min_cost_size</span><span class="p">);</span>

                <span class="cm">/* Write the followers. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">min_cost_size</span><span class="p">,</span> <span class="mi">6</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">min_cost_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">followers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">byte</span><span class="p">,</span> <span class="mi">8</span><span class="p">)) {</span>
                                <span class="k">return</span> <span class="nb">false</span><span class="p">;
                        }
                }
        }</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<a name="reducelz77"></a>
<h3>Reduce: LZ77</h3>

<p>For the LZ77 component of Reduce, we will use the implementation <a href="https://www.hanshq.net/zip.html#lz">described in the previous article</a>, with code available in <a href="https://www.hanshq.net/files/hwzip/lz77.h"><span class="code">lz77.h</span></a> and <a href="https://www.hanshq.net/files/hwzip/lz77.c"><span class="code">lz77.c</span></a>. To use it, we need to implement callbacks for handling literals and backrefs.</p>

<p>Literal bytes are simply passed through to the <span class="code">write_byte()</span> function. A DLE byte needs to be followed by a zero byte to be interpreted as a literal value:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">lit_callback</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">lit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">)
{</span>
        <span class="n">reduce_state_t</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">aux</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_byte</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">lit</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">lit</span> <span class="o">==</span> <span class="n">DLE_BYTE</span><span class="p">) {</span>
                <span class="k">return</span> <span class="n">write_byte</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">);
        }</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<p>For back references, we write a DLE byte followed by the bytes which represent the backref length and distance:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">backref_callback</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">)
{</span>
        <span class="n">reduce_state_t</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">aux</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">v_len_bits</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="mi">8</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">comp_factor</span><span class="p">);</span>
        <span class="kt">uint8_t</span> <span class="n">v</span><span class="p">,</span> <span class="n">elb</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">len</span>  <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">len</span>  <span class="o">&lt;=</span> <span class="n">max_len</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">comp_factor</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">max_dist</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">comp_factor</span><span class="p">));</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">dist</span> <span class="o">&amp;&amp;</span> <span class="s">"Backref shouldn't self-overlap."</span><span class="p">);</span>

        <span class="cm">/* The implicit part of len and dist are not encoded. */</span>
        <span class="n">len</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">dist</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="cm">/* Write the DLE marker. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_byte</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">DLE_BYTE</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="cm">/* Write V. */</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">, (</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">v_len_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="mi">256</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">comp_factor</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">v</span> <span class="o">|=</span> <span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="mi">256</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">v_len_bits</span><span class="p">;</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">"The byte following DLE must be non-zero."</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_byte</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">v_len_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">) {</span>
                <span class="cm">/* Write extra length byte. */</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="p">((</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">v_len_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">UINT8_MAX</span><span class="p">);</span>
                <span class="n">elb</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">len</span> <span class="o">-</span> <span class="p">((</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">v_len_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_byte</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">elb</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }
        }</span>

        <span class="cm">/* Write W. */</span>
        <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">dist</span> <span class="o">%</span> <span class="mi">256</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_byte</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">w</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<p>With the callbacks in place, we call the LZ77 code to drive the compression:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Compress (reduce) the data in src into dst using the specified compression
   factor (1--4). The number of bytes output, at most dst_cap, is stored in
   *dst_used. Returns false if there is not enough room in dst. */</span>
<span class="kt">bool</span> <span class="nf">hwreduce</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">src_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">comp_factor</span><span class="p">,</span>
              <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">dst_used</span><span class="p">)
{</span>
        <span class="n">reduce_state_t s</span><span class="p">;</span>

        <span class="n">ostream_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">.</span><span class="n">os</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">dst_cap</span><span class="p">);</span>
        <span class="n">s</span><span class="p">.</span><span class="n">comp_factor</span> <span class="o">=</span> <span class="n">comp_factor</span><span class="p">;</span>
        <span class="n">s</span><span class="p">.</span><span class="n">prev_byte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">s</span><span class="p">.</span><span class="n">raw_bytes_flushed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">s</span><span class="p">.</span><span class="n">num_raw_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lz77_compress</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">src_len</span><span class="p">,</span>
                           <span class="n">max_dist</span><span class="p">(</span><span class="n">comp_factor</span><span class="p">),</span> <span class="n">max_len</span><span class="p">(</span><span class="n">comp_factor</span><span class="p">),</span>
                           <span class="cm">/*allow_overlap=*/</span> <span class="nb">false</span><span class="p">,</span>
                           <span class="n">lit_callback</span><span class="p">,</span> <span class="n">backref_callback</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">raw_bytes_flushed</span> <span class="o">&amp;&amp; !</span><span class="n">flush_raw_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="o">*</span><span class="n">dst_used</span> <span class="o">=</span> <span class="n">ostream_bytes_written</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">.</span><span class="n">os</span><span class="p">);</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<a name="implode"></a>
<h2>Method 6: Implode / Explode</h2>

<p>Of all the compression and decompression algorithms, Implode and Explode probably have the coolest names. They're also a big step towards what's used in modern Zip compression: Deflate and Inflate (<a href="https://www.hanshq.net/zip.html#deflate">described in the previous article</a>). The differences are described <a href="https://www.hanshq.net/zip2.html#deflate">at the end of this section</a>.</p>

<p>Implode was introduced with <a href="http://cd.textfiles.com/originalsw/25/pkz101.exe">PKZip 1.01</a> in July 1989, and is similar to Reduce in that it uses LZ77 compression. However, instead of the follower sets used by Reduce, Implode uses Huffman coding to encode the output from LZ77.</p>

<div style="text-align: center">
<div class="latex"><p style="margin-left: 2em"><img src="./zip2_files/tex_924f06f5.svg" alt="LaTeX"></p></div>
</div>


<p>(PKWare also used Implode in their Data Compression Library (DCL), a software library which could be used to embed the compression algorithm in other programs. Confusingly, DCL Implode is different from regular Implode. The format is described in a <a href="https://groups.google.com/d/msg/comp.compression/M5P064or93o/W1ca1-ad6kgJ">Usenet post by Ben Rudiak-Gould</a>, and the Zlib maintainer Mark Adler has written <a href="https://github.com/madler/zlib/blob/master/contrib/blast/blast.c">a decompressor for it</a>. DCL Implode was later added to the PKZip application note as Method 10, but without any description of how it works.)</p>

<p>Like the previous methods, we will explain Implode and Explode by walking through an implementation, starting with decompression to get an understanding of the format. The code is available in <a href="https://www.hanshq.net/files/hwzip/implode.h"><span class="code">implode.h</span></a> and <a href="https://www.hanshq.net/files/hwzip/implode.c"><span class="code">implode.c</span></a>.</p>

<a name="explode"></a>
<h3>Explode</h3>

<p>Huffman coding is described in detail <a href="https://www.hanshq.net/zip.html#huffman">in the previous article</a>. It's a method for assigning binary codewords to a set of symbols, with more common symbols receiving shorter codewords. Implode uses this to encode the LZ77 backref distances, lengths, and optionally the literal bytes.</p>

<p>(Actually, the application note never mentions Huffman coding—neither for Implode nor Deflate—but Shannon-Fano coding, which is an older technique that tries to accomplish the same thing but with less optimal results.)</p>

<p>Implode uses two or three different Huffman codes, depending on whether literal bytes should be Huffman coded or not. The codes are stored at the beginning of the compressed data. As is common with Huffman codes, the codewords themselves are not stored, only the codeword lengths. The codewords can then be reconstructed from the lengths as what is called a canonical Huffman code.</p>

<p>The codeword lengths used by Implode can be between 1 and 16 bits, and are run-length encoded as a sequence of bytes where the least significant four bits of each byte denote the codeword length minus one, and the other bits represent the run-length minus one. For example, <span class="code">0x21</span> encodes 3 codeword lengths of 2 bits. An initial byte stores the number of bytes used to represent the code minus one.</p>

<p>The function below reads a Huffman code:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Initialize the Huffman decoder d with num_lens codeword lengths read from is.
   Returns false if the input is invalid. */</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">read_huffman_code</span><span class="p">(</span><span class="n">istream_t</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">num_lens</span><span class="p">,</span>
                              <span class="n">huffman_decoder_t</span> <span class="o">*</span><span class="n">d</span><span class="p">)
{</span>
        <span class="kt">uint8_t</span> <span class="n">lens</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
        <span class="kt">uint8_t</span> <span class="n">byte</span><span class="p">,</span> <span class="n">codeword_len</span><span class="p">,</span> <span class="n">run_length</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">byte_idx</span><span class="p">,</span> <span class="n">codeword_idx</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">len_count</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
        <span class="kt">int32_t</span> <span class="n">avail_codewords</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">ok</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">num_lens</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lens</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>

        <span class="cm">/* Number of bytes representing the Huffman code. */</span>
        <span class="n">byte</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">lsb</span><span class="p">(</span><span class="n">istream_bits</span><span class="p">(</span><span class="n">is</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
        <span class="n">num_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">byte</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="mi">8</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="n">codeword_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">byte_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">byte_idx</span> <span class="o">&lt;</span> <span class="n">num_bytes</span><span class="p">;</span> <span class="n">byte_idx</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">byte</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">lsb</span><span class="p">(</span><span class="n">istream_bits</span><span class="p">(</span><span class="n">is</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="mi">8</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }</span>

                <span class="n">codeword_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Low four bits plus one. */</span>
                <span class="n">run_length</span>   <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span>  <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* High four bits plus one. */</span>

                <span class="n">assert</span><span class="p">(</span><span class="n">codeword_len</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">codeword_len</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">);</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">codeword_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">len_count</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">len_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
                <span class="n">len_count</span><span class="p">[</span><span class="n">codeword_len</span><span class="p">]</span> <span class="o">+=</span> <span class="n">run_length</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">codeword_idx</span> <span class="o">+</span> <span class="n">run_length</span> <span class="o">&gt;</span> <span class="n">num_lens</span><span class="p">) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* Too many codeword lengths. */</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">run_length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">codeword_idx</span> <span class="o">&lt;</span> <span class="n">num_lens</span><span class="p">);</span>
                        <span class="n">lens</span><span class="p">[</span><span class="n">codeword_idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">codeword_len</span><span class="p">;
                }
        }</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">codeword_idx</span> <span class="o">&lt;=</span> <span class="n">num_lens</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">codeword_idx</span> <span class="o">&lt;</span> <span class="n">num_lens</span><span class="p">) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* Too few codeword lengths. */</span>
        <span class="p">}</span>
</pre></div>


<p>Implode does an interesting twist on canonical Huffman codes: it assigns the codewords in reverse order. Canonical codes assign codewords to the symbols sorted by codeword length, normally starting with an all-zeros codeword for the first and shortest symbol, and finishing with all ones for the last and longest symbol. Implode, however, starts by assigning all zeros to the last codeword, and works its way back to the first. For example, if we have one 1-bit codeword and two 2-bit codewords, they would normally be <span class="code">0</span>, <span class="code">10</span>, and <span class="code">11</span>, but Implode would use the codewords <span class="code">1</span>, <span class="code">01</span>, and <span class="code">00</span> instead.</p>

<p>In order to re-use the Huffman decoder <a href="https://www.hanshq.net/zip.html#huffdec">described in the previous article</a> (code in <a href="https://www.hanshq.net/files/hwzip/huffman.h"><span class="code">huffman.h</span></a> and <a href="https://www.hanshq.net/files/hwzip/huffman.c"><span class="code">huffman.c</span></a>), we have to convert from Implode's canonical code to the regular canonical code that the decoder uses. It turns out that this is as easy as flipping the bits: the all-ones first codeword becomes all zeros, the all-zeros last codeword becomes all ones, and it works for the codewords in between too.</p>

<p>The bit flipping trick only works when all available codewords are used, though. For example, if we had a code consisting of three 2-bit codewords, they would normally be <span class="code">00</span>, <span class="code">01</span>, <span class="code">10</span>, but Implode would use <span class="code">10</span>, <span class="code">01</span>, <span class="code">00</span>, and we could not simply flip the bits to convert between them. Viewed in terms of Huffman trees, this problem would occur if the tree is not full in the sense that every node has zero or two children (see the left tree below). However, because of how Huffman's algorithm (and Shannon-Fano's) work, such a tree would never actually be constructed: a new node is always created with two children. A code with three 2-bit codewords would never be created; instead the code would use one 1-bit and two 2-bit codewords (the right tree below).</p>

<div class="latex"><p style="margin-left: 2em"><img src="./zip2_files/tex_ce5db31a.svg" alt="LaTeX"></p></div>

<p>While a code which doesn't use all available codewords shouldn't occur in practice, it is possible to represent such a code in the input data. We check for and reject such codes:</p>

<div class="highlight"><pre><span></span>        <span class="cm">/* Check that the Huffman tree is full. */</span>
        <span class="n">avail_codewords</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">avail_codewords</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
                <span class="n">avail_codewords</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">avail_codewords</span> <span class="o">-=</span> <span class="n">len_count</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">avail_codewords</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="cm">/* Higher count than available codewords. */</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }
        }</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">avail_codewords</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="cm">/* Not all codewords were used. */</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="n">ok</span> <span class="o">=</span> <span class="n">huffman_decoder_init</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">lens</span><span class="p">,</span> <span class="n">num_lens</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">ok</span> <span class="o">&amp;&amp;</span> <span class="s">"The checks above mean the tree should be valid."</span><span class="p">);</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<p>With the function for reading Huffman codes in place, we can start working on the main decompression function.</p>

<p>Explode uses two or three Huffman codes: one for backref lengths, one for distances, and optionally a third code for literal bytes. Whether literal bytes are Huffman coded is controlled by a flag which is stored as metadata in the Zip file (bit 2 in the "general purpose bit flag" field).</p>

<div class="highlight"><pre><span></span><span class="k">typedef enum</span> <span class="p">{</span>
        <span class="n">HWEXPLODE_OK</span><span class="p">,</span>   <span class="cm">/* Explode was successful. */</span>
        <span class="n">HWEXPLODE_ERR</span>   <span class="cm">/* Error in the input data. */</span>
<span class="p">}</span> <span class="n">explode_stat_t</span><span class="p">;</span>

<span class="cm">/* Decompress (explode) the data in src. The uncompressed data is uncomp_len
   bytes long. large_wnd is true if a large window was used for compression,
   lit_tree is true if literals were Huffman coded, and pk101_bug_compat is
   true if compatibility with PKZip 1.01/1.02 is desired. The number of input
   bytes used, at most src_len, is written to *src_used on success. Output is
   written to dst. */</span>
<span class="n">explode_stat_t</span> <span class="nf">hwexplode</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">src_len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">uncomp_len</span><span class="p">,</span>
                         <span class="kt">bool</span> <span class="n">large_wnd</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">lit_tree</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">pk101_bug_compat</span><span class="p">,</span>
                         <span class="kt">size_t</span> <span class="o">*</span><span class="n">src_used</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">)
{</span>
        <span class="n">istream_t is</span><span class="p">;</span>
        <span class="n">huffman_decoder_t lit_decoder</span><span class="p">,</span> <span class="n">len_decoder</span><span class="p">,</span> <span class="n">dist_decoder</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">dst_pos</span><span class="p">,</span> <span class="n">used</span><span class="p">,</span> <span class="n">used_tot</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">bits</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">sym</span><span class="p">,</span> <span class="n">min_len</span><span class="p">;</span>

        <span class="n">istream_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">src_len</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">lit_tree</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_huffman_code</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lit_decoder</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="n">HWEXPLODE_ERR</span><span class="p">;
                }
        }</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_huffman_code</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len_decoder</span><span class="p">)</span> <span class="o">||
            !</span><span class="n">read_huffman_code</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dist_decoder</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="n">HWEXPLODE_ERR</span><span class="p">;
        }</span>
</pre></div>


<p>Another metadata flag controls the maximum back reference distance, which is either 4,096 or 8,192 bytes (bit 1 in the "general purpose bit flag" field).</p>

<p>The minimum back reference length depends on whether literal bytes are Huffman coded or not. If they are, the minimum back reference is 3 bytes long, otherwise it's 2. The reasoning was probably that a two-byte string is likely to be more efficiently represented as two Huffman-coded literals than a backref.</p>

<p>It appears that PKZip versions 1.01 and 1.02 got the minimum back reference length computation wrong, considering the flag for window size instead of the flag for Huffman coded literals. This is described in a <a href="https://entropymine.wordpress.com/2019/09/22/pkzip-implode-compression-oddity/">blog post by Jason Summers</a>, and was also previously discussed <a href="https://groups.google.com/g/comp.compression/c/oOiAxCpEKGI/m/szUUxVXPDBcJ">on Usenet</a>.  Because of this bug, <a href="http://cd.textfiles.com/originalsw/25/pkz101.exe">the PKZip 1.01 distribution file</a> cannot be extracted by later PKZip versions (although it still self-extracts). In order to extract files compressed with the buggy behaviour, we will support it with a flag:</p>

<div class="highlight"><pre><span></span>        <span class="k">if</span> <span class="p">(</span><span class="n">pk101_bug_compat</span><span class="p">) {</span>
                <span class="n">min_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">large_wnd</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">2</span><span class="p">);
        }</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">min_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">lit_tree</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">2</span><span class="p">);
        }</span>
</pre></div>


<p>If <span class="code">min_len</span> is wrong, the extracted data is unlikely to have the expected length, in which case the caller can try again with the <span class="code">pk101_bug_compat</span> flag set.</p>

<p>Implode uses a one-bit marker to differentiate between literal bytes and back references. Literals are represented by a 1 bit followed by the byte, possibly Huffman coded. Note how the input bits are flipped when passed to <span class="code">huffman_decode</span> due to Implode's reverse canonical Huffman code described above:</p>

<div class="highlight"><pre><span></span>        <span class="n">dst_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">dst_pos</span> <span class="o">&lt;</span> <span class="n">uncomp_len</span><span class="p">) {</span>
                <span class="n">bits</span> <span class="o">=</span> <span class="n">istream_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x1</span><span class="p">) {</span>
                        <span class="cm">/* Literal. */</span>
                        <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">lit_tree</span><span class="p">) {</span>
                                <span class="n">sym</span> <span class="o">=</span> <span class="n">huffman_decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lit_decoder</span><span class="p">,
                                                     (</span><span class="kt">uint16_t</span><span class="p">)</span><span class="o">~</span><span class="n">bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">used</span><span class="p">);</span>
                                <span class="n">assert</span><span class="p">(</span><span class="n">sym</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">"huffman decode successful"</span><span class="p">);</span>
                                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">used</span><span class="p">)) {</span>
                                        <span class="k">return</span> <span class="n">HWEXPLODE_ERR</span><span class="p">;
                                }
                        }</span> <span class="k">else</span> <span class="p">{</span>
                                <span class="n">sym</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
                                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)) {</span>
                                        <span class="k">return</span> <span class="n">HWEXPLODE_ERR</span><span class="p">;
                                }
                        }</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">sym</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sym</span> <span class="o">&lt;=</span> <span class="n">UINT8_MAX</span><span class="p">);</span>
                        <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">sym</span><span class="p">;</span>
                        <span class="k">continue</span><span class="p">;
                }</span>
</pre></div>


<p>Back references are signalled by a 0 bit, followed by encodings of the distance and length. The distance is encoded in two parts, with the 6 or 7 (depending on the window size) least significant bits stored directly in the bitstream, and the remaining 6 bits Huffman coded. The length is encoded as a Huffman-coded 6-bit value, followed by an extra byte if the first bits are all ones.</p>

<div class="highlight"><pre><span></span>                <span class="cm">/* Backref. */</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">);</span>
                <span class="n">used_tot</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>

                <span class="cm">/* Read the low dist bits. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">large_wnd</span><span class="p">) {</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
                        <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="mi">7</span><span class="p">;</span>
                        <span class="n">used_tot</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">;
                }</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
                        <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="mi">6</span><span class="p">;</span>
                        <span class="n">used_tot</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">;
                }</span>

                <span class="cm">/* Read the Huffman-encoded high dist bits. */</span>
                <span class="n">sym</span> <span class="o">=</span> <span class="n">huffman_decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dist_decoder</span><span class="p">, (</span><span class="kt">uint16_t</span><span class="p">)</span><span class="o">~</span><span class="n">bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">used</span><span class="p">);</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">sym</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">"huffman decode successful"</span><span class="p">);</span>
                <span class="n">used_tot</span> <span class="o">+=</span> <span class="n">used</span><span class="p">;</span>
                <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="n">used</span><span class="p">;</span>
                <span class="n">dist</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">sym</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">large_wnd</span> <span class="o">?</span> <span class="mi">7</span> <span class="o">:</span> <span class="mi">6</span><span class="p">);</span>
                <span class="n">dist</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

                <span class="cm">/* Read the Huffman-encoded len. */</span>
                <span class="n">sym</span> <span class="o">=</span> <span class="n">huffman_decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">len_decoder</span><span class="p">, (</span><span class="kt">uint16_t</span><span class="p">)</span><span class="o">~</span><span class="n">bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">used</span><span class="p">);</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">sym</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">"huffman decode successful"</span><span class="p">);</span>
                <span class="n">used_tot</span> <span class="o">+=</span> <span class="n">used</span><span class="p">;</span>
                <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="n">used</span><span class="p">;</span>
                <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">sym</span> <span class="o">+</span> <span class="n">min_len</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">sym</span> <span class="o">==</span> <span class="mi">63</span><span class="p">) {</span>
                        <span class="cm">/* Read an extra len byte. */</span>
                        <span class="n">len</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">lsb</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
                        <span class="n">used_tot</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
                        <span class="n">bits</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;
                }</span>

                <span class="n">assert</span><span class="p">(</span><span class="n">used_tot</span> <span class="o">&lt;=</span> <span class="n">ISTREAM_MIN_BITS</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">istream_advance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">used_tot</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="n">HWEXPLODE_ERR</span><span class="p">;
                }</span>
</pre></div>


<p>With the distance and length decoded, the back reference can be copied the same way as for Reduce compression.</p>

<p>The same rules as for Reduce apply: backrefs may self-overlap, and bytes before the start of the output buffer are implicit zeros. In contrast to Reduce, PKZip's Implode implementation does emit self-overlapping back references. That makes the implicit zeros feature superfluous since a run of <span class="code">N</span> zeros can be encoded with a self-overlapping backref as <span class="code">0(1,N)</span>.</p>

<div class="highlight"><pre><span></span>                <span class="k">if</span> <span class="p">(</span><span class="n">round_up</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">uncomp_len</span> <span class="o">-</span> <span class="n">dst_pos</span> <span class="o">&amp;&amp;</span>
                    <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">dst_pos</span><span class="p">) {</span>
                        <span class="cm">/* Enough room and no implicit zeros; chunked copy. */</span>
                        <span class="n">lz77_output_backref64</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">dst_pos</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
                        <span class="n">dst_pos</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;
                }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">uncomp_len</span> <span class="o">-</span> <span class="n">dst_pos</span><span class="p">) {</span>
                        <span class="cm">/* Not enough room. */</span>
                        <span class="k">return</span> <span class="n">HWEXPLODE_ERR</span><span class="p">;
                }</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="cm">/* Copy, handling overlap and implicit zeros. */</span>
                        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="n">dst_pos</span><span class="p">) {</span>
                                        <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                                        <span class="k">continue</span><span class="p">;
                                }</span>
                                <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">dst</span><span class="p">[</span><span class="n">dst_pos</span> <span class="o">-</span> <span class="n">dist</span><span class="p">];</span>
                                <span class="n">dst_pos</span><span class="o">++</span><span class="p">;
                        }
                }
        }</span>

        <span class="o">*</span><span class="n">src_used</span> <span class="o">=</span> <span class="n">istream_bytes_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">HWEXPLODE_OK</span><span class="p">;
}</span>
</pre></div>


<a name="implodeimp"></a>
<h3>Implode</h3>

<p>Since the same set of Huffman codes is used for the whole compression process, we should ideally consider all of the data to generate the best codes. Since this is not practical, we will use the same approach as for Reduce, and base our encoding on the first part of the data.</p>

<p>As for Reduce, LZ77 back references and literals will be accumulated into a fixed-size buffer, after which we compute the Huffman codes and start writing to the actual output stream. In contrast to Reduce, the LZ77 tokens are not encoded as bytes, but instead we store the actual backrefs and literals in the buffer:</p>

<div class="highlight"><pre><span></span><span class="cp">#define BUFFER_CAP (32 * 1024)</span>

<span class="k">typedef struct</span> <span class="n">implode_state_t implode_state_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">implode_state_t</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">large_wnd</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">lit_tree</span><span class="p">;</span>

        <span class="k">struct</span> <span class="p">{</span>
                <span class="kt">uint16_t</span> <span class="n">dist</span><span class="p">;</span>   <span class="cm">/* Backref dist, or 0 for literals. */</span>
                <span class="kt">uint16_t</span> <span class="n">litlen</span><span class="p">;</span> <span class="cm">/* Literal byte (dist=0) or backref length. */</span>
        <span class="p">}</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_CAP</span><span class="p">];</span>
        <span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">buffer_flushed</span><span class="p">;</span>

        <span class="kt">uint16_t</span> <span class="n">lit_freqs</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
        <span class="kt">uint16_t</span> <span class="n">dist_sym_freqs</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
        <span class="kt">uint16_t</span> <span class="n">len_sym_freqs</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

        <span class="n">ostream_t os</span><span class="p">;</span>
        <span class="n">huffman_encoder_t lit_encoder</span><span class="p">;</span>
        <span class="n">huffman_encoder_t len_encoder</span><span class="p">;</span>
        <span class="n">huffman_encoder_t dist_encoder</span><span class="p">;
};</span>
</pre></div>


<p>While inserting into the buffer, we also count the frequencies of each symbol. We will use those when generating the Huffman codes.</p>

<p>Handling literals is straight-forward:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">lit_callback</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">lit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">)
{</span>
        <span class="n">implode_state_t</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">aux</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer_flushed</span><span class="p">) {</span>
                <span class="k">return</span> <span class="n">write_lit</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">lit</span><span class="p">);
        }</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">&lt;</span> <span class="n">BUFFER_CAP</span><span class="p">);</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer_size</span>  <span class="p">].</span><span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="o">++</span><span class="p">].</span><span class="n">litlen</span> <span class="o">=</span> <span class="n">lit</span><span class="p">;</span>

        <span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_freqs</span><span class="p">[</span><span class="n">lit</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">==</span> <span class="n">BUFFER_CAP</span><span class="p">) {</span>
                <span class="k">return</span> <span class="n">flush_buffer</span><span class="p">(</span><span class="n">s</span><span class="p">);
        }</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<p>For backrefs we also have to figure out what symbols will be Huffman coded for the length and distance:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">size_t</span> <span class="nf">max_dist</span><span class="p">(</span><span class="kt">bool</span> <span class="n">large_wnd</span><span class="p">) {</span>
        <span class="k">return</span> <span class="n">large_wnd</span> <span class="o">?</span> <span class="mi">8192</span> <span class="o">:</span> <span class="mi">4096</span><span class="p">;
}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">max_len</span><span class="p">(</span><span class="kt">bool</span> <span class="n">lit_tree</span><span class="p">) {</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lit_tree</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">63</span> <span class="o">+</span> <span class="mi">255</span><span class="p">;
}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dist_sym</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">large_wnd</span><span class="p">)
{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">max_dist</span><span class="p">(</span><span class="n">large_wnd</span><span class="p">));</span>

        <span class="n">dist</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">dist</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">large_wnd</span> <span class="o">?</span> <span class="mi">7</span> <span class="o">:</span> <span class="mi">6</span><span class="p">));
}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">len_sym</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">lit_tree</span><span class="p">)
{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">lit_tree</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">2</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">max_len</span><span class="p">(</span><span class="n">lit_tree</span><span class="p">));</span>

        <span class="n">len</span> <span class="o">-=</span> <span class="p">(</span><span class="n">lit_tree</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">2</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">63</span><span class="p">) {</span>
                <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">len</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="mi">63</span><span class="p">;</span> <span class="cm">/* The remainder is in a separate byte. */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">bool</span> <span class="nf">backref_callback</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">)
{</span>
        <span class="n">implode_state_t</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">aux</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">max_dist</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">large_wnd</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_tree</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">2</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">max_len</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_tree</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer_flushed</span><span class="p">) {</span>
                <span class="k">return</span> <span class="n">write_backref</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">len</span><span class="p">);
        }</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">&lt;</span> <span class="n">BUFFER_CAP</span><span class="p">);</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer_size</span>  <span class="p">].</span><span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">dist</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="o">++</span><span class="p">].</span><span class="n">litlen</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">len</span><span class="p">;</span>

        <span class="n">s</span><span class="o">-&gt;</span><span class="n">dist_sym_freqs</span><span class="p">[</span><span class="n">dist_sym</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">large_wnd</span><span class="p">)]</span><span class="o">++</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">len_sym_freqs</span><span class="p">[</span><span class="n">len_sym</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_tree</span><span class="p">)]</span><span class="o">++</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">==</span> <span class="n">BUFFER_CAP</span><span class="p">) {</span>
                <span class="k">return</span> <span class="n">flush_buffer</span><span class="p">(</span><span class="n">s</span><span class="p">);
        }</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<p>When the buffer is full, we set up the Huffman encoders based on the frequencies of the symbols, write the symbols to the output stream, and flush the buffer:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">init_encoder</span><span class="p">(</span><span class="n">huffman_encoder_t</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">freqs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">freq_sum</span><span class="p">,</span> <span class="n">zero_freqs</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">BUFFER_CAP</span> <span class="o">&lt;=</span> <span class="n">UINT16_MAX</span> <span class="o">&amp;&amp;</span>
               <span class="s">"Frequency sum must be guaranteed to fit in 16 bits."</span><span class="p">);</span>

        <span class="n">freq_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">zero_freqs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">freq_sum</span> <span class="o">+=</span> <span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">zero_freqs</span> <span class="o">+=</span> <span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);
        }</span>

        <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">UINT16_MAX</span> <span class="o">/</span> <span class="p">(</span><span class="n">freq_sum</span> <span class="o">+</span> <span class="n">zero_freqs</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">scale_factor</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="cm">/* The Huffman encoder was designed for Deflate, which
                         * excludes zero-frequency symbols from the code. That
                         * doesn't work with Implode, so enforce a minimum
                         * frequency of one. */</span>
                        <span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="k">continue</span><span class="p">;
                }</span>

                <span class="cm">/* Scale up to emphasise difference to the zero-freq symbols. */</span>
                <span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">scale_factor</span><span class="p">;</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">);
        }</span>

        <span class="n">huffman_encoder_init</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="cm">/*max_codeword_len=*/</span> <span class="mi">16</span><span class="p">);</span>

        <span class="cm">/* Flip the bits to get the Implode-style canonical code. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">);</span>
                <span class="n">e</span><span class="o">-&gt;</span><span class="n">codewords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">lsb</span><span class="p">(</span><span class="o">~</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">codewords</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                <span class="n">e</span><span class="o">-&gt;</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]);
        }
}</span>

<span class="k">static</span> <span class="kt">bool</span> <span class="nf">write_huffman_code</span><span class="p">(</span><span class="n">ostream_t</span> <span class="o">*</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">codeword_lengths</span><span class="p">,</span>
                               <span class="kt">size_t</span> <span class="n">num_syms</span><span class="p">)
{</span>
        <span class="k">struct</span> <span class="p">{</span>
                <span class="kt">uint8_t</span> <span class="n">len</span><span class="p">;</span>
                <span class="kt">uint8_t</span> <span class="n">num</span><span class="p">;
        }</span> <span class="n">rle</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
        <span class="kt">size_t</span> <span class="n">rle_size</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">num_syms</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">num_syms</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rle</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rle</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>

        <span class="cm">/* Run-length encode the codeword lengths. */</span>
        <span class="n">rle</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">codeword_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">rle</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">rle_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_syms</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">rle</span><span class="p">[</span><span class="n">rle_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">len</span> <span class="o">==</span> <span class="n">codeword_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
                    <span class="n">rle</span><span class="p">[</span><span class="n">rle_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">num</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">) {</span>
                        <span class="n">rle</span><span class="p">[</span><span class="n">rle_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">num</span><span class="o">++</span><span class="p">;</span>
                        <span class="k">continue</span><span class="p">;
                }</span>

                <span class="n">assert</span><span class="p">(</span><span class="n">rle_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rle</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rle</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
                <span class="n">rle</span><span class="p">[</span><span class="n">rle_size</span>  <span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">codeword_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">rle</span><span class="p">[</span><span class="n">rle_size</span><span class="o">++</span><span class="p">].</span><span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;
        }</span>

        <span class="cm">/* Write the number of run-length encoded lengths. */</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">rle_size</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">rle_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="cm">/* Write the run-length encoded lengths. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rle_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">rle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">num</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">rle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">);</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">rle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">rle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">rle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">||
                    !</span><span class="n">ostream_write</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">rle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }
        }</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>

<span class="k">static</span> <span class="kt">bool</span> <span class="nf">flush_buffer</span><span class="p">(</span><span class="n">implode_state_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)
{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer_flushed</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_tree</span><span class="p">) {</span>
                <span class="n">init_encoder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_encoder</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_freqs</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_huffman_code</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_encoder</span><span class="p">.</span><span class="n">lengths</span><span class="p">,</span> <span class="mi">256</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }
        }</span>

        <span class="n">init_encoder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">len_encoder</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">len_sym_freqs</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_huffman_code</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">len_encoder</span><span class="p">.</span><span class="n">lengths</span><span class="p">,</span> <span class="mi">64</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="n">init_encoder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dist_encoder</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dist_sym_freqs</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_huffman_code</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dist_encoder</span><span class="p">.</span><span class="n">lengths</span><span class="p">,</span> <span class="mi">64</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_lit</span><span class="p">(</span><span class="n">s</span><span class="p">, (</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">litlen</span><span class="p">)) {</span>
                                <span class="k">return</span> <span class="nb">false</span><span class="p">;
                        }
                }</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_backref</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dist</span><span class="p">,</span>
                                              <span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">litlen</span><span class="p">)) {</span>
                                <span class="k">return</span> <span class="nb">false</span><span class="p">;
                        }
                }
        }</span>

        <span class="n">s</span><span class="o">-&gt;</span><span class="n">buffer_flushed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<p>With the Huffman encoders set up, we write literals and backrefs using the encoding described in the Explode section:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">write_lit</span><span class="p">(</span><span class="n">implode_state_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">lit</span><span class="p">)
{</span>
        <span class="cm">/* Literal marker bit. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_tree</span><span class="p">) {</span>
                <span class="cm">/* Huffman coded literal. */</span>
                <span class="k">return</span> <span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_encoder</span><span class="p">.</span><span class="n">codewords</span><span class="p">[</span><span class="n">lit</span><span class="p">],</span>
                                             <span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_encoder</span><span class="p">.</span><span class="n">lengths</span><span class="p">[</span><span class="n">lit</span><span class="p">]);
        }</span>

        <span class="cm">/* Raw literal. */</span>
        <span class="k">return</span> <span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">lit</span><span class="p">,</span> <span class="mi">8</span><span class="p">);
}</span>

<span class="k">static</span> <span class="kt">bool</span> <span class="nf">write_backref</span><span class="p">(</span><span class="n">implode_state_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="n">l</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">num_dist_bits</span><span class="p">,</span> <span class="n">extra_len</span><span class="p">;</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">dist_sym</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">large_wnd</span><span class="p">);</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">len_sym</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_tree</span><span class="p">);</span>

        <span class="cm">/* Backref marker bit. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="cm">/* Lower dist bits. */</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">num_dist_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">large_wnd</span> <span class="o">?</span> <span class="mi">7</span> <span class="o">:</span> <span class="mi">6</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">lsb</span><span class="p">(</span><span class="n">dist</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_dist_bits</span><span class="p">),</span>
                                   <span class="n">num_dist_bits</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="cm">/* Upper 6 dist bits, Huffman coded. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dist_encoder</span><span class="p">.</span><span class="n">codewords</span><span class="p">[</span><span class="n">d</span><span class="p">],</span>
                                   <span class="n">s</span><span class="o">-&gt;</span><span class="n">dist_encoder</span><span class="p">.</span><span class="n">lengths</span><span class="p">[</span><span class="n">d</span><span class="p">])) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="cm">/* Huffman coded length. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">len_encoder</span><span class="p">.</span><span class="n">codewords</span><span class="p">[</span><span class="n">l</span><span class="p">],</span>
                                   <span class="n">s</span><span class="o">-&gt;</span><span class="n">len_encoder</span><span class="p">.</span><span class="n">lengths</span><span class="p">[</span><span class="n">l</span><span class="p">])) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">63</span><span class="p">) {</span>
                <span class="cm">/* Extra length byte. */</span>
                <span class="n">extra_len</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">63</span> <span class="o">-</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_tree</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">2</span><span class="p">);</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">extra_len</span> <span class="o">&lt;=</span> <span class="n">UINT8_MAX</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ostream_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">,</span> <span class="n">extra_len</span><span class="p">,</span> <span class="mi">8</span><span class="p">)) {</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;
                }
        }</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<p>With all those functions in place, we can call the LZ77 code to drive the compression:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Compress (implode) the data in src into dst, using a large window and Huffman
   coding of literals as specified by the flags. The number of bytes output, at
   most dst_cap, is stored in *dst_used. Returns false if there is not enough
   room in dst. */</span>
<span class="kt">bool</span> <span class="nf">hwimplode</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">src_len</span><span class="p">,</span>
               <span class="kt">bool</span> <span class="n">large_wnd</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">lit_tree</span><span class="p">,</span>
               <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dst_cap</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">dst_used</span><span class="p">)
{</span>
        <span class="n">implode_state_t s</span><span class="p">;</span>

        <span class="n">s</span><span class="p">.</span><span class="n">large_wnd</span> <span class="o">=</span> <span class="n">large_wnd</span><span class="p">;</span>
        <span class="n">s</span><span class="p">.</span><span class="n">lit_tree</span> <span class="o">=</span> <span class="n">lit_tree</span><span class="p">;</span>
        <span class="n">s</span><span class="p">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">s</span><span class="p">.</span><span class="n">buffer_flushed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">dist_sym_freqs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">dist_sym_freqs</span><span class="p">));</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">len_sym_freqs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">len_sym_freqs</span><span class="p">));</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">lit_freqs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">lit_freqs</span><span class="p">));</span>
        <span class="n">ostream_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">.</span><span class="n">os</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">dst_cap</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lz77_compress</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">src_len</span><span class="p">,</span> <span class="n">max_dist</span><span class="p">(</span><span class="n">large_wnd</span><span class="p">),</span>
                           <span class="n">max_len</span><span class="p">(</span><span class="n">lit_tree</span><span class="p">),</span> <span class="cm">/*allow_overlap=*/</span><span class="nb">true</span><span class="p">,</span>
                           <span class="n">lit_callback</span><span class="p">,</span> <span class="n">backref_callback</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">buffer_flushed</span> <span class="o">&amp;&amp; !</span><span class="n">flush_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)) {</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;
        }</span>

        <span class="o">*</span><span class="n">dst_used</span> <span class="o">=</span> <span class="n">ostream_bytes_written</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">.</span><span class="n">os</span><span class="p">);</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;
}</span>
</pre></div>


<a name="deflate"></a>
<h3>From Implode to Deflate</h3>

<p>Since the release of PKZIP 2 in 1992, Zip files predominantly use the Deflate compression method, described in <a href="https://www.hanshq.net/zip.html">the previous article</a>. Implode is similar to Deflate in that they both combine LZ77 and Huffman coding. However now that we know the details of Implode, we can see that Deflate contains several important improvements:</p>

<ul>
<li>Deflate uses a larger <em>window</em>, allowing back reference distances up to 32 kilobytes. While small by modern standards, that's significantly larger than Implode's 8 kilobytes, and large enough to still be useful today.</li>

<li>Implode uses the same Huffman codes for all of the data, whereas Deflate breaks the data into blocks with separate Huffman codes. This allows Deflate to adapt to changes in the data. Processing the data one block at a time also allows for better streaming compression.</li>

<li>The Deflate blocks contain flags indicating the block's type and whether it's the last block, making the compressed data self-contained as opposed to Implode which relies on metadata for the uncompressed size and number of Huffman codes etc. A block can also use a pre-defined "static" Huffman code, giving it very low overhead as opposed to Implode which must always transmit at least two Huffman codes with 64 symbols each.</li>

<li>Like Implode, Deflate transmits the Huffman codes in the compression output as a set of codeword lengths, but in Deflate those codeword lengths are themselves compressed with run-length and Huffman coding in a scheme that has been described as devilishly complex. (Salomon &amp; Motta, <em>Handbook of Data Compression</em> (Springer 2010) S. 6.2.5.2)</li>
<!--"Devilishly complex" from Salomon & Motta "Handbook of Data Compression" 6.25.2 (p. 408).-->

<li>Instead of using a separate Huffman code for literal bytes, Deflate uses one Huffman code for both literal bytes and back reference lengths. The first 256 values are for literal bytes, and the other values represent lengths (or marks the end of the block). This clever trick avoids the need for a marker bit to differentiate between literals and backrefs.</li>

<li>Deflate encodes distances more efficiently, with short distances using only Huffman coding, and longer distances an increasing number of extra bits, as opposed to Implode which always uses six bits in addition to the Huffman codeword.</li>
</ul>

<p>Many of these techniques were already in use in the <a href="https://en.wikipedia.org/wiki/LHA_(file_format)">LHA</a> compression program, and it's likely that Phil Katz learned them from there. Haruhiko Okumura's <a href="https://oku.edu.mie-u.ac.jp/~okumura/compression/history.html">History of Data Compression in Japan</a> specifically mentions the combined literal and length encoding, Huffman encoding the codeword lengths, and that he was in contact with a PKZip programmer.</p>

<a name="conclusion"></a>
<h2>Conclusion</h2>

<p>We have seen above how PKZip's legacy compression methods work, and how they are implemented in HWZip. The routines in <a href="https://www.hanshq.net/files/hwzip/zip.c"><span class="code">zip.c</span></a> for reading and writing Zip files have been updated to handle the new (old) methods. The full set of source files is available in <a href="https://www.hanshq.net/files/hwzip/hwzip-2.0.zip">hwzip-2.0.zip</a>. There are <a href="https://www.hanshq.net/zip.html#build">build instructions in the previous post</a>.</p>

<p>With all the methods in place, we can compare their efficiency when compressing Shakespeare's Hamlet:</p>

<!--The sizes can be found in shrink_test.c, reduce_test.c, etc.-->
<div style="overflow-x: auto">
<table border="1">
<tbody><tr>
        <th>Method</th>
        <td>Store</td>
        <td><b>Shrink</b></td>
        <td><b>Reduce</b></td>
        <td><b>Implode</b></td>
        <td>Deflate</td>
</tr>
<tr>
        <th>Size (bytes)</th>
        <td>204,908</td>
        <td>93,900</td>
        <td>101,872</td>
        <td>85,741</td>
        <td>79,708</td>
</tr>

<tr>
        <th>Relative Size</th>
        <td>100%</td>
        <td>46%</td>
        <td>50%</td>
        <td>42%</td>
        <td>39%</td>
</tr>

<tr>
        <th>Compression Ratio</th>
        <td>1.00</td>
        <td>2.18</td>
        <td>2.01</td>
        <td>2.39</td>
        <td>2.57</td>
</tr>

<tr>
        <th>Compression Speed (MB/s)</th>
        <td>—</td>
        <td>38.2</td>
        <td>20.6</td>
        <td>38.1</td>
        <td>19.6</td>
</tr>

<tr>
        <th>Decompression Speed (MB/s)</th>
        <td>—</td>
        <td>153.9</td>
        <td>137.0</td>
        <td>256.3</td>
        <td>303.2</td>
</tr>

</tbody></table>
</div>

<p>(Reduce used compression factor 4, Implode used the large window and Huffman coded literals. Speed was measured on a laptop from 2013; the code was built with Clang 11.)</p>

<p>All methods are able to cut the size in half, with Implode being the clear winner among the legacy methods.</p>

<a name="exercises"></a>
<h2>Exercises</h2>

<ul>
<li>Write a fast decompressor for Unix Compress (<span class="code">.Z</span>) files. Use the technique of storing string lengths and last positions in the LZW dictionary.</li>

<li>Try to improve the Shrink implementation. For example, avoid the <a href="https://www.hanshq.net/zip2.html#lzwsurprise">surprising effects of partial clearing</a> by not doing partial clearing if it would clear the current code. Or consider sometimes doing a partial reset instead of increasing the code size.</li>

<li>Improve the Reduce or Implode compression by choosing the follower sets or Huffman code based on the full source data, either by using a dynamically sized buffer or by doing two passes of LZ77: one to gather statistics and one to write the data.</li>
</ul>


<a name="reading"></a>
<h2>Further Reading</h2>

<ul>
<li>Jason Summers has written <a href="https://entropymine.wordpress.com/tag/zip/">many interesting blog posts about Zip files</a>, including information about old PKZip versions, their compression methods and bugs. He has also written <a href="https://github.com/jsummers/oldunzip/">decompression routines</a> for the legacy methods.</li>

<li>Mark Nelson's <a href="https://marknelson.us/posts/1989/10/01/lzw-data-compression.html">LZW article</a> in Dr Dobb's Journal probably made the algorithm even more popular. <a href="https://marknelson.us/pages/tdcb.html">The Data Compression Book, 2nd ed.</a> (Mark Nelson &amp; Jean-loup Gailly, M&amp;T&nbsp;Books 1995) explains LZ77, LZ78, and LZW in detail, as well as how they relate to each other.</li>

<li>Mike Frysinger chronicles the history of Compress on the <a href="https://vapier.github.io/ncompress/#history">ncompress web site</a>.</li>
</ul>


<a name="files"></a>
<h2>Linked Files</h2>

<p>These are the files linked from this article and their SHA-256 hash values.</p>

<div style="overflow-x: auto">
<table border="1" style="overflow-x: auto">
<tbody><tr><td><a href="https://www.hanshq.net/files/hwzip/hwzip-2.0.zip">hwzip-2.0.zip</a></td> <td><span class="code">2136285dd19024fba551307d3cc32a429e2db9e0fb91f0ce6bf11563efe15510</span></td></tr>
<tr><td><a href="http://cd.textfiles.com/originalsw/25/pkz080.zip">pkz080.zip</a></td> <td><span class="code">a1253a1be26ee718e00ca3d4e533baeb843aae2be31d8c64cfdf47efbbcad07d</span></td></tr>
<tr><td><a href="http://cd.textfiles.com/originalsw/25/pkz090.exe">pkz090.exe</a></td> <td><span class="code">21978159874a6a388eaad3d338c0864dbcfeb8c72d80f95a2177c4c7cc3a2ac2</span></td></tr>
<tr><td><a href="https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-2.0.txt">APPNOTE-2.0.txt</a></td> <td><span class="code">688431765d2b0bc87ea8872cd7b12d5ca2405dcc2bae72046a2a70fb7f369b27</span></td></tr>
<tr><td><a href="http://cd.textfiles.com/originalsw/25/arc520.com">arc520.com</a></td> <td><span class="code">74d2d031e9edca8d1a69a56fd258c895e7118ac1e98d1c874e3ac29e7749d5b9</span></td></tr>
<tr><td><a href="https://sourceforge.net/projects/arc/files/arc/arc-5.21p/arc-5.21p.tar.gz/download">arc-5.21p.tar.gz</a></td> <td><span class="code">eacf870a245f155a4ba8c6f8e0fbb2e8a267aafa157f56ba7a8cb1d74fd8b5a1</span></td></tr>
<tr><td><a href="http://cd.textfiles.com/originalsw/25/pkx35a35.exe">pkx35a35.exe</a></td> <td><span class="code">05425765d934c38926a3108d24280e39a5452d57c8867e7e743d4f6bec30cd44</span></td></tr>
<tr><td><a href="http://cd.textfiles.com/simtel/DISK1/DISC2/ARCHIVER/SQSHINFO.DOC">SQSHINFO.DOC</a></td> <td><span class="code">82bb5048fd0070daeae17bfa3a2c702ef0ee0f31af1972f5f64ad16cb52066f2</span></td></tr>
<tr><td><a href="http://cd.textfiles.com/simtel/simtel9510/disk2/DISC2/COMPRESS/SCRNC102.ZIP">SCRNC102.ZIP</a></td> <td><span class="code">bb1663f6cfefb9f2b517b5f2ff9888ca6fe427d2b8eb8a10043be3c966ce940d</span></td></tr>
<tr><td><a href="http://cd.textfiles.com/originalsw/25/pkz101.exe">pkz101.exe</a></td> <td><span class="code">f36d9551c1917a7990db2b4582191656d748179ea2bd15499294388e9c4fa458</span></td></tr>
</tbody></table>
</div>

                        </div>
                </div>
                <div id="footer">
                        Hans Wennborg |
                        <a href="https://www.hanshq.net/">www.hanshq.net</a> |
                        hans (at) hanshq.net |
                        <a href="https://twitter.com/hansw2000">@hansw2000</a> |
                        <a href="https://www.hanshq.net/feed.rss">RSS</a>
                </div>
        </div>
</div>


<div style="background-color: rgb(255, 143, 0); display: none; color: white; text-align: center; position: fixed; top: 0px; left: 0px; width: 100%; height: auto; min-width: 100%; min-height: auto; max-width: 100%; font: 12px &quot;Helvetica Neue&quot;, Helvetica, Arial, Geneva, sans-serif; cursor: pointer; padding: 5px;"><span style="color: white; font: 12px &quot;Helvetica Neue&quot;, Helvetica, Arial, Geneva, sans-serif;">You have turned off the paragraph player. You can turn it on again from the options page.</span><img src="chrome-extension://gfjopfpjmkcfgjpogepmdjmcnihfpokn/img/icons/icon-close_16.png" style="width: 20px; height: auto; min-width: 20px; min-height: auto; max-width: 20px; float: right; margin-right: 10px;"></div></body></html>